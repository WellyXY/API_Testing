<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parrot API - Image to Video Generator</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>🎬</text></svg>">
    <style>
        /* ========== Design System ========== */
        :root {
            /* Color system - Material Design inspired */
            --primary-color: #2196f3;
            --primary-dark: #1976d2;
            --primary-light: #64b5f6;
            --accent-color: #00bcd4;
            --success-color: #4caf50;
            --warning-color: #ff9800;
            --error-color: #f44336;
            
            /* Neutral colors */
            --text-primary: #212121;
            --text-secondary: #757575;
            --text-disabled: #bdbdbd;
            --divider: #e0e0e0;
            
            /* Background colors */
            --bg-primary: #ffffff;
            --bg-secondary: #fafafa;
            --bg-tertiary: #f5f5f5;
            
            /* Spacing system - 8px grid */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
            --spacing-xxl: 40px;
            
            /* Border radius */
            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 12px;
            
            /* Shadows */
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
            --shadow-md: 0 3px 6px rgba(0,0,0,0.15), 0 2px 4px rgba(0,0,0,0.12);
            --shadow-lg: 0 10px 20px rgba(0,0,0,0.15), 0 3px 6px rgba(0,0,0,0.10);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            background: var(--bg-tertiary);
            min-height: 100vh;
            padding: var(--spacing-lg);
            color: var(--text-primary);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            background: var(--bg-primary);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            padding: var(--spacing-xl) var(--spacing-xxl);
            margin-bottom: var(--spacing-lg);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-left h1 {
            font-size: 24px;
            font-weight: 500;
            margin-bottom: var(--spacing-xs);
            color: var(--text-primary);
        }

        .header-left p {
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 400;
        }

        .header-right {
            display: flex;
            gap: var(--spacing-sm);
            align-items: center;
        }

        .content {
            display: grid !important;
            grid-template-columns: 360px 1fr !important;
            gap: var(--spacing-lg);
            align-items: start;
            width: 100%;
        }

        /* Card System */
        .card {
            background: var(--bg-primary);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--divider);
        }

        .card-title {
            font-size: 16px;
            font-weight: 500;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .card-subtitle {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: var(--spacing-xs);
        }

        .step-indicator {
            background: var(--primary-color);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 500;
        }

        .sidebar {
            position: sticky;
            top: var(--spacing-lg);
        }

        .main-area {
            min-height: 80vh;
        }

        .form-group {
            margin-bottom: var(--spacing-lg);
        }

        .form-group label {
            display: block;
            margin-bottom: var(--spacing-sm);
            font-weight: 500;
            color: var(--text-primary);
            font-size: 14px;
        }

        .hidden { display: none !important; }

        .file-upload-area {
            border: 2px dashed var(--divider);
            border-radius: var(--radius-lg);
            padding: var(--spacing-xl);
            text-align: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            background: var(--bg-primary);
            position: relative;
            overflow: hidden;
        }

        .file-upload-area:hover {
            border-color: var(--primary-color);
            background: #f5f9ff;
            box-shadow: 0 0 0 4px rgba(33, 150, 243, 0.05);
        }

        .file-upload-area.drag-over {
            border-color: var(--primary-color);
            background: #e3f2fd;
            border-style: solid;
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.2);
        }

        .upload-icon {
            font-size: 42px;
            color: var(--text-disabled);
            margin-bottom: var(--spacing-sm);
            transition: all 0.3s ease;
        }

        .file-upload-area:hover .upload-icon {
            transform: scale(1.1);
            color: var(--primary-color);
        }

        .file-upload-area.has-file {
            border-color: var(--success-color);
            background: #f1f8f4;
            border-style: solid;
        }

        .file-upload-area.has-file .upload-icon {
            color: var(--success-color);
        }

        .upload-text strong {
            display: block;
            font-size: 14px;
            color: var(--text-primary);
            margin-bottom: var(--spacing-xs);
        }

        .upload-text small {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        /* Info Badge */
        .info-badge {
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-xs);
            padding: 4px 10px;
            background: #e3f2fd;
            color: var(--primary-color);
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
        }

        /* Description Box */
        .description-box {
            background: var(--bg-secondary);
            padding: var(--spacing-md);
            border-radius: var(--radius-sm);
            border-left: 3px solid var(--primary-color);
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        input[type="file"] {
            display: none;
        }

        .form-control {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid var(--divider);
            border-radius: var(--radius-sm);
            font-size: 14px;
            font-family: inherit;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        .form-control:hover {
            border-color: var(--text-disabled);
        }

        .form-control:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
        }

        textarea.form-control {
            resize: vertical;
            min-height: 100px;
            line-height: 1.5;
        }

        /* Removed .api-config and .api-config h3 - now using card classes */

        /* Toggle Switch (iOS Style) */
        .toggle-container {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            padding: var(--spacing-md);
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
            margin-bottom: var(--spacing-md);
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 48px;
            height: 28px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .3s;
            border-radius: 28px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        input:checked + .slider {
            background-color: var(--primary-color);
        }

        input:checked + .slider:before {
            transform: translateX(20px);
        }

        .toggle-label {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
            flex: 1;
        }

        .toggle-hint {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: var(--spacing-xs);
        }

        /* Compact Select */
        .select-row {
            display: grid;
            grid-template-columns: 120px 1fr;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        .select-row label {
            font-size: 13px;
            font-weight: 500;
            color: var(--text-secondary);
            margin: 0;
        }

        /* Section Divider */
        .section-divider {
            height: 1px;
            background: var(--divider);
            margin: var(--spacing-lg) 0;
        }

        /* Benchmark Section */
        #benchmarkConfig {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-lg);
        }
        
        .benchmark-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-lg);
        }
        
        .benchmark-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
            box-shadow: 0 8px 24px rgba(102, 126, 234, 0.15);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .benchmark-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 100%);
            pointer-events: none;
        }
        
        .benchmark-section:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 32px rgba(102, 126, 234, 0.25);
        }
        
        .benchmark-section:first-child {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            box-shadow: 0 8px 24px rgba(245, 87, 108, 0.15);
        }
        
        .benchmark-section:first-child:hover {
            box-shadow: 0 12px 32px rgba(245, 87, 108, 0.25);
        }

        .benchmark-section h4 {
            font-size: 16px;
            font-weight: 600;
            color: white;
            margin-bottom: var(--spacing-lg);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            position: relative;
            z-index: 1;
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .benchmark-section .form-group {
            position: relative;
            z-index: 1;
        }
        
        .benchmark-section label {
            color: rgba(255,255,255,0.95);
            font-weight: 500;
            font-size: 13px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        
        .benchmark-section .form-control {
            background: white;
            border: 1px solid rgba(255,255,255,0.3);
            backdrop-filter: blur(10px);
            color: var(--text-primary);
            position: relative;
            z-index: 2;
        }
        
        .benchmark-section .form-control:focus {
            background: white;
            border-color: rgba(255,255,255,0.6);
            box-shadow: 0 0 0 3px rgba(255,255,255,0.2);
        }
        
        .benchmark-section select.form-control {
            background: white;
            cursor: pointer;
        }
        
        .benchmark-section select.form-control option {
            background: white;
            color: var(--text-primary);
        }
        
        .benchmark-section .description-box {
            background: rgba(255,255,255,0.15);
            border-left: 3px solid rgba(255,255,255,0.5);
            color: white;
            backdrop-filter: blur(10px);
            font-size: 11px;
            line-height: 1.4;
            max-height: 60px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .benchmark-section .description-box::before {
            content: '📋 ';
        }
        
        /* 在小屏幕上垂直排列 */
        @media (max-width: 1024px) {
            .benchmark-grid {
                grid-template-columns: 1fr;
            }
        }

        .btn {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: var(--radius-sm);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            width: 100%;
            text-transform: none;
            letter-spacing: 0;
            box-shadow: var(--shadow-sm);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-sm);
        }

        .btn:hover {
            background: var(--primary-dark);
            box-shadow: var(--shadow-md);
            transform: translateY(-1px);
        }

        .btn:active {
            transform: translateY(0);
            box-shadow: var(--shadow-sm);
        }

        .btn:disabled {
            background: var(--text-disabled);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Button Variants */
        .btn-primary {
            background: var(--primary-color);
        }

        .btn-primary:hover {
            background: var(--primary-dark);
        }

        .btn-success {
            background: var(--success-color);
        }

        .btn-success:hover {
            background: #388e3c;
        }

        /* Toggle Switch */
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--primary-color);
        }

        input:focus + .slider {
            box-shadow: 0 0 1px var(--primary-color);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-secondary:hover {
            background: #545b62;
        }

        .btn-outline {
            background: transparent;
            border: 1px solid var(--divider);
            color: var(--text-primary);
            box-shadow: none;
        }

        .btn-outline:hover {
            background: var(--bg-secondary);
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        .btn-sm {
            padding: 6px 12px;
            font-size: 12px;
        }

        .btn-lg {
            padding: 14px 28px;
            font-size: 15px;
            font-weight: 600;
        }

        /* Button Group */
        .btn-group {
            display: flex;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-md);
        }

        .btn-group .btn {
            flex: 1;
        }

        /* Icon Button */
        .icon-btn {
            width: 36px;
            height: 36px;
            padding: 0;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .status-area {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg);
            border-radius: var(--radius-md);
            background: var(--bg-secondary);
            border: 1px solid var(--divider);
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-sm) 0;
            border-bottom: 1px solid var(--divider);
        }

        .status-item:last-child {
            border-bottom: none;
        }

        .status-label {
            font-weight: 500;
            color: var(--text-primary);
            font-size: 14px;
        }

        .status-value {
            color: var(--text-secondary);
            font-size: 14px;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: var(--divider);
            border-radius: 2px;
            overflow: hidden;
            margin: var(--spacing-sm) 0;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary-color);
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            width: 0%;
        }

        .result-area {
            margin-top: var(--spacing-xl);
            text-align: center;
        }

        .video-container {
            margin: var(--spacing-lg) 0;
        }

        .video-container video {
            max-width: 100%;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
        }

        .error-message {
            background: #ffebee;
            border-left: 4px solid var(--error-color);
            color: #c62828;
            padding: var(--spacing-md);
            border-radius: var(--radius-sm);
            margin: var(--spacing-md) 0;
            font-size: 14px;
        }

        .success-message {
            background: #e8f5e9;
            border-left: 4px solid var(--success-color);
            color: #2e7d32;
            padding: var(--spacing-md);
            border-radius: var(--radius-sm);
            margin: var(--spacing-md) 0;
            font-size: 14px;
        }

        .preview-image {
            max-width: 300px;
            max-height: 200px;
            border-radius: var(--radius-md);
            margin-top: var(--spacing-md);
            box-shadow: var(--shadow-sm);
        }

        .task-card {
            background: var(--bg-primary);
            border: 1px solid var(--divider);
            border-radius: var(--radius-md);
            margin-bottom: var(--spacing-lg);
            padding: var(--spacing-lg);
            box-shadow: var(--shadow-sm);
            transition: box-shadow 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .task-card:hover {
            box-shadow: var(--shadow-md);
        }

        .task-card.completed {
            border-color: var(--success-color);
            background: #f1f8f4;
        }

        .task-card.failed {
            border-color: var(--error-color);
            background: #fef5f5;
        }

        .task-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-sm);
            border-bottom: 1px solid var(--divider);
        }

        .task-title {
            font-weight: 500;
            color: var(--text-primary);
            font-size: 14px;
        }

        .task-status {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .task-status.processing {
            background: #fff4e5;
            color: #e65100;
        }

        .task-status.completed {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .task-status.failed {
            background: #ffebee;
            color: #c62828;
        }

        .task-details {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        .task-detail-item {
            text-align: center;
        }

        .task-detail-label {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: var(--spacing-xs);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .task-detail-value {
            font-weight: 500;
            color: var(--text-primary);
            font-size: 14px;
        }

        .task-video {
            text-align: center;
            margin-top: var(--spacing-md);
        }

        /* Adjust sidebar width on smaller screens */
        @media (max-width: 1100px) {
            .content {
                grid-template-columns: 320px 1fr !important;
            }
        }

        /* Switch to single column on very small screens */
        @media (max-width: 600px) {
            .content {
                grid-template-columns: 1fr !important;
            }
            
            .sidebar {
                position: relative;
                top: 0;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: var(--spacing-sm);
            }
            
            .header {
                flex-direction: column;
                text-align: center;
                padding: var(--spacing-lg);
            }
            
            .header-left h1 {
                font-size: 20px;
            }
            
            .header-left p {
                font-size: 13px;
            }
            
            .header-right {
                width: 100%;
                justify-content: center;
                margin-top: var(--spacing-md);
            }

            .content {
                grid-template-columns: 1fr;
                gap: var(--spacing-md);
            }

            .task-details {
                grid-template-columns: repeat(2, 1fr);
                gap: var(--spacing-sm);
            }
            
            .file-upload-area {
                padding: var(--spacing-lg);
            }
            
            .select-row {
                grid-template-columns: 1fr;
                gap: var(--spacing-xs);
            }
            
            .select-row label {
                margin-bottom: var(--spacing-xs);
            }
            
            .btn-group {
                flex-direction: column;
            }
            
            .card {
                padding: var(--spacing-md);
            }
        }
    </style>
    <!-- HLS.js for streaming support -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-left">
                <h1>🎬 Parrot API</h1>
                <p>Professional Image-to-Video Generator</p>
            </div>
            <div class="header-right">
                <span class="info-badge">⚡ Fast Processing</span>
                <span class="info-badge">🎯 Multi-Provider Support</span>
            </div>
        </div>

        <div class="content">
            <div class="sidebar">


            <!-- API Configuration -->
            <div class="card">
                <div class="card-header">
                    <div>
                        <div class="card-title">
                            <span class="step-indicator">1</span>
                            API Configuration
                        </div>
                        <div class="card-subtitle">Select your provider and version</div>
                    </div>
                </div>
                
                <!-- Benchmark Toggle -->
                <div class="toggle-container">
                    <label class="switch">
                        <input type="checkbox" id="benchmarkToggle">
                        <span class="slider"></span>
                    </label>
                    <div style="flex:1;">
                        <div class="toggle-label">Benchmark Mode</div>
                        <div class="toggle-hint">Compare two API configurations side-by-side</div>
                    </div>
                </div>
                
                <!-- API Path A -->
                <div style="margin-top: var(--spacing-md);">
                    <div class="select-row">
                        <label for="apiProvider">Provider:</label>
                        <select id="apiProvider" class="form-control" onchange="updateProviderVersions()">
                            <option value="original" selected>Original - Parrot API</option>
                            <option value="testing">🧪 Testing (New Architecture)</option>
                            <option value="staging">Staging - Parrot Labs</option>
                        <option value="candy">Candy (Lipsync)</option>
                            <option value="minimax">Minimax TTS</option>
                        </select>
                    </div>

                    <div class="select-row">
                        <label for="apiVersion">Version:</label>
                        <select id="apiVersion" class="form-control" onchange="updateAPIDescription()">
                            <!-- Version options populated dynamically by JavaScript -->
                        </select>
                    </div>

                    <div class="select-row" id="endpointTypeGroup" style="display: none;">
                        <label for="endpointType">Endpoint:</label>
                        <select id="endpointType" class="form-control" onchange="updateAPIDescription()">
                            <option value="image-to-video-v2" selected>image-to-video-v2 (default)</option>
                            <option value="image-to-video">image-to-video</option>
                            <option value="image-to-video-new">image-to-video-new</option>
                            <option value="image-to-video-inner">image-to-video-inner</option>
                            <option value="image-to-video-nmd">image-to-video-nmd</option>
                            <option value="image-to-video-v2">image-to-video-v2</option>
                            <option value="audio-to-video">audio-to-video</option>
                        </select>
                    </div>
                </div>

                <!-- Benchmark Configuration -->
                <div id="benchmarkConfig" class="section hidden">
                    <div class="section-divider"></div>
                    
                    <div class="benchmark-grid">
                        <!-- Path A -->
                        <div class="benchmark-section">
                            <h4>🅰️ Path A Configuration</h4>
                            <div class="form-group">
                                <label for="promptTextA">Prompt (A)</label>
                                <textarea id="promptTextA" class="form-control" placeholder="Enter prompt for path A..." rows="3"></textarea>
                            </div>
                        </div>
                        
                        <!-- Path B -->
                        <div class="benchmark-section">
                            <h4>🅱️ Path B Configuration</h4>
                            
                            <div class="form-group">
                                <label for="apiProviderB">Provider</label>
                                <select id="apiProviderB" class="form-control" onchange="updateProviderVersionsB()">
                                    <option value="testing">🧪 Testing (New Architecture)</option>
                                    <option value="staging">Staging - Parrot Labs</option>
                                    <option value="candy">Candy (Lipsync)</option>
                                    <option value="original" selected>Original - Parrot API</option>
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label for="apiVersionB">Version</label>
                                <select id="apiVersionB" class="form-control" onchange="updateAPIDescriptionB()"></select>
                            </div>
                            
                            <div class="form-group" id="endpointTypeGroupB" style="display:none;">
                                <label for="endpointTypeB">Endpoint</label>
                                <select id="endpointTypeB" class="form-control" onchange="updateAPIDescriptionB()">
                                    <option value="image-to-video">image-to-video (default)</option>
                                    <option value="image-to-video-new">image-to-video-new</option>
                                    <option value="image-to-video-inner">image-to-video-inner</option>
                                    <option value="image-to-video-nmd">image-to-video-nmd</option>
                                    <option value="image-to-video-v2">image-to-video-v2</option>
                                    <option value="audio-to-video">audio-to-video</option>
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label for="promptTextB">Prompt (B)</label>
                                <textarea id="promptTextB" class="form-control" placeholder="Enter prompt for path B..." rows="3"></textarea>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- API Description -->
                <div class="form-group">
                    <div id="apiDescription" class="description-box">
                        Select API provider and version above
                    </div>
                </div>
                
                <!-- API Key -->
                <div class="form-group">
                    <label for="apiKey">API Key</label>
                    <input type="password" id="apiKey" class="form-control" value="" placeholder="pk-xxxxx">
                    <small style="color: var(--text-secondary); margin-top: 6px; display: block; font-size: 12px;">
                        💡 Usually starts with "pk-" prefix
                    </small>
                </div>
                
                <!-- Debug Tools -->
                <div class="btn-group">
                    <button type="button" class="btn btn-success btn-sm" onclick="testConnection()">
                        🔍 Test
                    </button>
                    <button type="button" class="btn btn-secondary btn-sm" onclick="debugCheck()">
                        🐛 Debug
                    </button>
                    <button type="button" class="btn btn-secondary btn-sm" onclick="debugTasks()">
                        📊 Tasks
                    </button>
                </div>

                <!-- Text to Audio (MiniMax) -->
                <div id="minimaxSection" class="section hidden">
                    <div class="section-divider"></div>
                    <h4 style="font-size: 14px; font-weight: 500; margin-bottom: var(--spacing-md);">🎵 Text to Audio (MiniMax)</h4>
                    
                    <div class="form-group">
                        <label for="minimaxText">Text</label>
                        <textarea id="minimaxText" class="form-control" rows="3" placeholder="Enter text to synthesize..."></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label>Voice Clone (Optional)</label>
                        <div class="file-upload-area" id="minimaxCloneUpload" style="cursor:pointer; padding: var(--spacing-lg);">
                            <div class="upload-icon">🎵</div>
                            <div class="upload-text">
                                <strong>Upload audio/video for voice cloning</strong>
                                <small>MP3/WAV/M4A/MP4 • 10-30 seconds recommended</small>
                            </div>
                            <input type="file" id="minimaxCloneFile" accept="audio/*,video/*" style="display:none;">
                            <div id="minimaxCloneFileName" style="margin-top: 8px; font-size: 12px; color: var(--text-secondary);"></div>
                        </div>
                        <div id="minimaxCloneStatus" style="margin-top:8px; font-size:12px; color:var(--text-secondary);"></div>
                        <audio id="minimaxClonePreview" controls style="display:none; margin-top:8px; width:100%;"></audio>
                    </div>
                    
                    <button type="button" class="btn btn-primary" onclick="minimaxTTS()">🔈 Generate Audio</button>
                    <a id="minimaxAudioLink" style="display:none;margin-left:8px;" download>Download</a>
                    <audio id="minimaxAudioPlayer" controls style="display:none;margin-top:8px;width:100%;"></audio>
                </div>
            </div>
            </div>
            <!-- End Sidebar -->
            
            <!-- Main Area -->
            <div class="main-area">

            <!-- Step 2: Upload Images -->
            <div class="card">
                <div class="card-header">
                    <div>
                        <div class="card-title">
                            <span class="step-indicator">2</span>
                            Upload Images
                        </div>
                        <div class="card-subtitle">Select one or multiple images (max 50)</div>
                    </div>
                    <div id="imageCount" style="font-size: 13px; color: var(--text-secondary);"></div>
                </div>
                
                <div class="file-upload-area" id="uploadArea">
                    <div class="upload-icon">📁</div>
                    <div class="upload-text">
                        <strong>Click to select or drag and drop</strong>
                        <small>JPG, PNG, GIF • Multi-select enabled • Max 50 images</small>
                    </div>
                    <input type="file" id="imageFile" accept="image/*" multiple>
                    <div id="imagePreview"></div>
                </div>
                
                <!-- Audio Upload (for audio-to-video) -->
                <div id="audioGroup" style="display: none; margin-top: var(--spacing-md);">
                    <label>🎵 Audio File (Required for audio-to-video)</label>
                    <div class="file-upload-area" id="audioUploadArea">
                        <div class="upload-icon">🎵</div>
                        <div class="upload-text">
                            <strong>Click to select audio</strong>
                            <small>MP3, WAV, M4A supported</small>
                        </div>
                        <input type="file" id="audioFile" accept="audio/*">
                        <div id="audioFileName" style="margin-top: 8px; font-size: 12px; color: var(--text-secondary);"></div>
                    </div>
                </div>
            </div>

            <!-- Step 3: Prompt & Generate -->
            <div class="card">
                <div class="card-header">
                    <div>
                        <div class="card-title">
                            <span class="step-indicator">3</span>
                            Prompt & Generate
                        </div>
                        <div class="card-subtitle">Describe the video effect (optional)</div>
                    </div>
                </div>
                
                <!-- i2i Toggle -->
                <div class="form-group" style="display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--bg-secondary); border-radius: var(--radius-md); margin-bottom: var(--spacing-md);">
                    <label style="margin: 0; font-weight: 500; display: flex; align-items: center; gap: 8px;">
                        🎨 Enable reference image
                    </label>
                    <label class="switch" style="margin-left: auto;">
                        <input type="checkbox" id="i2iToggle" onchange="toggleI2IMode()">
                        <span class="slider"></span>
                    </label>
                </div>

                <!-- Sticking Video Toggle -->
                <div class="form-group" style="display: flex; align-items: center; gap: 12px; padding: 12px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: var(--radius-md); margin-bottom: var(--spacing-md); color: white;">
                    <label style="margin: 0; font-weight: 500; display: flex; align-items: center; gap: 8px;">
                        🎬 Sticking Video (AI Prompt Generation)
                    </label>
                    <label class="switch" style="margin-left: auto;">
                        <input type="checkbox" id="stickingVideoToggle" onchange="toggleStickingVideoMode()">
                        <span class="slider"></span>
                    </label>
                </div>
                <div id="stickingVideoHint" class="description-box" style="display: none; margin-bottom: var(--spacing-md);">
                    ⚡ <strong>Sticking Video Mode:</strong> AI will generate 3 image variants from your reference, then create videos for each variant. This will produce 3 final videos.
                </div>

                <!-- Prompt (unified for both i2i and i2v) -->
                <div class="form-group">
                    <label for="promptText">
                        <span id="promptLabel">Prompt</span>
                        <span id="promptHint" style="font-size: 12px; color: var(--text-secondary);">(for video generation)</span>
                    </label>
                    <textarea id="promptText" class="form-control" rows="3" placeholder="E.g., a beautiful sunset scene with gentle waves..."></textarea>
                </div>

                <div class="btn-group">
                    <button class="btn btn-outline btn-sm" onclick="clearAllImages()">
                        🗑️ Clear Images
                    </button>
                    <button class="btn btn-outline btn-sm" onclick="downloadLogs()">
                        📥 Logs
                    </button>
                </div>

                <button class="btn btn-primary btn-lg" id="generateBtn" onclick="onStartButtonClick()">
                    <span id="generateBtnText">🚀 Generate Videos</span>
                </button>
            </div>

            <!-- Processing Progress -->
            <div id="batchProgressArea" class="card" style="display: none;">
                <div class="card-header">
                    <div class="card-title">📊 Processing Progress</div>
                </div>
                <div style="margin-bottom: var(--spacing-sm);">
                    <span id="batchProgressText" style="font-size: 14px; font-weight: 500; color: var(--text-primary);">Processing...</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="batchProgressFill"></div>
                </div>
                <div style="font-size: 12px; color: var(--text-secondary); margin-top: var(--spacing-sm);">
                    <span id="batchProgressDetail">Starting processing...</span>
                </div>
            </div>

            <!-- Batch Download -->
            <div class="card" id="downloadAllCard" style="display: none;">
                <div class="card-header">
                    <div class="card-title">📦 Batch Download</div>
                </div>
                <button class="btn btn-success" id="downloadAllBtn" onclick="downloadAllVideos()">
                    📦 Download All Completed Videos
                </button>
                <div style="margin-top: var(--spacing-sm); font-size: 12px; color: var(--text-secondary);">
                    💡 Videos will be named after their corresponding images
                </div>
            </div>

            <!-- Sticking Video Merge Download -->
            <div class="card" id="downloadStickingCard" style="display: none; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                <div class="card-header" style="border-bottom-color: rgba(255,255,255,0.2);">
                    <div class="card-title" style="color: white;">🎬 Sticking Video Merge</div>
                </div>
                <button class="btn btn-success" id="downloadStickingBtn" onclick="downloadMergedStickingVideos()" style="background: white; color: #667eea; font-weight: 600;">
                    💫 Merge & Download (Fade Effect)
                </button>
                <div style="margin-top: var(--spacing-sm); font-size: 12px; color: rgba(255,255,255,0.9); background: rgba(0,0,0,0.2); padding: 8px; border-radius: 4px;">
                    💡 Merges 3 variants with smooth fade transitions
                </div>
            </div>

            <!-- Task Management -->
            <div class="tasks-area" id="tasksArea" style="display: none;">
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">📊 Task Management</div>
                    </div>
                    <div class="task-summary" id="taskSummary" style="padding: var(--spacing-md); background: var(--bg-secondary); border-radius: var(--radius-md); margin-bottom: var(--spacing-md);">
                        <div style="display: flex; justify-content: space-between; align-items: center; font-size: 13px;">
                            <span>📈 Total: <strong id="totalTasks">0</strong> tasks</span>
                            <span>⏱️ Avg Time: <strong id="averageTime">-</strong></span>
                        </div>
                    </div>
                    <div id="tasksList"></div>
                </div>
            </div>

            <!-- Benchmark Results -->
            <div id="benchmarkResults" class="card" style="display:none;">
                <div class="card-header">
                    <div class="card-title">🧪 Benchmark Results (A vs B)</div>
                    <div style="display:flex; gap:var(--spacing-sm);">
                        <button class="btn btn-success btn-sm" id="downloadMergedBtn" onclick="downloadMergedBenchmark()">⬇️ Top Pair</button>
                        <button class="btn btn-outline btn-sm" id="downloadMergedAllBtn" onclick="downloadMergedAll()">⬇️ All (ZIP)</button>
                    </div>
                </div>
                <div id="benchmarkPairs" style="display:flex; flex-direction:column; gap:var(--spacing-md);"></div>
            </div>
            <!-- End Benchmark Results Card -->
            
            </div>
            <!-- End Main Area -->
            
        </div>
        <!-- End Content (two-column layout) -->
        
    </div>
    <!-- End Container -->

    <script>
        // Multi-task management
        let tasks = new Map(); // Store task information
        let imageQueue = []; // Image queue for processing
        let processingInterval = null; // Queue manager timer
        let globalTaskCounter = 0;
        let statusCheckInterval = null;
        let pendingSubmissions = 0; // Pending submissions not yet added to tasks Map
        
        // API Provider and version configuration
        const API_PROVIDERS = {
            'testing': {
                name: 'Testing (New Architecture)',
                description: '新测试架构 - 需要 SSH 隧道',
                baseUrl: 'http://localhost:9580',
                apiKey: 'test-api-key-123456',
                versions: {
                    'v1': {
                        endpoints: {
                            'image-to-video': {
                                path: '/api/v1/generate/v0/image-to-video',
                                description: 'Image to Video - v1 (新架构)',
                                name: 'Testing v1 (image-to-video)',
                                queryPath: '/api/v1/generate/v0/videos' // 查询路径
                            }
                        },
                        defaultEndpoint: 'image-to-video-v2',
                        description: 'Image to Video - v1 (新测试架构)',
                        name: 'Testing v1'
                    }
                }
            },
            'original': {
                name: 'Original',
                description: 'Original Parrot API Server',
                baseUrl: 'https://qazwsxedcrf3g5h.pika.art',
                apiKey: 'pk_GW7ITxUVnC271AoJaasgdATrmzjl4OnQKTmD2j6tLZM',
                versions: {
                    'v0': {
                        endpoints: {
                            'image-to-video': {
                                path: '/generate/v0/image-to-video',
                                description: 'Image to Video - v0 (default)',
                                name: 'Original v0 (default)'
                            },
                            'image-to-video-new': {
                                path: '/generate/v0/image-to-video-new',
                                description: 'Image to Video - v0 (new endpoint)',
                                name: 'Original v0 (new)'
                            },
                            'image-to-video-inner': {
                                path: '/generate/v0/image-to-video-inner',
                                description: 'Image to Video - v0 (internal endpoint)',
                                name: 'Original v0 (internal)'
                            },
                            'image-to-video-nmd': {
                                path: '/generate/v0/image-to-video-nmd',
                                description: 'Image to Video - v0 (NMD endpoint)',
                                name: 'Original v0 (nmd)'
                            },
                            'image-to-video-v2': {
                                path: '/generate/v0/image-to-video-v2',
                                description: 'Image to Video - v2 (new version)',
                                name: 'Original v0 (v2)'
                            },
                            'audio-to-video': {
                                path: '/generate/v0/audio-to-video',
                                description: 'Image + Audio to Video - v0',
                                name: 'Original v0 (audio-to-video)'
                            }
                        },
                        defaultEndpoint: 'image-to-video',
                        description: 'Image to Video - v0',
                        name: 'Original v0'
                    }
                }
            },
            'staging': {
                name: 'Staging',
                description: 'Parrot Labs API Server',
                baseUrl: 'https://089e99349ace.pikalabs.app',
                apiKey: 'pk_fnOLPQFrhk96QscYG9hIUSw-Jn5ygl_ehSUWa9PvwZM',
                versions: {
                    'v2.2': {
                        endpoint: '/generate/2.2/i2v',
                        description: '圖片轉視頻 - v2.2 版本',
                        name: 'Staging v2.2'
                    }
                }
            },
            'candy': {
                name: 'Candy (Lipsync)',
                description: 'Pika Candy audio-to-video (lipsync)',
                baseUrl: 'https://candy-api.pika.art',
                apiKey: 'test-api-key-123456',
                versions: {
                    'v0': {
                        endpoints: {
                            'audio-to-video': {
                                path: '/api/v1/generate/v0/audio-to-video',
                                description: 'Image + Audio to Video (lipsync)',
                                name: 'Candy v0 (audio-to-video)'
                            }
                        },
                        defaultEndpoint: 'audio-to-video',
                        description: 'Audio to Video - v0',
                        name: 'Candy v0'
                    }
                }
            },
            'minimax': {
                name: 'Minimax text to audio',
                description: 'MiniMax 文本轉語音',
                baseUrl: '',
                versions: {
                    'v1': {
                        endpoint: '/minimax/t2a',
                        description: '文本轉語音 - v1',
                        name: 'Text to Audio'
                    }
                }
            }
        };

        // 獲取當前API配置 - 現在支持動態選擇
        function getCurrentAPIConfig() {
            const provider = document.getElementById('apiProvider')?.value || 'staging';
            const apiVersion = document.getElementById('apiVersion')?.value || 'v2.2';
            const endpointType = document.getElementById('endpointType')?.value;
            const versionConfig = API_PROVIDERS[provider]?.versions[apiVersion];
            
            let endpoint = '/generate/2.2/i2v'; // 默認
            
            if (versionConfig) {
                if (versionConfig.endpoints) {
                    // Original API v0 支持多個端點
                    const selectedEndpoint = endpointType && versionConfig.endpoints[endpointType] 
                        ? versionConfig.endpoints[endpointType] 
                        : versionConfig.endpoints[versionConfig.defaultEndpoint];
                    endpoint = selectedEndpoint.path;
                } else {
                    // 單一端點（Staging 或 Minimax）
                    endpoint = versionConfig.endpoint;
                }
            }
            
            return {
                provider: provider,
                version: apiVersion,
                endpoint: endpoint,
                endpointType: endpointType
            };
        }

        // 更新提供商版本選項
        function updateProviderVersions() {
            const providerSelect = document.getElementById('apiProvider');
            const versionSelect = document.getElementById('apiVersion');
            const endpointTypeGroup = document.getElementById('endpointTypeGroup');
            
            if (!providerSelect || !versionSelect) return;
            
            const selectedProvider = providerSelect.value || 'original';
            const providerConfig = API_PROVIDERS[selectedProvider];
            
            // 清空版本選項
            versionSelect.innerHTML = '';
            
            // 添加版本選項
            if (providerConfig && providerConfig.versions) {
                Object.keys(providerConfig.versions).forEach(versionKey => {
                    const version = providerConfig.versions[versionKey];
                    const option = document.createElement('option');
                    option.value = versionKey;
                    option.textContent = version.name || versionKey;
                    versionSelect.appendChild(option);
                });
            }
            
            // 若為 original，強制選擇 v0
            if (selectedProvider === 'original') {
                versionSelect.value = 'v0';
            }

            // 檢查是否需要顯示端點類型選擇器
            if (endpointTypeGroup) {
                const selectedVersion = versionSelect.value;
                const versionConfig = providerConfig?.versions[selectedVersion];
                
                if (versionConfig && versionConfig.endpoints) {
                    // Original API v0 支持多個端點
                    endpointTypeGroup.style.display = 'block';
                } else {
                    // Staging API 或其他版本使用單一端點
                    endpointTypeGroup.style.display = 'none';
                }
            }
            
            // 切換 UI：Minimax 下隱藏圖片/生成視頻相關，顯示 T2A 區塊
            const isMinimax = selectedProvider === 'minimax';
            const isCandy = selectedProvider === 'candy';
            document.getElementById('uploadArea')?.closest('.form-group')?.classList.toggle('hidden', isMinimax);
            document.getElementById('audioGroup')?.classList.toggle('hidden', isMinimax ? false : false);
            // Candy 與 Original/Staging 顯示主生成區塊；Minimax 隱藏
            document.getElementById('promptText')?.closest('.form-group')?.classList.toggle('hidden', isMinimax);
            document.getElementById('generateBtn')?.classList.toggle('hidden', isMinimax);
            // 顯示/隱藏 minimax 區塊
            document.getElementById('minimaxSection')?.classList.toggle('hidden', !isMinimax);

            // 自動填入 Minimax 憑證（僅當留空時）
            if (isMinimax) {
                try {
                    fetch('/minimax/env?full=1').then(r => r.json()).then(env => {
                        const gidEl = document.getElementById('minimaxGroupId');
                        const keyEl = document.getElementById('minimaxApiKey');
                        if (gidEl && !gidEl.value && env.group_id) gidEl.value = env.group_id;
                        if (keyEl && !keyEl.value && env.api_key) keyEl.value = env.api_key;
                    }).catch(() => {});
                } catch {}
            }

            // 同步當前 provider 的默認 API Key 到輸入框（避免使用錯誤 provider 的 key）
            try {
                const keyInput = document.getElementById('apiKey');
                if (keyInput) {
                    keyInput.value = providerConfig?.apiKey || '';
                }
            } catch {}

            // 切換到 candy 時，預設選中 audio-to-video 並顯示音訊上傳
            if (selectedProvider === 'candy') {
                const et = document.getElementById('endpointType');
                if (et) et.value = 'audio-to-video';
                document.getElementById('audioGroup')?.classList.remove('hidden');
            }

            updateAPIDescription();
        }

        // Benchmark: 更新 B 路的提供商/版本/端點顯示
        function updateProviderVersionsB() {
            const providerSelect = document.getElementById('apiProviderB');
            const versionSelect = document.getElementById('apiVersionB');
            const endpointTypeGroup = document.getElementById('endpointTypeGroupB');
            if (!providerSelect || !versionSelect) return;
            const selectedProvider = providerSelect.value || 'original';
            const providerConfig = API_PROVIDERS[selectedProvider];
            versionSelect.innerHTML = '';
            if (providerConfig && providerConfig.versions) {
                Object.keys(providerConfig.versions).forEach(versionKey => {
                    const version = providerConfig.versions[versionKey];
                    const option = document.createElement('option');
                    option.value = versionKey;
                    option.textContent = version.name || versionKey;
                    versionSelect.appendChild(option);
                });
            }

            // Default to original/v0 and endpoint image-to-video-v2
            if (selectedProvider === 'original') {
                versionSelect.value = 'v0';
                const et = document.getElementById('endpointType');
                if (et) et.value = 'image-to-video-v2';
            }
            if (endpointTypeGroup) {
                const selectedVersion = versionSelect.value;
                const versionConfig = providerConfig?.versions[selectedVersion];
                if (versionConfig && versionConfig.endpoints) {
                    endpointTypeGroup.style.display = 'block';
                } else {
                    endpointTypeGroup.style.display = 'none';
                }
            }
            // 自動填入 B 的默認 key
            try {
                const keyInput = document.getElementById('apiKeyB');
                if (keyInput) keyInput.value = providerConfig?.apiKey || '';
            } catch {}
            updateAPIDescriptionB();
        }

        function getCurrentAPIConfigB() {
            const provider = document.getElementById('apiProviderB')?.value || 'staging';
            const apiVersion = document.getElementById('apiVersionB')?.value || 'v2.2';
            const endpointType = document.getElementById('endpointTypeB')?.value;
            const versionConfig = API_PROVIDERS[provider]?.versions[apiVersion];
            let endpoint = '/generate/2.2/i2v';
            if (versionConfig) {
                if (versionConfig.endpoints) {
                    const selectedEndpoint = endpointType && versionConfig.endpoints[endpointType]
                        ? versionConfig.endpoints[endpointType]
                        : versionConfig.endpoints[versionConfig.defaultEndpoint];
                    endpoint = selectedEndpoint.path;
                } else {
                    endpoint = versionConfig.endpoint;
                }
            }
            return { provider, version: apiVersion, endpoint, endpointType };
        }

        function updateAPIDescriptionB() {
            const provider = document.getElementById('apiProviderB')?.value;
            const version = document.getElementById('apiVersionB')?.value;
            const endpointType = document.getElementById('endpointTypeB')?.value;
            const descElement = document.getElementById('apiDescriptionB');
            if (!descElement || !provider || !version) return;
            const providerConfig = API_PROVIDERS[provider];
            const versionConfig = providerConfig?.versions[version];
            if (providerConfig && versionConfig) {
                // 简化描述文字
                let description = `${version}`;
                if (versionConfig.endpoints && endpointType) {
                    const endpointConfig = versionConfig.endpoints[endpointType];
                    if (endpointConfig) {
                        // 只显示 endpoint 类型，不显示完整描述
                        description += ` • ${endpointType}`;
                    }
                } else {
                    description = versionConfig.description;
                }
                descElement.textContent = description;
            }
        }

        // 根據端點類型顯示/隱藏音頻上傳
        function refreshAudioVisibility() {
            const endpointType = document.getElementById('endpointType')?.value;
            const audioGroup = document.getElementById('audioGroup');
            if (!audioGroup) return;
            if (endpointType === 'audio-to-video') {
                audioGroup.style.display = 'block';
            } else {
                audioGroup.style.display = 'none';
            }
        }
        document.getElementById('endpointType')?.addEventListener('change', refreshAudioVisibility);
        // 初次渲染時也刷新一次
        window.addEventListener('load', refreshAudioVisibility);

        // 更新API描述
        function updateAPIDescription() {
            const provider = document.getElementById('apiProvider')?.value;
            const version = document.getElementById('apiVersion')?.value;
            const endpointType = document.getElementById('endpointType')?.value;
            const descElement = document.getElementById('apiDescription');
            
            if (!descElement || !provider || !version) return;
            
            const providerConfig = API_PROVIDERS[provider];
            const versionConfig = providerConfig?.versions[version];
            
            if (providerConfig && versionConfig) {
                let description = `${providerConfig.description} - ${versionConfig.description}`;
                
                // 如果是 Original API v0，添加端點類型信息
                if (versionConfig.endpoints && endpointType) {
                    const endpointConfig = versionConfig.endpoints[endpointType];
                    if (endpointConfig) {
                        description += ` (${endpointConfig.description})`;
                    }
                }
                
                descElement.textContent = description;
            }
        }
        
        // 任務數據結構
        function createTask(videoId, promptText, imageName) {
            return {
                id: videoId,
                taskNumber: ++globalTaskCounter,
                status: 'waiting',
                progress: 0,
                promptText: promptText || '',
                imageName: imageName || '',
                startTime: null,
                endTime: null,
                duration: 0,
                // 新增計時字段
                submittedAt: null,
                startedAt: null,
                finishedAt: null,
                waitDurationSec: null,
                genDurationSec: null,
                url: null,
                created: new Date(),
                retryCount: 0,
                benchmarkLabel: window.benchmarkLabel || ''
            };
        }

        // 文件上傳處理
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('imageFile');
        const imagePreview = document.getElementById('imagePreview');

            // 點擊上傳區域（若選擇 audio-to-video，點擊音頻區域也能觸發）
            uploadArea.addEventListener('click', () => {
                fileInput.click();
            });

            // 音頻區域點擊/拖拽
            const audioGroup = document.getElementById('audioGroup');
            const audioInput = document.getElementById('audioFile');
            const audioUploadArea = document.getElementById('audioUploadArea');
            const audioFileName = document.getElementById('audioFileName');
            
            audioUploadArea?.addEventListener('click', () => audioInput?.click());
            audioUploadArea?.addEventListener('dragover', (e) => {
                e.preventDefault();
                audioUploadArea.classList.add('drag-over');
            });
            audioUploadArea?.addEventListener('dragleave', () => audioUploadArea.classList.remove('drag-over'));
            audioUploadArea?.addEventListener('drop', (e) => {
                e.preventDefault();
                audioUploadArea.classList.remove('drag-over');
                if (e.dataTransfer?.files?.length) {
                    const f = e.dataTransfer.files[0];
                    audioInput.files = e.dataTransfer.files;
                    audioUploadArea.classList.add('has-file');
                    if (audioFileName) audioFileName.textContent = `Selected: ${f.name}`;
                }
            });
            audioInput?.addEventListener('change', () => {
                const f = audioInput.files?.[0];
                if (f) {
                    audioUploadArea?.classList.add('has-file');
                    if (audioFileName) audioFileName.textContent = `Selected: ${f.name}`;
                } else {
                    audioUploadArea?.classList.remove('has-file');
                    if (audioFileName) audioFileName.textContent = '';
                }
            });

        // 拖拽上傳
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('drag-over');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('drag-over');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('drag-over');
            const files = Array.from(e.dataTransfer.files);
            if (files.length > 0) {
                handleMultipleFileSelect(files);
            }
        });

        // 文件選擇處理
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleMultipleFileSelect(Array.from(e.target.files));
            }
        });

        let selectedImages = []; // 全局變量存儲選中的圖片

        async function handleMultipleFileSelect(files) {
            // 過濾出圖片文件
            const imageFiles = files.filter(file => file.type.startsWith('image/'));
            
            if (imageFiles.length === 0) {
                showError('Please select image files');
                return;
            }

            // 檢查是否會超過50張限制
            const totalAfterAdd = selectedImages.length + imageFiles.length;
            if (totalAfterAdd > 50) {
                const canAdd = 50 - selectedImages.length;
                if (canAdd <= 0) {
                    showError('Maximum 50 images allowed. Please remove some images first.');
                    return;
                } else {
                    showError(`Only ${canAdd} more image(s) can be added (max 50 total). Only first ${canAdd} will be added.`);
                    imageFiles.splice(canAdd); // 只保留前canAdd個文件
                }
            }

            // 防止重複圖片（根據文件名和大小）
            const newUniqueImages = [];
            imageFiles.forEach(newFile => {
                const isDuplicate = selectedImages.some(existingFile => 
                    existingFile.name === newFile.name && existingFile.size === newFile.size
                );
                if (!isDuplicate) {
                    newUniqueImages.push(newFile);
                }
            });

            // 自動將 AVIF 轉為 JPG
            const finalFiles = [];
            for (const f of newUniqueImages) {
                if (isAvifFile(f)) {
                    try {
                        const converted = await convertAvifToJpeg(f);
                        finalFiles.push(converted);
                    } catch (e) {
                        // 轉換失敗則回退使用原文件
                        console.warn('AVIF to JPEG conversion failed, using original file:', e);
                        finalFiles.push(f);
                    }
                } else {
                    finalFiles.push(f);
                }
            }

            if (newUniqueImages.length === 0) {
                showError('All selected images are already added');
                return;
            }

            if (newUniqueImages.length < imageFiles.length) {
                const duplicateCount = imageFiles.length - newUniqueImages.length;
                showSuccess(`${newUniqueImages.length} image(s) added. ${duplicateCount} duplicate(s) skipped.`);
            }

            // 將新的唯一圖片（含轉換後 JPG）添加到選中列表
            selectedImages = [...selectedImages, ...finalFiles];
            
            // 更新 file input 的 files 屬性
            updateFileInput();
            
            // 顯示預覽
            displayImagePreviews();
            
            // 更新上傳區域狀態
            uploadArea.classList.add('has-file');
            updateUploadAreaText();
        }

        function isAvifFile(file) {
            return file && (file.type === 'image/avif' || /\.avif$/i.test(file.name || ''));
        }

        async function convertAvifToJpeg(file) {
            const url = URL.createObjectURL(file);
            try {
                // 優先使用 createImageBitmap
                try {
                    const bitmap = await createImageBitmap(file);
                    const canvas = document.createElement('canvas');
                    canvas.width = bitmap.width;
                    canvas.height = bitmap.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(bitmap, 0, 0);
                    const jpegBlob = await new Promise((resolve, reject) => {
                        canvas.toBlob(b => b ? resolve(b) : reject(new Error('toBlob failed')), 'image/jpeg', 0.92);
                    });
                    const newName = (file.name || 'image').replace(/\.avif$/i, '.jpg');
                    return new File([jpegBlob], newName, { type: 'image/jpeg' });
                } catch (_) {
                    // 回退使用 HTMLImageElement
                    const image = await new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => resolve(img);
                        img.onerror = reject;
                        img.src = url;
                    });
                    const canvas = document.createElement('canvas');
                    canvas.width = image.width;
                    canvas.height = image.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(image, 0, 0);
                    const jpegBlob = await new Promise((resolve, reject) => {
                        canvas.toBlob(b => b ? resolve(b) : reject(new Error('toBlob failed')), 'image/jpeg', 0.92);
                    });
                    const newName = (file.name || 'image').replace(/\.avif$/i, '.jpg');
                    return new File([jpegBlob], newName, { type: 'image/jpeg' });
                }
            } finally {
                URL.revokeObjectURL(url);
            }
        }

        function updateFileInput() {
            // 創建新的 DataTransfer 對象來更新 file input
            const dt = new DataTransfer();
            selectedImages.forEach(file => {
                dt.items.add(file);
            });
            fileInput.files = dt.files;
        }

        function displayImagePreviews() {
            if (selectedImages.length === 0) {
                imagePreview.innerHTML = '';
                uploadArea.classList.remove('has-file');
                updateUploadAreaText();
                return;
            }

            let previewHTML = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px; margin-top: 15px;">';
            
            selectedImages.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const previewItem = document.createElement('div');
                    previewItem.style.cssText = 'position: relative; text-align: center; background: #f8f9fa; border-radius: 8px; padding: 8px;';
                    previewItem.innerHTML = `
                        <img src="${e.target.result}" style="width: 100%; height: 80px; object-fit: cover; border-radius: 6px;" alt="Preview ${index + 1}">
                        <div style="font-size: 11px; color: #666; margin-top: 4px; word-break: break-all;">${file.name}</div>
                        <div style="font-size: 10px; color: #999;">${(file.size / 1024 / 1024).toFixed(2)} MB</div>
                        <button onclick="removeImage(${index})" style="position: absolute; top: 2px; right: 2px; background: #ff4757; color: white; border: none; border-radius: 50%; width: 20px; height: 20px; font-size: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center;">×</button>
                    `;
                    
                    // 更新預覽容器
                    const container = document.getElementById('imagePreview');
                    if (!container.querySelector('.preview-grid')) {
                        container.innerHTML = '<div class="preview-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px; margin-top: 15px;"></div>';
                    }
                    const grid = container.querySelector('.preview-grid');
                    grid.appendChild(previewItem);
                };
                reader.readAsDataURL(file);
            });
        }

        function removeImage(index) {
            selectedImages.splice(index, 1);
            updateFileInput();
            
            // 重新顯示所有預覽
            imagePreview.innerHTML = '';
            if (selectedImages.length > 0) {
                displayImagePreviews();
            } else {
                uploadArea.classList.remove('has-file');
            }
            updateUploadAreaText();
        }

        function updateUploadAreaText() {
            const uploadText = document.querySelector('.upload-text');
            const imageCountDiv = document.getElementById('imageCount');
            
            if (selectedImages.length === 0) {
                uploadText.innerHTML = '<strong>Click to select image(s)</strong> or drag and drop them here<br><small>Supports JPG, PNG, GIF formats • Multi-select enabled • Max 50 images</small>';
                imageCountDiv.textContent = '';
            } else {
                const remaining = 50 - selectedImages.length;
                if (remaining > 0) {
                    uploadText.innerHTML = `<strong>${selectedImages.length}/50 image(s) selected</strong><br><small>Click to add ${remaining} more images or drag and drop</small>`;
                    imageCountDiv.textContent = `${selectedImages.length}/50 images selected`;
                } else {
                    uploadText.innerHTML = `<strong>50/50 images selected (Maximum reached)</strong><br><small>Remove some images to add different ones</small>`;
                    imageCountDiv.textContent = `50/50 images selected (Max reached)`;
                }
            }
        }

        // i2i Mode Toggle
        function toggleI2IMode() {
            const i2iToggle = document.getElementById('i2iToggle');
            const stickingVideoToggle = document.getElementById('stickingVideoToggle');
            const generateBtnText = document.getElementById('generateBtnText');
            const promptHint = document.getElementById('promptHint');
            
            // Disable sticking video if i2i is enabled
            if (i2iToggle.checked) {
                stickingVideoToggle.checked = false;
                stickingVideoToggle.disabled = true;
                document.getElementById('stickingVideoHint').style.display = 'none';
                generateBtnText.textContent = '🎨 Generate Videos';
                promptHint.textContent = '(with reference image)';
            } else {
                stickingVideoToggle.disabled = false;
                generateBtnText.textContent = '🚀 Generate Videos';
                promptHint.textContent = '(for video generation)';
            }
        }

        // Sticking Video Mode Toggle
        function toggleStickingVideoMode() {
            const stickingVideoToggle = document.getElementById('stickingVideoToggle');
            const i2iToggle = document.getElementById('i2iToggle');
            const generateBtnText = document.getElementById('generateBtnText');
            const promptHint = document.getElementById('promptHint');
            const stickingVideoHint = document.getElementById('stickingVideoHint');
            
            if (stickingVideoToggle.checked) {
                // Disable i2i if sticking video is enabled
                i2iToggle.checked = false;
                i2iToggle.disabled = true;
                stickingVideoHint.style.display = 'block';
                generateBtnText.textContent = '🎬 Generate Sticking Videos (3x)';
                promptHint.textContent = '(AI will generate variants)';
            } else {
                i2iToggle.disabled = false;
                stickingVideoHint.style.display = 'none';
                generateBtnText.textContent = '🚀 Generate Videos';
                promptHint.textContent = '(for video generation)';
            }
        }

        // Process Sticking Video - Generate prompts and create multiple variants
        async function processStickingVideo(imageFile, videoPrompt) {
            console.log('🎬 Starting Sticking Video process...');
            console.log(`📷 Image: ${imageFile.name}`);
            console.log(`📝 Video Prompt: ${videoPrompt}`);
            
            try {
                // Step 1: Call backend to generate prompts
                showSuccess(`🤖 Generating AI prompts for ${imageFile.name}...`);
                
                const formData = new FormData();
                formData.append('image', imageFile);
                formData.append('video_prompt', videoPrompt);
                
                console.log('📤 [Gemini] Sending request to /generate-prompts...');
                console.log(`📤 [Gemini] Image: ${imageFile.name}, Size: ${(imageFile.size / 1024).toFixed(2)}KB`);
                console.log(`📤 [Gemini] Video Prompt: ${videoPrompt}`);
                
                const startTime = Date.now();
                const response = await fetch('/generate-prompts', {
                    method: 'POST',
                    body: formData
                });
                
                const elapsed = ((Date.now() - startTime) / 1000).toFixed(2);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`❌ [Gemini] Failed after ${elapsed}s: ${response.status}`);
                    throw new Error(`Prompt generation failed: ${response.status} - ${errorText}`);
                }
                
                const result = await response.json();
                console.log(`✅ [Gemini] Completed in ${elapsed}s`);
                console.log('✅ [Gemini] Generated prompts:', result);
                
                let imagePrompts = result.image_prompts || [];
                let videoPrompts = result.video_prompts || [];
                if (imagePrompts.length > 2) imagePrompts = imagePrompts.slice(0, 2);
                if (videoPrompts.length > 2) videoPrompts = videoPrompts.slice(0, 2);
                
                if (imagePrompts.length === 0 || videoPrompts.length === 0) {
                    throw new Error('No prompts generated');
                }
                
                showSuccess(`✅ Generated ${imagePrompts.length} prompt variants! Starting baseline + variants...`);
                
                // Step 2: 基線(直接 i2v) + 變體(兩條：i2i→i2v)
                console.log('🚀 Starting parallel processing: baseline + variants...');

                // 基線：使用上傳圖片 + 原始視頻 Prompt 作為第1條
                const baselinePromise = (async () => {
                    try {
                        showSuccess('🎬 [1/3] Submitting baseline video (reference image + original prompt)...');
                        window.stickingVideoOverridePrompt = videoPrompt;
                        window.stickingVideoVariantIndex = 1;
                        window.stickingVideoTotalVariants = imagePrompts.length + 1;
                        await submitTaskForStickingVideo(imageFile, videoPrompt, 1, imageFile.name, '(baseline)');
                        console.log('✅ Baseline video submitted');
                    } finally {
                        window.stickingVideoOverridePrompt = null;
                        window.stickingVideoVariantIndex = null;
                        window.stickingVideoTotalVariants = null;
                    }
                })();
                
                // 并行生成所有图片变体
                const i2iPromises = imagePrompts.map(async (imagePrompt, i) => {
                    console.log(`\n${'='.repeat(70)}`);
                    console.log(`🎨 Processing variant ${i + 1}/${imagePrompts.length} (parallel)`);
                    console.log(`${'='.repeat(70)}`);
                    console.log(`📝 Image Prompt: ${imagePrompt.substring(0, 100)}...`);
                    
                    try {
                        showSuccess(`🎨 [${i + 1}/${imagePrompts.length}] Generating image variant (parallel)...`);
                        const processedImage = await processI2I(imageFile, imagePrompt);
                        console.log(`✅ Variant ${i + 1} image generated`);
                        return { processedImage, videoPrompt: videoPrompts[i], imagePrompt, index: i + 2 };
                    } catch (error) {
                        console.error(`❌ Variant ${i + 1} i2i failed:`, error);
                        throw error;
                    }
                });
                
                // 等待基線與 i2i 完成
                const i2iResults = await Promise.allSettled([baselinePromise, ...i2iPromises]);
                
                // 并行提交所有 i2v 任务
                const i2vPromises = i2iResults.slice(1).map(async (result, i) => {
                    if (result.status === 'fulfilled') {
                        const { processedImage, videoPrompt, imagePrompt, index } = result.value; // 2 or 3
                        
                        console.log(`📝 Video Prompt ${index}: ${videoPrompt.substring(0, 100)}...`);
                        showSuccess(`🎬 [${index}/3] Submitting video generation (parallel)...`);
                        
                        window.stickingVideoOverridePrompt = videoPrompt;
                        window.stickingVideoVariantIndex = index;
                        window.stickingVideoTotalVariants = imagePrompts.length;
                        
                        try {
                            await submitTaskForStickingVideo(processedImage, videoPrompt, index, imageFile.name, imagePrompt);
                            console.log(`✅ Variant ${index} submitted`);
                        } finally {
                            window.stickingVideoOverridePrompt = null;
                            window.stickingVideoVariantIndex = null;
                            window.stickingVideoTotalVariants = null;
                        }
                    } else {
                        console.error(`❌ Variant ${i + 2} was skipped due to i2i failure`);
                        showError(`❌ Variant ${i + 2} failed: ${result.reason?.message || 'Unknown error'}`);
                    }
                });
                
                // 等待所有 i2v 提交完成
                await Promise.allSettled(i2vPromises);
                
                const successCount = i2iResults.filter(r => r.status === 'fulfilled').length; // include baseline
                showSuccess(`🎉 Submitted baseline + ${Math.max(0, successCount - 1)}/${imagePrompts.length} variants!`);
                return true;
                
            } catch (error) {
                console.error('❌ Sticking Video process failed:', error);
                showError(`❌ Sticking Video failed: ${error.message}`);
                throw error;
            }
        }

        // Modified submitTask for Sticking Video (submits a single variant)
        async function submitTaskForStickingVideo(processedImageFile, videoPrompt, variantIndex, originalImageName, imagePrompt) {
            const apiKey = document.getElementById('apiKey').value || '';
            const apiConfig = getCurrentAPIConfig();
            const MAX_RETRIES = 20;
            const RETRY_DELAY = 8000;
            
            let lastError = 'Unknown error';
            
            // Create task with variant info
            const tempId = `sticking-${Date.now()}-${Math.random()}`;
            const displayName = `[Sticking ${variantIndex}] ${originalImageName}`;
            const task = createTask(tempId, videoPrompt, displayName);
            task.stickingVideoMode = true;
            task.stickingVideoVariant = variantIndex;
            task.imagePrompt = imagePrompt || '';
            task.status = 'submitting';
            task.submittedAt = Date.now();
            task.apiProvider = apiConfig.provider;
            task.apiVersion = apiConfig.version;
            task.apiEndpointType = apiConfig.endpointType;
            task.apiKey = apiKey;
            tasks.set(tempId, task);
            createTaskCard(task);
            updateTaskCard(task);
            showTasksArea();
            
            // Submission logic (similar to submitTask)
            for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
                task.retryCount = attempt;
                updateTaskCard(task);
                
                try {
                    if (attempt > 0) {
                        console.log(`[Retry] Attempt ${attempt}/${MAX_RETRIES} for sticking video variant ${variantIndex}...`);
                        await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));
                    }
                    
                    const formData = new FormData();
                    formData.append('image', processedImageFile);
                    formData.append('provider', apiConfig.provider);
                    formData.append('version', apiConfig.version);
                    if (apiConfig.endpointType) formData.append('endpoint_type', apiConfig.endpointType);
                    if (videoPrompt.trim()) formData.append('promptText', videoPrompt.trim());
                    
                    const headers = {};
                    if (apiKey) headers['X-API-KEY'] = apiKey;
                    
                    // 根据 provider 决定请求 URL
                    let requestUrl;
                    if (apiConfig.provider === 'testing') {
                        // 新架构通过代理请求（解决 CORS 问题）
                        const apiPath = apiConfig.endpoint.replace(/^\//, '');
                        requestUrl = `/testing-proxy/${apiPath}`;
                    } else {
                        requestUrl = '/api/generate';
                    }
                    
                    console.log(`📤 Submitting sticking video variant ${variantIndex} to API...`);
                    const response = await fetch(requestUrl, { method: 'POST', headers, body: formData });
                    const result = await response.json().catch(() => ({}));
                    
                    console.log('📊 API Response:', response.status, result);
                    
                    if (response.ok) {
                        const realId = result.video_id;
                        tasks.delete(task.id);
                        updateCardIds(task.id, realId);
                        task.id = realId;
                        task.status = 'waiting';
                        tasks.set(realId, task);
                        
                        if (!statusCheckInterval) {
                            try { startStatusCheck(); } catch {}
                        }
                        
                        updateTaskCard(task);
                        console.log(`✅ Sticking video variant ${variantIndex} submitted: ${realId}`);
                        return;
                    }
                    
                    lastError = result.detail || result.message || `HTTP ${response.status}`;
                    const isRetryable = response.status === 429 || response.status >= 500;
                    
                    if (isRetryable && attempt < MAX_RETRIES) {
                        console.warn(`[Retry] Will retry variant ${variantIndex}. Error: ${lastError}`);
                        task.status = `retrying (${attempt + 1})`;
                        updateTaskCard(task);
                        continue;
                    } else {
                        task.status = 'failed';
                        updateTaskCard(task);
                        showError(lastError);
                        return;
                    }
                    
                } catch (error) {
                    lastError = error.message || 'Request error';
                    const isNetwork = lastError.toLowerCase().includes('network');
                    if (isNetwork && attempt < MAX_RETRIES) {
                        task.status = `retrying (${attempt + 1})`;
                        updateTaskCard(task);
                        continue;
                    }
                    task.status = 'failed';
                    updateTaskCard(task);
                    showError(lastError);
                    return;
                }
            }
            
            console.error(`❌ Sticking video variant ${variantIndex} failed after ${MAX_RETRIES} retries`);
            task.status = 'failed';
            updateTaskCard(task);
        }

        // Call Seedream API for i2i
        async function processI2I(imageFile, prompt) {
            const i2iStartTime = Date.now();
            console.log('🎨 [Seedream] Starting i2i process...');
            console.log(`📝 [Seedream] Prompt: ${prompt.substring(0, 100)}...`);
            console.log(`🖼️ [Seedream] Input Image: ${imageFile.name} (${imageFile.type}), Size: ${(imageFile.size / 1024).toFixed(2)}KB`);
            
            return new Promise((resolve, reject) => {
                // Convert image to JPEG format (Seedream doesn't support webp)
                const img = new Image();
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    img.onload = async function() {
                        try {
                            // Create canvas and convert to JPEG
                            const canvas = document.createElement('canvas');
                            canvas.width = img.width;
                            canvas.height = img.height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0);
                            
                            // Convert to JPEG base64 (Seedream API needs data URL format)
                            const base64Image = canvas.toDataURL('image/jpeg', 0.95);
                            const conversionTime = ((Date.now() - i2iStartTime) / 1000).toFixed(2);
                            console.log(`🔄 [Seedream] Converted to JPEG in ${conversionTime}s`);
                            
                            const seedreamPayload = {
                                model: "ep-20250921042133-t769x",
                                prompt: prompt,
                                image: base64Image,
                                size: "1440x2560",
                                watermark: false
                            };

                            console.log('📤 [Seedream] Sending API request via proxy...');
                            
                            // Use our proxy server endpoint
                            const response = await fetch('/seedream/generate', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify(seedreamPayload)
                            });

                            const apiElapsed = ((Date.now() - i2iStartTime) / 1000).toFixed(2);
                            
                            if (!response.ok) {
                                const errorText = await response.text();
                                console.error(`❌ [Seedream] API failed after ${apiElapsed}s: ${response.status}`);
                                throw new Error(`Seedream API returned ${response.status}: ${errorText}`);
                            }

                            const result = await response.json();
                            console.log(`✅ [Seedream] API responded in ${apiElapsed}s`);
                            console.log('📦 [Seedream] Response data:', result);
                            
                            if (result.data && result.data.length > 0) {
                                const imageData = result.data[0];
                                
                                // 優先使用 base64 數據（後端已下載並轉換）
                                if (imageData.base64) {
                                    console.log('📦 [Seedream] Using base64 data from server (CORS bypass)');
                                    // Convert base64 to File
                                    const base64Data = imageData.base64.split(',')[1];
                                    const binaryData = atob(base64Data);
                                    const arrayBuffer = new Uint8Array(binaryData.length);
                                    for (let i = 0; i < binaryData.length; i++) {
                                        arrayBuffer[i] = binaryData.charCodeAt(i);
                                    }
                                    const blob = new Blob([arrayBuffer], { type: 'image/jpeg' });
                                    const newFile = new File([blob], `i2i_${imageFile.name}`, { type: 'image/jpeg' });
                                    const totalElapsed = ((Date.now() - i2iStartTime) / 1000).toFixed(2);
                                    console.log(`✅ [Seedream] i2i complete in ${totalElapsed}s, Output: ${(newFile.size / 1024).toFixed(2)}KB`);
                                    resolve(newFile);
                                } else if (imageData.url) {
                                    // 回退：嘗試直接下載 URL（可能有 CORS 問題）
                                    console.log('🖼️ [Seedream] Generated image URL:', imageData.url);
                                    console.log('📥 [Seedream] Downloading generated image...');
                                    const imgResponse = await fetch(imageData.url);
                                    if (!imgResponse.ok) {
                                        throw new Error(`Failed to download generated image: ${imgResponse.status}`);
                                    }
                                    const blob = await imgResponse.blob();
                                    const newFile = new File([blob], `i2i_${imageFile.name}`, { type: 'image/jpeg' });
                                    const totalElapsed = ((Date.now() - i2iStartTime) / 1000).toFixed(2);
                                    console.log(`✅ [Seedream] i2i complete in ${totalElapsed}s, Output: ${(newFile.size / 1024).toFixed(2)}KB`);
                                    resolve(newFile);
                                } else {
                                    throw new Error('No image data (base64 or URL) returned');
                                }
                            } else {
                                throw new Error('Seedream API returned no image data');
                            }
                        } catch (error) {
                            const errorElapsed = ((Date.now() - i2iStartTime) / 1000).toFixed(2);
                            console.error(`❌ [Seedream] i2i failed after ${errorElapsed}s:`, error);
                            reject(error);
                        }
                    };
                    
                    img.onerror = (error) => {
                        console.error('❌ Image loading error:', error);
                        reject(new Error('Failed to load image for conversion'));
                    };
                    
                    img.src = e.target.result;
                };
                
                reader.onerror = (error) => {
                    console.error('❌ FileReader error:', error);
                    reject(error);
                };
                
                reader.readAsDataURL(imageFile);
            });
        }

        function clearAllImages() {
            if (selectedImages.length === 0) {
                showError('No images to clear');
                return;
            }
            
            if (confirm(`Are you sure you want to remove all ${selectedImages.length} selected image(s)?`)) {
                selectedImages = [];
                updateFileInput();
                imagePreview.innerHTML = '';
                uploadArea.classList.remove('has-file');
                updateUploadAreaText();
                showSuccess('All images cleared');
            }
        }

        // 取得併發上限（若UI已移除，提供安全默認值）
        function getConcurrencyLimit() {
            const el = document.getElementById('concurrencyLimit');
            const n = parseInt(el?.value || '10', 10);
            if (Number.isNaN(n) || n <= 0) return 10;
            return Math.min(n, 20);
        }

        // 生成視頻 - 使用智能隊列和併發控制
        async function generateVideo() {
            const apiKey = document.getElementById('apiKey').value;
            const concurrencyLimit = getConcurrencyLimit();
            const imageFiles = Array.from(document.getElementById('imageFile').files);

            // 驗證輸入
            if (!apiKey) {
                showError('Please enter your API Key');
                return;
            }
            if (imageFiles.length === 0) {
                showError('Please select at least one image file');
                return;
            }

            // 初始化
            clearMessages();
            setButtonLoading(true);
            showBatchProgress();
            
            // 將所有圖片放入隊列
            imageQueue = [...imageFiles];
            const totalTasks = imageQueue.length;
            
            console.log('=== New Concurrent Task Submission ===');
            console.log('Selected images:', totalTasks);
            console.log('Concurrency Limit:', concurrencyLimit);
            console.log('====================================');
            
            showSuccess(`🚀 Queued ${totalTasks} image(s) for generation...`);
            
            // 啟動隊列管理器
            if (processingInterval) clearInterval(processingInterval);
            processingInterval = setInterval(() => queueManager(concurrencyLimit, totalTasks), 2000); // 每2秒檢查一次
            
            // 立即觸發一次以快速啟動
            queueManager(concurrencyLimit, totalTasks);

            // 啟動狀態輪詢
            if (!statusCheckInterval) {
                startStatusCheck();
            }
        }
        
        // 輔助函數：更新任務卡片及其所有子元素的ID
        function updateCardIds(oldId, newId) {
            const card = document.getElementById(`task-${oldId}`);
            if (!card) return;

            // 選擇所有帶有舊ID的元素
            const elementsToUpdate = card.querySelectorAll(`[id$="-${oldId}"]`);
            
            elementsToUpdate.forEach(el => {
                el.id = el.id.replace(oldId, newId);
            });
            
            // 更新主卡片的ID
            card.id = `task-${newId}`;
            
            // 特別處理onclick事件
            const downloadLink = card.querySelector(`a[onclick*="'${oldId}'"]`);
            if (downloadLink) {
                downloadLink.setAttribute('onclick', `downloadTaskVideo('${newId}')`);
            }
        }

        // 隊列管理器
        function queueManager(_limit, totalTasks) {
            // 每次動態取得併發上限（UI可能已隱藏）
            const concurrencyLimit = getConcurrencyLimit();
            const activeTasks = Array.from(tasks.values()).filter(t => !['completed', 'failed', 'finished', 'error'].includes(t.status)).length;
            const effectiveActive = activeTasks + pendingSubmissions; // 把尚未加入 Map 的提交也算進去
            const canSubmitCount = concurrencyLimit - effectiveActive;
            
            console.log(`[Queue Manager] Active (in Map): ${activeTasks}, Pending Submissions: ${pendingSubmissions}, Queue: ${imageQueue.length}, Can Submit: ${canSubmitCount}`);
            
            if (canSubmitCount > 0 && imageQueue.length > 0) {
                const itemsToSubmit = imageQueue.splice(0, canSubmitCount);
                console.log(`[Queue Manager] Submitting ${itemsToSubmit.length} new tasks.`);
                
                showSuccess(`Submitting ${itemsToSubmit.length} new tasks...`);

                // 帶有交錯延遲地提交任務，以避免請求風暴
                (async () => {
                    for (const imageFile of itemsToSubmit) {
                        pendingSubmissions++; // 標記為正在提交
                        submitTask(imageFile).finally(() => {
                            pendingSubmissions--; // 提交結束（成功或失敗）
                        });
                        await new Promise(resolve => setTimeout(resolve, 500)); // 增加到500ms
                    }
                })();
            }
            
            const submittedCount = totalTasks - imageQueue.length;
            const completedCount = submittedCount - activeTasks;
            updateBatchProgress(completedCount, totalTasks, null, null, `Submitted: ${submittedCount}/${totalTasks} | Active: ${effectiveActive}`);

            // 如果隊列為空且沒有活動任務，則停止
            if (imageQueue.length === 0 && activeTasks === 0) {
                console.log('[Queue Manager] All tasks completed. Stopping manager.');
                clearInterval(processingInterval);
                processingInterval = null;
                setButtonLoading(false);
                
                const finalCompletedCount = Array.from(tasks.values()).filter(t => ['completed', 'finished'].includes(t.status)).length;
                showSuccess(`🎉 All ${finalCompletedCount}/${totalTasks} tasks processed!`);
                updateBatchProgress(finalCompletedCount, totalTasks, null, null, `All tasks processed!`);

                setTimeout(() => {
                    hideBatchProgress();
                }, 5000);
            }
        }

        // 提交單個任務，包含重試邏輯
        async function submitTask(imageFile) {
            // Check if sticking video mode is enabled
            const stickingVideoToggle = document.getElementById('stickingVideoToggle');
            const stickingVideoEnabled = stickingVideoToggle?.checked || false;
            
            // Check if i2i mode is enabled
            const i2iToggle = document.getElementById('i2iToggle');
            const i2iEnabled = i2iToggle?.checked || false;
            
            // Get the unified prompt
            const promptText = (window.benchmarkOverridePrompt ?? document.getElementById('promptText').value) || '';
            
            // Handle Sticking Video Mode
            if (stickingVideoEnabled && !window.benchmarkOverridePrompt) {
                if (!promptText.trim()) {
                    showError('❌ Sticking Video mode requires a video prompt!');
                    return;
                }
                
                console.log('🎬 Sticking Video mode detected - processing...');
                try {
                    await processStickingVideo(imageFile, promptText);
                    return; // processStickingVideo handles everything
                } catch (error) {
                    console.error('❌ Sticking Video failed:', error);
                    showError(`❌ Sticking Video failed: ${error.message}`);
                    return;
                }
            }
            
            let processedImageFile = imageFile;

            if (i2iEnabled) {
                if (!promptText.trim()) {
                    showError('❌ i2i mode is enabled but no prompt provided!');
                    return;
                }

                // Show i2i processing notification
                showSuccess(`🎨 Processing i2i for ${imageFile.name}... Please wait.`);
                
                try {
                    // Process image through Seedream first, using the same prompt
                    processedImageFile = await processI2I(imageFile, promptText);
                    console.log(`✅ i2i processing complete. Original: ${imageFile.name}, Processed: ${processedImageFile.name}`);
                    showSuccess(`✅ i2i completed for ${imageFile.name}, now generating video...`);
                } catch (error) {
                    showError(`❌ i2i processing failed: ${error.message}`);
                    console.error('i2i processing error:', error);
                    return;
                }
            }

            // 若有 Benchmark 覆蓋，使用覆蓋參數
            const apiKey = (window.benchmarkOverrideApiKey ?? document.getElementById('apiKey').value) || '';
            const apiConfig = window.benchmarkOverrideConfig || getCurrentAPIConfig();
            const MAX_RETRIES = 20; // 提高重試上限
            const RETRY_DELAY = 8000; // 8秒重試間隔

            let lastError = 'Unknown error';

            // 創建一個臨時任務用於UI展示
            const tempId = `submitting-${Date.now()}-${Math.random()}`;
            const displayName = i2iEnabled ? `[i2i] ${imageFile.name}` : imageFile.name;
            const task = createTask(tempId, promptText, displayName);
            task.i2iEnabled = i2iEnabled;
            task.i2iPrompt = i2iEnabled ? promptText : '';
            task.status = 'submitting';
            task.submittedAt = Date.now();
            // 存儲API配置信息到任務
            task.apiProvider = apiConfig.provider;
            task.apiVersion = apiConfig.version;
            task.apiEndpointType = apiConfig.endpointType;
            task.apiKey = apiKey;
            tasks.set(tempId, task);
            createTaskCard(task);
            updateTaskCard(task);
            
            // 更新API信息顯示
            const apiInfoElement = document.getElementById(`api-info-${tempId}`);
            if (apiInfoElement) {
                const providerConfig = API_PROVIDERS[apiConfig.provider];
                const baseUrl = providerConfig.baseUrl;
                const keyDisplay = apiKey ? `${apiKey.substring(0, 6)}...${apiKey.substring(apiKey.length - 6)}` : 'Server Default';
                const endpointInfo = apiConfig.endpointType ? ` | 🎯 ${apiConfig.endpointType}` : '';
                apiInfoElement.innerHTML = `📍 ${apiConfig.provider} | 🌐 ${baseUrl} | 🔗 ${apiConfig.version}${endpointInfo} | 🔑 ${keyDisplay}`;
            }
            
            showTasksArea();

            // audio-to-video 需要音頻文件，無則直接失敗並返回
            if (apiConfig.endpointType === 'audio-to-video') {
                const audioInputPre = document.getElementById('audioFile');
                const audioFilePre = audioInputPre?.files?.[0];
                if (!audioFilePre) {
                    const errMsg = 'audio-to-video requires an audio file';
                    lastError = errMsg;
                    task.status = 'failed';
                    updateTaskCard(task);
                    showError(errMsg);
                    return;
                }
            }
            
            for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
                task.retryCount = attempt;
                updateTaskCard(task);
                
                try {
                    if (attempt > 0) {
                        console.log(`[Retry] Attempt ${attempt}/${MAX_RETRIES} for ${imageFile.name}...`);
                        await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));
                    }

                    // 準備 FormData 和 headers
                    const formData = new FormData();
                    // Use processed image if i2i was enabled
                    formData.append('image', processedImageFile);
                    formData.append('provider', apiConfig.provider);
                    formData.append('version', apiConfig.version);
                    if (apiConfig.endpointType) formData.append('endpoint_type', apiConfig.endpointType);
                    // 如果選擇的是 audio-to-video，附帶音頻文件
                    if (apiConfig.endpointType === 'audio-to-video') {
                        const audioInput = document.getElementById('audioFile');
                        const audioFile = audioInput?.files?.[0];
                        if (!audioFile) {
                            showError('audio-to-video requires an audio file');
                            throw new Error('Missing audio file');
                        }
                        formData.append('audio', audioFile);
                    }
                    if (promptText.trim()) formData.append('promptText', promptText.trim());
                    const headers = {};
                    if (apiKey) headers['X-API-KEY'] = apiKey; // 如果用户提供了API Key就使用，否则使用服务器默认的
                    
            // 記錄詳細的API調用信息
                    const providerConfig = API_PROVIDERS[apiConfig.provider];
                    const baseUrl = providerConfig.baseUrl;
                    const fullUrl = baseUrl + apiConfig.endpoint;
                    
                    console.log('=== Video Generation API Call ===');
                    console.log('📍 Provider:', apiConfig.provider);
                    console.log('🔗 Version:', apiConfig.version);
                    if (apiConfig.endpointType) console.log('🎯 Endpoint Type:', apiConfig.endpointType);
                    console.log('🌐 Base URL:', baseUrl);
                    console.log('🎯 Endpoint:', apiConfig.endpoint);
                    console.log('🔗 Full URL:', fullUrl);
                    console.log('🚀 Proxy Endpoint:', '/api/generate');
                    console.log('🔑 API Key:', apiKey ? `${apiKey.substring(0, 8)}...${apiKey.substring(apiKey.length - 8)}` : 'Using default from server');
                    console.log('📝 Prompt:', promptText.trim() || 'No prompt');
                    console.log('📎 Image:', processedImageFile.name, `(${(processedImageFile.size / 1024).toFixed(2)} KB)${i2iEnabled ? ' [i2i processed]' : ''}`);
                    if (i2iEnabled) {
                        console.log('🎨 Original Image:', imageFile.name, `(${(imageFile.size / 1024).toFixed(2)} KB)`);
                    }
                    console.log('📋 Headers:', headers);
                    
                    // 根据 provider 决定请求 URL
                    let requestUrl;
                    if (apiConfig.provider === 'testing') {
                        // 新架构通过代理请求（解决 CORS 问题）
                        // 将 /api/v1/generate/v0/image-to-video 转换为 /testing-proxy/api/v1/generate/v0/image-to-video
                        const apiPath = apiConfig.endpoint.replace(/^\//, ''); // 去掉开头的 /
                        requestUrl = `/testing-proxy/${apiPath}`;
                    } else {
                        // 其他 provider 通过代理
                        requestUrl = '/api/generate';
                    }
                    
                    const response = await fetch(requestUrl, { method: 'POST', headers, body: formData });
                    const result = await response.json().catch(() => ({}));
                    
                    // 記錄響應信息
                    console.log('=== API Response ===');
                    console.log('📊 Status:', response.status, response.statusText);
                    console.log('📝 Result:', result);

                    if (response.ok) {
                        // 顯示詳細的成功信息
                    const successDetails = `
✅ Video Generation Started Successfully!

🆔 Video ID: ${result.video_id}
📍 Provider: ${apiConfig.provider}${window.benchmarkLabel ? ` (${window.benchmarkLabel})` : ''}
🔗 Version: ${apiConfig.version}
${apiConfig.endpointType ? `🎯 Endpoint Type: ${apiConfig.endpointType}` : ''}
🌐 Base URL: ${baseUrl}
🎯 Endpoint: ${apiConfig.endpoint}
🔗 Full URL: ${fullUrl}
🔑 API Key: ${apiKey ? `${apiKey.substring(0, 8)}...${apiKey.substring(apiKey.length - 8)}` : 'Server Default'}
📝 Prompt: ${(window.benchmarkOverridePrompt ?? promptText).trim() || 'No prompt provided'}
📎 Image: ${processedImageFile.name} (${(processedImageFile.size / 1024).toFixed(2)} KB)${i2iEnabled ? ' [i2i processed from ' + imageFile.name + ']' : ''}
🏗️ Worker: ${result.worker || 'Not specified'}
📊 Status: ${result.status || 'pending'}
⏰ Time: ${new Date().toLocaleTimeString()}
                        `;
                        
                        console.log('=== Video Generation Success ===');
                        console.log(successDetails);
                        console.log(`✅ Task submitted successfully: ${result.video_id} for ${imageFile.name}`);
                        
                        // 提交成功，用真實ID替換臨時ID
                        const realId = result.video_id;
                        const oldApiInfo = document.getElementById(`api-info-${task.id}`);
                        const apiInfoContent = oldApiInfo ? oldApiInfo.innerHTML : '';
                        
                        tasks.delete(task.id); // 刪除臨時任務
                        
                        updateCardIds(task.id, realId); // 更新DOM中所有相關ID
                        
                        task.id = realId; // 更新JS對象的ID
                        task.status = 'waiting'; // 重置狀態
                        // 存儲詳細信息到任務對象
                        task.submissionDetails = {
                            videoId: result.video_id,
                            provider: apiConfig.provider,
                            baseUrl: baseUrl,
                            endpoint: apiConfig.endpoint,
                            fullUrl: fullUrl,
                            apiKey: apiKey ? `${apiKey.substring(0, 8)}...${apiKey.substring(apiKey.length - 8)}` : 'Server Default',
                            prompt: promptText.trim() || 'No prompt provided',
                            imageInfo: `${processedImageFile.name} (${(processedImageFile.size / 1024).toFixed(2)} KB)${i2iEnabled ? ' [i2i]' : ''}`,
                            originalImageInfo: i2iEnabled ? `${imageFile.name} (${(imageFile.size / 1024).toFixed(2)} KB)` : null,
                            worker: result.worker || 'Not specified',
                            submittedAt: new Date().toLocaleTimeString()
                        };
                        tasks.set(realId, task); // 用真實ID存儲
                        
                        // 確保輪詢已啟動
                        if (!statusCheckInterval) {
                            try { startStatusCheck(); } catch {}
                        }

                        updateTaskCard(task); // 用新ID更新一次UI
                        
                        // 恢復API信息顯示並添加詳細信息
                        const newApiInfo = document.getElementById(`api-info-${realId}`);
                        if (newApiInfo) {
                            const enhancedApiInfo = `
📍 ${apiConfig.provider} | 🌐 ${baseUrl} | 🔗 ${apiConfig.version} | 🔑 ${apiKey ? `${apiKey.substring(0, 6)}...${apiKey.substring(apiKey.length - 6)}` : 'Server Default'}
<br><small>🏗️ Worker: ${result.worker || 'Not specified'} | ⏰ ${new Date().toLocaleTimeString()}</small>
                            `;
                            newApiInfo.innerHTML = enhancedApiInfo;
                        }
                        return; // 成功，退出循環
                    }
                    
                    lastError = result.detail || result.message || `HTTP ${response.status}`;
                    // 增加對網絡錯誤的判斷
                    if (response.status === 0 || !response.status) {
                        lastError = "Network Error. Is the proxy server running?";
                    }
                    const isRetryable = response.status === 429 || response.status >= 500;

                    if (isRetryable && attempt < MAX_RETRIES) {
                        console.warn(`[Retry] Will retry for ${imageFile.name}. Error: ${lastError}`);
                        task.status = `retrying (${attempt + 1})`;
                        updateTaskCard(task);
                        continue;
                    } else {
                        // 非可重試錯誤，直接標記失敗並結束
                        task.status = 'failed';
                        updateTaskCard(task);
                        showError(lastError);
                        return;
                    }

                } catch (error) {
                    lastError = error.message || 'Request error';
                    // 僅針對網路類錯誤重試
                    const isNetwork = lastError.toLowerCase().includes('network');
                    if (isNetwork && attempt < MAX_RETRIES) {
                        task.status = `retrying (${attempt + 1})`;
                        updateTaskCard(task);
                        continue;
                    }
                    // 非網路錯誤直接失敗
                    task.status = 'failed';
                    updateTaskCard(task);
                    showError(lastError);
                    return;
                }
            }

            // 所有重試失敗
            console.error(`❌ Task failed for ${imageFile.name} after ${MAX_RETRIES} retries. Final error: ${lastError}`);
            task.status = 'failed';
            updateTaskCard(task);
        }

        // 檢查視頻狀態
        async function checkVideoStatus() {
            const baseUrl = '/';  // 使用本地代理
            
            // 允許未輸入 API Key 時仍輪詢，後端會使用預設 key（若有）
            
            const activeTasks = Array.from(tasks.values()).filter(task => 
                !['finished', 'completed', 'failed', 'error'].includes(task.status)
            );
            
            if (activeTasks.length === 0) {
                stopStatusCheck();
                return;
            }

            // 檢查所有活躍任務
            for (const task of activeTasks) {
                try {
                    // 使用任务自己保存的provider和apiKey，而不是当前UI选中的
                    const taskProvider = task.apiProvider || 'original';
                    const taskApiKey = task.apiKey || '';
                    
                    // 準備 headers
                    const headers = {
                        'Accept': 'application/json'
                    };
                    if (taskApiKey) {
                        headers['X-API-KEY'] = taskApiKey;
                    }
                    
                    // 根据 provider 确定查询路径
                    let queryUrl;
                    if (taskProvider === 'testing') {
                        // 新架构通过代理请求（解决 CORS 问题）
                        const providerConfig = API_PROVIDERS[taskProvider];
                        const versionConfig = providerConfig?.versions[task.apiVersion || 'v1'];
                        const endpointConfig = versionConfig?.endpoints?.[task.apiEndpointType || 'image-to-video'];
                        const queryPath = endpointConfig?.queryPath || '/api/v1/generate/v0/videos';
                        // 将 /api/v1/generate/v0/videos 转换为 /testing-proxy/api/v1/generate/v0/videos
                        const apiPath = queryPath.replace(/^\//, '');
                        queryUrl = `/testing-proxy/${apiPath}/${task.id}`;
                    } else {
                        // 其他 provider 使用代理
                        queryUrl = `/videos/${task.id}?provider=${taskProvider}`;
                    }
                    
                    const response = await fetch(queryUrl, {
                        headers: headers
                    });

                    if (response.ok) {
                        const result = await response.json();
                        updateTaskFromAPI(task, result);
                    } else {
                        console.error(`Failed to check task ${task.id}: ${response.status} ${response.statusText}`);
                    }
                } catch (error) {
                    console.error(`檢查任務 ${task.id} 狀態時出錯:`, error);
                }
            }
            
            // 更新統計
            updateTasksSummary();
        }

        function updateTaskFromAPI(task, result) {
            console.log(`=== Task #${task.taskNumber} Status Update ===`);
            console.log('Full API Response:', result);
            
            // 更新任務數據
            const prevStatus = task.status;
            task.status = result.status || task.status;
            task.progress = result.progress || task.progress;
            
            // 处理URL：streaming状态下url是m3u8，finished状态下url是mp4
            if (result.url) {
                if (task.status === 'streaming') {
                    task.streamUrl = result.url;
                    console.log(`📡 Got HLS stream URL: ${result.url}`);
                } else if (task.status === 'finished' || task.status === 'completed') {
                    task.url = result.url;
                    console.log(`🎬 Got final MP4 URL: ${result.url}`);
                } else {
                    task.url = result.url;
                }
            }
            
            // 如果从streaming转到finished，清理HLS实例
            if (prevStatus === 'streaming' && (task.status === 'finished' || task.status === 'completed')) {
                if (task.hlsInstance) {
                    task.hlsInstance.destroy();
                    task.hlsInstance = null;
                    console.log(`🔄 Transitioning task #${task.taskNumber} from streaming to finished`);
                }
            }
            
            // 計時：等待時間（submitted -> started）與生成時間（started -> finished）
            if (!task.startedAt && (task.status === 'started' || task.progress > 0)) {
                task.startedAt = Date.now();
                if (task.submittedAt) {
                    task.waitDurationSec = Math.max(0, Math.round((task.startedAt - task.submittedAt) / 1000));
                }
            }
            if (!task.finishedAt && (task.status === 'finished' || task.status === 'completed')) {
                task.finishedAt = Date.now();
                if (task.startedAt) {
                    task.genDurationSec = Math.max(0, Math.round((task.finishedAt - task.startedAt) / 1000));
                }
            }
            
            // 舊的通用計時兼容（保留現有UI）
            if (task.progress > 0 && !task.startTime) {
                task.startTime = Date.now();
                console.log(`⏱️ Task #${task.taskNumber} timer started`);
            }
            
            // 如果任務完成且還沒記錄結束時間，記錄結束時間
            const isCompleted = ['completed', 'finished', 'done'].includes(task.status);
            if (isCompleted && !task.endTime) {
                task.endTime = Date.now();
                console.log(`🎉 Task #${task.taskNumber} completed!`);
            }
            
            // 更新UI
            updateTaskCard(task);
            
            // 更新到 Map 中
            tasks.set(task.id, task);

            // 若為 Benchmark，嘗試合併到左右對比
            try { maybeRenderBenchmarkPair(task); } catch {}
        }

        // 下載日誌：輸出 CSV，包含 id, provider, version, endpointType, prompt, submittedAt, startedAt, finishedAt, waitSec, genSec
        function downloadLogs() {
            const header = [
                'taskNumber','id','provider','version','endpointType','prompt','submittedAt','startedAt','finishedAt','waitSec','genSec','status','url'
            ];
            const rows = [header.join(',')];
            for (const task of tasks.values()) {
                const submittedAt = task.submittedAt ? new Date(task.submittedAt).toLocaleString() : '';
                const startedAt = task.startedAt ? new Date(task.startedAt).toLocaleString() : '';
                const finishedAt = task.finishedAt ? new Date(task.finishedAt).toLocaleString() : '';
                const waitSec = task.waitDurationSec != null ? task.waitDurationSec : (task.submittedAt && task.startedAt ? Math.round((task.startedAt - task.submittedAt)/1000) : '');
                const genSec = task.genDurationSec != null ? task.genDurationSec : (task.startedAt && task.finishedAt ? Math.round((task.finishedAt - task.startedAt)/1000) : '');
                const provider = task.apiProvider || '';
                const version = task.apiVersion || '';
                const endpointType = task.apiEndpointType || '';
                const prompt = (task.promptText || '').replaceAll('\n',' ').replaceAll('"','""');
                const line = [
                    task.taskNumber,
                    `"${task.id}"`,
                    provider,
                    version,
                    endpointType,
                    `"${prompt}"`,
                    `"${submittedAt}"`,
                    `"${startedAt}"`,
                    `"${finishedAt}"`,
                    waitSec,
                    genSec,
                    task.status || '',
                    task.url || ''
                ].join(',');
                rows.push(line);
            }
            const csv = rows.join('\n');
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `parrot_logs_${new Date().toISOString().replace(/[:.]/g,'-')}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // 開始狀態檢查
        function startStatusCheck() {
            if (statusCheckInterval) {
                clearInterval(statusCheckInterval);
            }
            statusCheckInterval = setInterval(checkVideoStatus, 3000); // 每3秒檢查一次
            checkVideoStatus(); // 立即檢查一次
        }

        // 停止狀態檢查
        function stopStatusCheck() {
            if (statusCheckInterval) {
                clearInterval(statusCheckInterval);
                statusCheckInterval = null;
                console.log('⏹️ All tasks completed, stopping status check');
            }
        }

        // 顯示狀態區域
        function showStatusArea() {
            document.getElementById('statusArea').style.display = 'block';
        }

        // 設置按鈕載入狀態
        function setButtonLoading(loading) {
            const btn = document.getElementById('generateBtn');
            if (!btn) return;
            // 始終保持可點擊，並維持啟動文案，允許持續提交
            btn.disabled = false;
            btn.textContent = '🚀 Start Generating Video(s)';
        }

        // 批量處理進度條管理
        function showBatchProgress() {
            document.getElementById('batchProgressArea').style.display = 'block';
        }

        function hideBatchProgress() {
            document.getElementById('batchProgressArea').style.display = 'none';
        }

        function updateBatchProgress(current, total, batchNumber, totalBatches, detail) {
            const progressPercent = total > 0 ? Math.round((current / total) * 100) : 0;
            const progressText = document.getElementById('batchProgressText');
            const progressFill = document.getElementById('batchProgressFill');
            const progressDetail = document.getElementById('batchProgressDetail');
            
            progressText.textContent = `Progress: ${current}/${total} tasks (${progressPercent}%)`;
            progressFill.style.width = `${progressPercent}%`;
            progressDetail.textContent = detail || 'Processing...';
        }

        // 顯示錯誤訊息
        function showError(message) {
            const errorArea = document.getElementById('errorArea');
            if (errorArea) {
                errorArea.innerHTML = `<div class="error-message">❌ ${message}</div>`;
            } else {
                console.error('❌', message);
            }
        }

        // Show success message
        function showSuccess(message) {
            const errorArea = document.getElementById('errorArea');
            if (errorArea) {
                errorArea.innerHTML = `<div class="success-message">✅ ${message}</div>`;
            } else {
                console.log('✅', message);
            }
        }

        // Clear messages
        function clearMessages() {
            const errorArea = document.getElementById('errorArea');
            if (errorArea) {
                errorArea.innerHTML = '';
            }
        }

        // 任務UI管理
        function showTasksArea() {
            document.getElementById('tasksArea').style.display = 'block';
        }

        function createTaskCard(task) {
            const tasksList = document.getElementById('tasksList');
            
            const taskCard = document.createElement('div');
            taskCard.className = 'task-card';
            taskCard.id = `task-${task.id}`;
            
            taskCard.innerHTML = `
                <div class="task-header">
                    <div class="task-title">📋 Task #${task.taskNumber}</div>
                    <div class="task-status processing" id="status-${task.id}">Processing</div>
                </div>
                <div class="task-details">
                    <div class="task-detail-item">
                        <div class="task-detail-label">Video ID</div>
                        <div class="task-detail-value" style="font-size: 11px;">${task.id.substring(0, 12)}...</div>
                    </div>
                    <div class="task-detail-item">
                        <div class="task-detail-label">Progress</div>
                        <div class="task-detail-value" id="progress-${task.id}">0%</div>
                    </div>
                    <div class="task-detail-item">
                        <div class="task-detail-label">Wait</div>
                        <div class="task-detail-value" id="wait-${task.id}">-</div>
                    </div>
                    <div class="task-detail-item">
                        <div class="task-detail-label">Gen</div>
                        <div class="task-detail-value" id="gen-${task.id}">-</div>
                    </div>
                    <div class="task-detail-item">
                        <div class="task-detail-label">⏱️ Time</div>
                        <div class="task-detail-value" id="time-${task.id}">Waiting...</div>
                    </div>
                    <div class="task-detail-item">
                        <div class="task-detail-label">🔁 Retries</div>
                        <div class="task-detail-value" id="retries-${task.id}">${task.retryCount}</div>
                    </div>
                </div>
                <div style="font-size: 13px; color: #666; margin-bottom: 8px;">
                    🖼️ Image: ${task.imageName} | 💬 Prompt: ${task.promptText || 'None'}
                    ${task.stickingVideoMode && task.imagePrompt ? `<div style="margin-top:6px; font-size:12px; color:#444; background:#f1f3f5; padding:6px; border-radius:4px;">🖊️ Image Prompt: ${task.imagePrompt.replaceAll('<','&lt;').replaceAll('>','&gt;')}</div>` : ''}
                </div>
                <div style="font-size: 12px; color: #888; margin-bottom: 10px; padding: 5px; background: #f8f9fa; border-radius: 3px;" id="api-info-${task.id}">
                    📍 API: Loading... | 🔗 Version: Loading... | 🔑 Key: Loading...
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill-${task.id}"></div>
                </div>
                <div class="task-video" id="video-${task.id}" style="display: none;"></div>
            `;
            
            // 插入到最前面（最新的任務在上面）
            tasksList.insertBefore(taskCard, tasksList.firstChild);
        }

        function updateTaskCard(task) {
            const statusElement = document.getElementById(`status-${task.id}`);
            const progressElement = document.getElementById(`progress-${task.id}`);
            const timeElement = document.getElementById(`time-${task.id}`);
            const waitElement = document.getElementById(`wait-${task.id}`);
            const genElement = document.getElementById(`gen-${task.id}`);
            const progressFillElement = document.getElementById(`progress-fill-${task.id}`);
            const taskCard = document.getElementById(`task-${task.id}`);
            const retriesElement = document.getElementById(`retries-${task.id}`);
            
            if (!statusElement) return;

            // 更新重試次數
            if(retriesElement) retriesElement.textContent = task.retryCount;
            
            // 更新進度
            progressElement.textContent = `${task.progress}%`;
            progressFillElement.style.width = `${task.progress}%`;
            
            // 更新時間
            if (task.startTime) {
                const elapsed = task.endTime ? 
                    Math.floor((task.endTime - task.startTime) / 1000) :
                    Math.floor((Date.now() - task.startTime) / 1000);
                
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                const timeText = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
                
                timeElement.textContent = task.endTime ? 
                    `✅ ${timeText}` : 
                    `🔄 ${timeText}`;
                    
                task.duration = elapsed;
            }

            // 新增：顯示等待/生成時間（即時更新，參考 time 的動態顯示邏輯）
            if (waitElement) {
                let waitSec = null;
                if (task.submittedAt) {
                    if (task.startedAt) {
                        // 已開始，固定為提交到開始的耗時
                        const fixed = task.waitDurationSec ?? Math.round((task.startedAt - task.submittedAt) / 1000);
                        waitSec = Math.max(0, fixed);
                    } else {
                        // 未開始，動態累加
                        waitSec = Math.max(0, Math.round((Date.now() - task.submittedAt) / 1000));
                    }
                }
                waitElement.textContent = waitSec != null ? `${waitSec}s` : '-';
            }
            if (genElement) {
                let genSec = null;
                if (task.startedAt) {
                    if (task.finishedAt) {
                        // 已完成，固定為開始到完成的耗時
                        const fixed = task.genDurationSec ?? Math.round((task.finishedAt - task.startedAt) / 1000);
                        genSec = Math.max(0, fixed);
                    } else {
                        // 生成中，動態累加
                        genSec = Math.max(0, Math.round((Date.now() - task.startedAt) / 1000));
                    }
                }
                genElement.textContent = genSec != null ? `${genSec}s` : '-';
            }
            
            // 更新狀態
            statusElement.className = 'task-status';
            if (task.status === 'finished' || task.status === 'completed') {
                statusElement.classList.add('completed');
                statusElement.textContent = '✅ Completed';
                taskCard.classList.add('completed');
                
                if (task.url) {
                    showTaskVideo(task);
                }
            } else if (task.status === 'streaming') {
                statusElement.classList.add('processing');
                statusElement.textContent = '📡 Streaming';
                
                if (task.streamUrl) {
                    showTaskVideo(task);
                }
            } else if (task.status === 'failed' || task.status === 'error') {
                statusElement.classList.add('failed');
                statusElement.textContent = '❌ Failed';
                taskCard.classList.add('failed');
            } else if (task.status.startsWith('retrying')) {
                statusElement.classList.add('processing');
                statusElement.textContent = `⏳ Retrying...`;
            } else if (task.status === 'submitting') {
                statusElement.classList.add('processing');
                statusElement.textContent = `📤 Submitting...`;
            } else {
                statusElement.classList.add('processing');
                statusElement.textContent = '🔄 Processing';
            }
        }

        function showTaskVideo(task) {
            const videoContainer = document.getElementById(`video-${task.id}`);
            if (!videoContainer) return;
            
            // 判断是streaming状态还是finished状态
            const isStreaming = task.status === 'streaming';
            const videoUrl = isStreaming ? task.streamUrl : task.url;
            
            if (!videoUrl) return;
            
            const videoId = `video-player-${task.id}`;
            
            // 检查是否已经渲染过相同的URL，避免重复渲染
            if (task._currentVideoUrl === videoUrl && document.getElementById(videoId)) {
                // 视频已经在播放，不要重新渲染
                return;
            }
            
            // 记录当前URL，避免重复渲染
            task._currentVideoUrl = videoUrl;
            
            videoContainer.style.display = 'block';
            const label = task.benchmarkLabel ? `<span style="margin-right:8px; padding:2px 6px; border-radius:10px; background:#eef; color:#335; font-size:12px;">${task.benchmarkLabel}</span>` : '';
            const endpointInfo = task.submissionDetails ? `${task.submissionDetails.endpoint}` : '';
            const promptInfo = (task.promptText || '').replaceAll('<','&lt;').replaceAll('>','&gt;');
            
            videoContainer.innerHTML = `
                <div style="display:flex; flex-direction:column; gap:6px; align-items:center;">
                    <div style="font-size:12px; color:#666;">${label}${endpointInfo} ${isStreaming ? '📡' : ''}</div>
                    <video id="${videoId}" controls width="60%" ${isStreaming ? 'autoplay muted' : 'preload="metadata"'} style="display: block; margin: 6px auto;">
                        ${isStreaming ? '' : `<source src="${videoUrl}" type="video/mp4">`}
                        Your browser does not support video playback.
                    </video>
                    <div style="font-size:12px; color:#555; max-width:60%; white-space:pre-wrap; word-break:break-word;">📝 ${promptInfo || 'No prompt'}</div>
                    ${!isStreaming && task.url ? `
                    <div style="margin-top: 6px; font-size: 12px; color: #666;">
                        🎬 <a href="${task.url}" target="_blank" style="color: #4facfe;">Open Video</a> |
                        <a href="javascript:void(0)" onclick="downloadTaskVideo('${task.id}')" style="color: #4facfe;">💾 Download</a>
                    </div>
                    ` : ''}
                </div>
            `;
            
            // 如果是streaming，使用HLS.js加载m3u8
            if (isStreaming && task.streamUrl) {
                const video = document.getElementById(videoId);
                if (video && window.Hls && window.Hls.isSupported()) {
                    // 清理舊的 HLS 實例（如果存在）
                    if (task.hlsInstance) {
                        task.hlsInstance.destroy();
                        task.hlsInstance = null;
                    }
                    
                    const hls = new window.Hls({
                        enableWorker: true,
                        lowLatencyMode: true,
                        backBufferLength: 90
                    });
                    
                    // 🎯 使用轉碼代理 URL（將 AC-3 轉為 AAC）
                    const transcodedUrl = `/hls-transcode/${encodeURIComponent(task.streamUrl)}`;
                    console.log(`🔄 Using transcoded URL: ${transcodedUrl}`);
                    hls.loadSource(transcodedUrl);
                    hls.attachMedia(video);
                    
                    hls.on(window.Hls.Events.MANIFEST_PARSED, function() {
                        console.log(`📡 HLS stream ready for task #${task.taskNumber}`);
                        // 🎯 兩階段播放策略：先靜音播放，然後取消靜音
                        video.muted = true;
                        video.play().then(() => {
                            console.log(`📡 Streaming started (muted) for task #${task.taskNumber}`);
                            setTimeout(() => {
                                video.muted = false;
                                video.volume = 1.0;
                                console.log(`🔊 Audio unmuted for task #${task.taskNumber}`);
                                
                                // 檢測實際播放時是否有音頻（更可靠的方法）
                                setTimeout(() => {
                                    const hasAudio = !video.muted && video.volume > 0 && 
                                                   (video.mozHasAudio || video.webkitAudioDecodedByteCount > 0 || 
                                                    (video.audioTracks && video.audioTracks.length > 0));
                                    if (hasAudio === false) {
                                        console.warn(`⚠️ Video may not have audio track (task #${task.taskNumber})`);
                                    }
                                }, 500);
                            }, 100);
                        }).catch(e => console.log('Autoplay prevented:', e));
                    });
                    
                    // HLS 錯誤處理
                    hls.on(window.Hls.Events.ERROR, function(event, data) {
                        if (data.fatal) {
                            switch(data.type) {
                                case window.Hls.ErrorTypes.NETWORK_ERROR:
                                    console.error('❌ Network error, recovering...');
                                    hls.startLoad();
                                    break;
                                case window.Hls.ErrorTypes.MEDIA_ERROR:
                                    console.error('❌ Media error, recovering...');
                                    hls.recoverMediaError();
                                    break;
                                default:
                                    console.error('❌ Fatal error, cannot recover');
                                    hls.destroy();
                                    break;
                            }
                        }
                    });
                    
                    task.hlsInstance = hls;
                } else if (video && video.canPlayType('application/vnd.apple.mpegurl')) {
                    // 原生支持HLS (Safari) - 也使用轉碼代理
                    const transcodedUrl = `/hls-transcode/${encodeURIComponent(task.streamUrl)}`;
                    console.log(`🔄 Safari using transcoded URL: ${transcodedUrl}`);
                    video.src = transcodedUrl;
                    video.muted = true;
                    video.play().then(() => {
                        console.log(`📡 Native HLS streaming started (muted) for task #${task.taskNumber}`);
                        setTimeout(() => {
                            video.muted = false;
                            video.volume = 1.0;
                            console.log(`🔊 Audio unmuted for task #${task.taskNumber}`);
                        }, 100);
                    }).catch(e => console.log('Autoplay prevented:', e));
                    console.log(`📡 Native HLS for task #${task.taskNumber}`);
                }
            }
        }

        // ==== Benchmark 對比渲染 ====
        function getPairKey(task) {
            // 以圖片名作為配對鍵
            return (task.imageName || '').toLowerCase();
        }

        function maybeRenderBenchmarkPair(task) {
            if (!task.benchmarkLabel) return; // 非 Benchmark 跳過
            const pairKey = getPairKey(task);
            if (!pairKey) return;
            // 找同圖另一半
            const other = Array.from(tasks.values()).find(t => t !== task && t.imageName === task.imageName && t.benchmarkLabel && t.url);
            if (!other || !task.url) return;

            // 構建左右對比卡
            const container = document.getElementById('benchmarkResults');
            const pairs = document.getElementById('benchmarkPairs');
            if (!container || !pairs) return;
            container.style.display = 'block';

            const promptA = task.benchmarkLabel === 'A' ? (task.promptText || '') : (other.promptText || '');
            const promptB = task.benchmarkLabel === 'B' ? (task.promptText || '') : (other.promptText || '');
            const endpointA = task.benchmarkLabel === 'A' ? (task.submissionDetails?.endpoint || '') : (other.submissionDetails?.endpoint || '');
            const endpointB = task.benchmarkLabel === 'B' ? (task.submissionDetails?.endpoint || '') : (other.submissionDetails?.endpoint || '');

            const safe = s => (s || '').replaceAll('<','&lt;').replaceAll('>','&gt;');

            const pairDiv = document.createElement('div');
            pairDiv.style.cssText = 'display:flex; gap:12px; align-items:flex-start; justify-content:center;';
            pairDiv.innerHTML = `
                <div style="flex:1; text-align:center; background:#fff; border:1px solid #e1e5e9; border-radius:6px; padding:8px;">
                    <div style="font-size:12px; color:#666; margin-bottom:4px;">A • ${safe(endpointA)}</div>
                    <video controls width="100%" preload="metadata" style="max-width:420px;">
                        <source src="${task.benchmarkLabel === 'A' ? task.url : other.url}" type="video/mp4">
                    </video>
                    <div style="font-size:12px; color:#555; white-space:pre-wrap; word-break:break-word; margin-top:4px;">📝 ${safe(promptA)}</div>
                </div>
                <div style="flex:1; text-align:center; background:#fff; border:1px solid #e1e5e9; border-radius:6px; padding:8px;">
                    <div style="font-size:12px; color:#666; margin-bottom:4px;">B • ${safe(endpointB)}</div>
                    <video controls width="100%" preload="metadata" style="max-width:420px;">
                        <source src="${task.benchmarkLabel === 'B' ? task.url : other.url}" type="video/mp4">
                    </video>
                    <div style="font-size:12px; color:#555; white-space:pre-wrap; word-break:break-word; margin-top:4px;">📝 ${safe(promptB)}</div>
                </div>
            `;
            // 保存 URL 於節點屬性，便於一鍵下載合併
            pairDiv.dataset.leftUrl = task.benchmarkLabel === 'A' ? task.url : other.url;
            pairDiv.dataset.rightUrl = task.benchmarkLabel === 'B' ? task.url : other.url;
            pairs.prepend(pairDiv);
        }

        async function downloadMergedBenchmark() {
            try {
                const pairs = document.getElementById('benchmarkPairs');
                if (!pairs || !pairs.firstElementChild) { showError('No benchmark pairs to download'); return; }
                const first = pairs.firstElementChild;
                const leftUrl = first.dataset.leftUrl;
                const rightUrl = first.dataset.rightUrl;
                if (!leftUrl || !rightUrl) { showError('Pair URLs missing'); return; }
                const form = new FormData();
                form.append('left_url', leftUrl);
                form.append('right_url', rightUrl);
                form.append('filename', 'benchmark_merged.mp4');
                // 優先使用本地合併服務 (有FFmpeg)
                const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                let resp;
                
                // 如果不在本地環境，嘗試連接本地服務
                if (!isLocalhost) {
                    try {
                        console.log('🔄 Trying local merge service for single pair...');
                        resp = await fetch('http://localhost:8000/benchmark/merge', { method: 'POST', body: form, mode: 'cors' });
                        if (resp && resp.ok) {
                            console.log('✅ Using local merge service');
                        } else {
                            resp = null;
                        }
                    } catch (e) { 
                        console.log('⚠️ Local service not available');
                        resp = null; 
                    }
                }
                
                // Fallback到當前服務器
                if (!resp || !resp.ok) {
                    resp = await fetch('/benchmark/merge', { method: 'POST', body: form });
                }
                if (!resp.ok) { const t = await resp.text(); throw new Error(t || 'merge failed'); }
                const blob = await resp.blob();
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = 'benchmark_merged.mp4';
                document.body.appendChild(a); a.click(); document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showSuccess('✅ Merged video downloaded');
            } catch (e) {
                showError('Merge download failed: ' + (e.message || e));
            }
        }

        async function downloadMergedAll() {
            try {
                const pairs = document.getElementById('benchmarkPairs');
                const list = [];
                Array.from(pairs.children).forEach((node, idx) => {
                    const leftUrl = node.dataset.leftUrl;
                    const rightUrl = node.dataset.rightUrl;
                    if (leftUrl && rightUrl) {
                        const baseName = (node.querySelector('video source')?.src || '').split('/').pop().replace(/\.mp4$/i,'') || `pair_${idx+1}`;
                        list.push({ left_url: leftUrl, right_url: rightUrl, filename: `${baseName}_merged.mp4` });
                    }
                });
                if (list.length === 0) { showError('No pairs available'); return; }
                let resp = null;
                
                // 優先嘗試本地合併服務 (有FFmpeg) - 檢測是否在本地環境
                const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                console.log('🎬 Requesting batch merge for', list.length, 'pairs');
                console.log(`📍 Running on: ${isLocalhost ? 'Local (FFmpeg available)' : 'Online (No FFmpeg)'}`);
                
                // 如果不在本地，嘗試連接本地merge服務
                if (!isLocalhost) {
                    try {
                        console.log('🔄 Trying to connect to local merge service...');
                        resp = await fetch('http://localhost:8000/benchmark/merge_batch', { 
                            method: 'POST', 
                            headers: { 'Content-Type': 'application/json' }, 
                            body: JSON.stringify({ pairs: list }),
                            mode: 'cors'
                        });
                        if (resp && resp.ok) {
                            console.log('✅ Using local merge service (localhost:8000)');
                        } else {
                            resp = null;
                        }
                    } catch (e) {
                        console.log('⚠️ Local merge service not available:', e.message);
                        resp = null;
                    }
                }
                
                // 如果本地服務不可用，使用當前服務器
                if (!resp) {
                    console.log('🎬 Requesting batch merge from current server');
                    resp = await fetch('/benchmark/merge_batch', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ pairs: list }) });
                    if (!resp.ok) {
                        console.error('❌ Merge batch failed:', resp.status, resp.statusText);
                        const errorText = await resp.text();
                        console.error('Error details:', errorText);
                        // 線上環境無 ffmpeg 時退化為打包原視頻
                        console.log('🔄 Falling back to zip_pairs...');
                        resp = await fetch('/benchmark/zip_pairs', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ pairs: list }) });
                        if (!resp.ok) { const t = await resp.text(); throw new Error(t || 'merge batch/zip fallback failed'); }
                        console.log('✅ Using fallback zip (original videos without merge)');
                    }
                }
                const blob = await resp.blob();
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = 'benchmark_merged_all.zip';
                document.body.appendChild(a); a.click(); document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showSuccess('✅ All merged videos downloaded as ZIP');
            } catch (e) {
                showError('Merge batch download failed: ' + (e.message || e));
            }
        }

        async function downloadTaskVideo(taskId) {
            const task = tasks.get(taskId);
            if (!task || !task.url) {
                showError('視頻資訊不完整，無法下載');
                return;
            }
            
            try {
                // 生成基於圖片名稱的文件名，添加任務ID確保唯一性
                const imageName = (task.imageName || '').replace(/\.[^/.]+$/, '') || 'video';
                const shortTaskId = task.id.substring(0, 8); // 使用任務ID前8位
                const defaultFileName = `${imageName}.mp4`;
                
                console.log('🔄 Downloading single video:', {
                    taskId: task.id,
                    imageName: task.imageName,
                    url: task.url,
                    defaultFileName: defaultFileName,
                    fullTask: task
                });
                
                // 檢查是否支援 File System Access API (Chrome 86+) 且在 HTTPS 環境
                const isSecureContext = window.isSecureContext || location.protocol === 'https:';
                const hasFileSystemAPI = 'showSaveFilePicker' in window;
                
                console.log('File System API availability:', {
                    hasFileSystemAPI,
                    isSecureContext,
                    protocol: location.protocol
                });
                
                if (hasFileSystemAPI && isSecureContext) {
                    try {
                        // 使用新的 File System Access API 讓用戶選擇存儲位置
                        const fileHandle = await window.showSaveFilePicker({
                            suggestedName: defaultFileName,
                            types: [{
                                description: 'Video files',
                                accept: {
                                    'video/mp4': ['.mp4']
                                }
                            }]
                        });
                        
                        showSuccess('開始下載視頻...');
                        
                        const response = await fetch(task.url, {
                            method: 'GET',
                            headers: {
                                'Accept': 'video/mp4,video/*,*/*'
                            }
                        });
                        
                        if (!response.ok) {
                            throw new Error(`下載失敗: ${response.status} ${response.statusText}`);
                        }
                        
                        const writableStream = await fileHandle.createWritable();
                        await response.body.pipeTo(writableStream);
                        
                        showSuccess('✅ 視頻下載成功！');
                        return;
                    } catch (filePickerError) {
                        if (filePickerError.name === 'AbortError') {
                            showError('下載已取消');
                            return;
                        }
                        console.log('📝 File picker failed, falling back to regular download:', filePickerError.message);
                    }
                }
                
                // 降級到傳統下載方式
                showSuccess('開始下載視頻...');
                
                const response = await fetch(task.url, {
                    method: 'GET',
                    headers: {
                        'Accept': 'video/mp4,video/*,*/*'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`下載失敗: ${response.status} ${response.statusText}`);
                }
                
                const blob = await response.blob();
                
                // 創建下載連結
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = defaultFileName;
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                // 清理 blob URL
                window.URL.revokeObjectURL(url);
                
                showSuccess(`✅ 視頻下載成功！檔名：${defaultFileName}`);
                
            } catch (error) {
                console.error('❌ Download failed:', error);
                showError(`下載失敗: ${error.message}`);
                
                // 如果 fetch 失敗，嘗試直接打開連結
                console.log('🔄 Fallback: Opening video URL directly');
                window.open(task.url, '_blank');
            }
        }

        function updateTasksSummary() {
            const totalTasksElement = document.getElementById('totalTasks');
            const averageTimeElement = document.getElementById('averageTime');
            
            const completedTasks = Array.from(tasks.values()).filter(task => 
                task.endTime && (task.status === 'finished' || task.status === 'completed')
            );
            
            totalTasksElement.textContent = tasks.size;
            
            if (completedTasks.length > 0) {
                const totalTime = completedTasks.reduce((sum, task) => sum + task.duration, 0);
                const avgTime = Math.round(totalTime / completedTasks.length);
                const minutes = Math.floor(avgTime / 60);
                const seconds = avgTime % 60;
                
                const avgText = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
                averageTimeElement.textContent = `${avgText} (${completedTasks.length}/${tasks.size})`;
            } else {
                averageTimeElement.textContent = '-';
            }
            
            // 顯示/隱藏下載按鈕
            const downloadBtn = document.getElementById('downloadAllBtn');
            const downloadCard = document.getElementById('downloadAllCard');
            const completedVideos = Array.from(tasks.values()).filter(task => 
                (task.status === 'finished' || task.status === 'completed') && task.url
            );
            
            if (downloadBtn && downloadCard) {
                if (completedVideos.length > 0) {
                    downloadCard.style.display = 'block';
                    downloadBtn.textContent = `📦 Download All Completed Videos (${completedVideos.length})`;
                } else {
                    downloadCard.style.display = 'none';
                }
            }
            
            // 顯示/隱藏 Sticking Video 合併下載按鈕
            const downloadStickingCard = document.getElementById('downloadStickingCard');
            const completedStickingVideos = Array.from(tasks.values()).filter(task => 
                task.stickingVideoMode && 
                (task.status === 'finished' || task.status === 'completed') && 
                task.url
            );
            
            if (downloadStickingCard) {
                if (completedStickingVideos.length >= 3) {
                    downloadStickingCard.style.display = 'block';
                } else {
                    downloadStickingCard.style.display = 'none';
                }
            }
        }

        // 下載合併的 Sticking Videos
        async function downloadMergedStickingVideos() {
            console.log('🎬 Starting sticking videos merge...');
            
            // 獲取所有完成的 sticking video 任務
            const completedStickingVideos = Array.from(tasks.values()).filter(task => 
                task.stickingVideoMode && 
                (task.status === 'finished' || task.status === 'completed') && 
                task.url
            ).sort((a, b) => a.stickingVideoVariant - b.stickingVideoVariant); // 按變體編號排序
            
            console.log(`📋 Found ${completedStickingVideos.length} completed sticking videos:`, 
                completedStickingVideos.map(t => ({ variant: t.stickingVideoVariant, url: t.url })));
            
            if (completedStickingVideos.length !== 3) {
                showError(`❌ Need exactly 3 completed sticking videos, but found ${completedStickingVideos.length}`);
                return;
            }
            
            const downloadBtn = document.getElementById('downloadStickingBtn');
            const originalText = downloadBtn.textContent;
            downloadBtn.disabled = true;
            downloadBtn.textContent = '⏳ Merging videos...';
            
            try {
                // 使用 fade 轉場效果
                const transition = 'fade';
                console.log(`💫 Using fade transition`);
                
                // 提取視頻 URLs
                const videoUrls = completedStickingVideos.map(task => task.url);
                
                showSuccess('💫 Downloading and merging videos with fade effect...');
                
                // 調用後端合併 API
                const response = await fetch('/merge-sticking-videos', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        video_urls: videoUrls,
                        transition: transition
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error || `HTTP ${response.status}`);
                }
                
                // 獲取合併後的視頻 blob
                const blob = await response.blob();
                
                // 創建下載連結
                const url = window.URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `sticking_videos_merged_fade.mp4`;
                link.style.display = 'none';
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // 清理 blob URL
                window.URL.revokeObjectURL(url);
                
                showSuccess(`✅ Sticking videos merged successfully with fade effect!`);
                
            } catch (error) {
                console.error('❌ Merge failed:', error);
                showError(`❌ Merge failed: ${error.message}`);
            } finally {
                downloadBtn.disabled = false;
                downloadBtn.textContent = originalText;
            }
        }

        // 下載所有完成的視頻
        async function downloadAllVideos() {
            console.log('🔄 Starting batch download...');
            
            const completedVideos = Array.from(tasks.values()).filter(task => 
                (task.status === 'finished' || task.status === 'completed') && task.url
            );
            
            console.log(`📋 Found ${completedVideos.length} completed videos:`, completedVideos.map(t => ({
                id: t.id,
                imageName: t.imageName,
                promptText: t.promptText,
                url: t.url
            })));
            
            if (completedVideos.length === 0) {
                showError('No completed videos to download');
                return;
            }
            
            const downloadBtn = document.getElementById('downloadAllBtn');
            const originalText = downloadBtn.textContent;
            downloadBtn.disabled = true;
            downloadBtn.textContent = '📥 Downloading...';
            
            try {
                let successCount = 0;
                let failCount = 0;
                
                for (let i = 0; i < completedVideos.length; i++) {
                    const task = completedVideos[i];
                    
                    try {
                        console.log(`📥 Downloading video ${i + 1}/${completedVideos.length}:`, {
                            taskId: task.id,
                            imageName: task.imageName,
                            url: task.url
                        });
                        
                        // 使用 fetch 下載視頻文件
                        const response = await fetch(task.url, {
                            method: 'GET',
                            headers: {
                                'Accept': 'video/mp4,video/*,*/*'
                            }
                        });
                        
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        
                        const blob = await response.blob();
                        
                        // 創建下載連結
                        const url = window.URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        
                        // 使用圖片名稱作為視頻檔名，添加任務ID確保唯一性
                        const imageName = (task.imageName || '').replace(/\.[^/.]+$/, '') || `video_${task.taskNumber}`;
                        const fileName = `${imageName}.mp4`;
                        link.download = fileName;
                        link.style.display = 'none';
                        
                        console.log(`💾 Download filename: ${fileName}`);
                        
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        
                        // 清理 blob URL
                        window.URL.revokeObjectURL(url);
                        
                        successCount++;
                        
                        // 更新按鈕文字顯示進度
                        downloadBtn.textContent = `📥 Downloading... (${i + 1}/${completedVideos.length})`;
                        
                        // 短暫延遲避免瀏覽器阻止多個下載
                        if (i < completedVideos.length - 1) {
                            await new Promise(resolve => setTimeout(resolve, 800));
                        }
                        
                    } catch (error) {
                        console.error(`❌ Failed to download video ${task.taskNumber}:`, error);
                        failCount++;
                    }
                }
                
                // 顯示結果
                if (successCount === completedVideos.length) {
                    showSuccess(`✅ Successfully started download for all ${successCount} video(s)!`);
                } else if (successCount > 0) {
                    showSuccess(`⚠️ Downloaded ${successCount}/${completedVideos.length} video(s). ${failCount} failed.`);
                } else {
                    showError(`❌ Failed to download any videos. Please try downloading individually.`);
                }
                
                // 確保任務狀態保持不變
                console.log(`📊 Tasks status after download:`, Array.from(tasks.values()).length, 'tasks remaining');
                
            } catch (error) {
                console.error('❌ Batch download error:', error);
                showError(`Download failed: ${error.message}`);
            } finally {
                downloadBtn.disabled = false;
                downloadBtn.textContent = originalText;
                
                // 強制更新任務摘要以確保UI正確
                updateTasksSummary();
            }
        }

        // 調試任務數據
        function debugTasks() {
            console.log('=== Debug Tasks Info ===');
            console.log('Total tasks:', tasks.size);
            console.log('Tasks Map:', tasks);
            
            Array.from(tasks.values()).forEach((task, index) => {
                console.log(`Task ${index + 1}:`, {
                    id: task.id,
                    taskNumber: task.taskNumber,
                    imageName: task.imageName,
                    promptText: task.promptText,
                    status: task.status,
                    url: task.url
                });
            });
            
            showSuccess('調試信息已輸出到控制台，請按F12查看');
        }

        // 測試連接功能
        async function testConnection() {
            console.log('testConnection function called');
            
            const apiKey = document.getElementById('apiKey').value;
            const apiConfig = getCurrentAPIConfig();
            const apiUrl = apiConfig.endpoint;

            if (!apiKey) {
                showError('Please enter API Key first');
                return;
            }

            clearMessages();
            
            // 獲取完整URL信息
            const providerConfig = API_PROVIDERS[apiConfig.provider];
            const baseUrl = providerConfig.baseUrl;
            const fullUrl = baseUrl + apiConfig.endpoint;
            
            // 使用正確的 API Key（如果用戶沒有輸入，使用配置中的默認值）
            const effectiveApiKey = apiKey || providerConfig.apiKey;
            
            // 顯示調試信息
            const debugInfo = `
🔍 <strong>Test Connection Debug Info:</strong><br>
📍 <strong>Provider:</strong> ${apiConfig.provider}<br>
🔗 <strong>API Version:</strong> ${apiConfig.version}<br>
🌐 <strong>Base URL:</strong> ${baseUrl}<br>
🎯 <strong>Endpoint:</strong> ${apiConfig.endpoint}<br>
🔗 <strong>Full URL:</strong> ${fullUrl}<br>
🔑 <strong>API Key:</strong> ${effectiveApiKey.substring(0, 8)}...${effectiveApiKey.substring(effectiveApiKey.length - 8)}<br>
⏳ Sending test request...
            `;
            showSuccess(debugInfo);

            try {
                console.log('=== Test Connection Debug Info ===');
                console.log('Provider:', apiConfig.provider);
                console.log('API Version:', apiConfig.version);
                console.log('Base URL:', baseUrl);
                console.log('Endpoint:', apiConfig.endpoint);
                console.log('Full URL:', fullUrl);
                console.log('Proxy Endpoint:', apiUrl);
                console.log('API Key:', `${apiKey.substring(0, 8)}...${apiKey.substring(apiKey.length - 8)}`);

                // 創建一個最小的測試請求體
                const formData = new FormData();
                formData.append('prompt', 'test connection');
                formData.append('provider', getCurrentAPIConfig().provider);
                formData.append('version', getCurrentAPIConfig().version);
                
                // 創建一個1x1像素的測試圖片
                const canvas = document.createElement('canvas');
                canvas.width = 1;
                canvas.height = 1;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, 1, 1);
                
                // 將canvas轉換為blob
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                formData.append('image', blob, 'test.png');

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'X-API-KEY': effectiveApiKey
                    },
                    body: formData
                });

                console.log('=== Response Info ===');
                console.log('Status:', response.status, response.statusText);
                console.log('Headers:', [...response.headers.entries()]);

                // 讀取響應內容
                let responseText = '';
                try {
                    responseText = await response.text();
                    console.log('Response content:', responseText);
                } catch (e) {
                    console.log('Could not read response content:', e);
                    responseText = 'Could not read response content';
                }

                // 顯示完整的測試結果
                const resultInfo = `
🔍 <strong>Test Connection Results:</strong><br>
📍 <strong>Provider:</strong> ${apiConfig.provider}<br>
🔗 <strong>API Version:</strong> ${apiConfig.version}<br>
🌐 <strong>Base URL:</strong> ${baseUrl}<br>
🎯 <strong>Endpoint:</strong> ${apiConfig.endpoint}<br>
🔗 <strong>Full URL:</strong> ${fullUrl}<br>
🔑 <strong>API Key:</strong> ${effectiveApiKey.substring(0, 8)}...${effectiveApiKey.substring(effectiveApiKey.length - 8)}<br>
📊 <strong>Response Status:</strong> ${response.status} ${response.statusText}<br>
📝 <strong>Response Content:</strong><br>
<pre style="background: #f5f5f5; padding: 10px; border-radius: 5px; max-height: 200px; overflow-y: auto; font-size: 12px; white-space: pre-wrap;">${responseText}</pre>
                `;

                if (response.status === 200 || response.status === 201 || response.status === 202) {
                    showSuccess(resultInfo + '<br>✅ <strong>Connection test successful!</strong>');
                } else if (response.status === 401) {
                    showError(resultInfo + '<br>❌ <strong>Authentication failed: API Key might be invalid</strong>');
                } else if (response.status === 403) {
                    showError(resultInfo + '<br>❌ <strong>Forbidden: API Key might not have access</strong>');
                } else if (response.status === 404) {
                    showError(resultInfo + '<br>❌ <strong>API endpoint not found: Please check the URL</strong>');
                } else if (response.status === 400) {
                    showError(resultInfo + '<br>⚠️ <strong>Bad Request: API Key or request format may be incorrect</strong>');
                } else if (response.status === 500) {
                    showError(resultInfo + '<br>⚠️ <strong>Server Error: API service may be temporarily unavailable</strong>');
                } else {
                    showError(resultInfo + `<br>⚠️ <strong>Received response status: ${response.status} ${response.statusText}</strong>`);
                }

            } catch (error) {
                console.error('Connection test error:', error);
                
                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    showError('❌ Network Error: Could not connect to server. Check URL and network connection.');
                } else if (error.message.includes('CORS')) {
                    showError('❌ CORS Error: Cross-origin request blocked by browser.');
                } else {
                    showError(`❌ Connection failed: ${error.message}`);
                }
            }
        }

        // 添加調試檢查功能
        async function debugCheck() {
            console.log('debugCheck function called');
            const apiKey = document.getElementById('apiKey').value;
            const apiConfig = getCurrentAPIConfig();
            const apiUrl = apiConfig.endpoint;

            if (!apiKey) {
                showError('Please enter API Key first');
                return;
            }

            clearMessages();
            showSuccess('Performing debug check...');

            try {
                // 嘗試一個簡單的請求來進行調試檢查
                const response = await fetch(apiUrl, {
                    method: 'OPTIONS',
                    headers: {
                        'X-API-KEY': apiKey,
                    }
                });

                console.log('Debug check response:', response.status, response.statusText);

                if (response.status === 405) {
                    showSuccess('✅ Debug check successful!');
                } else if (response.status === 200 || response.status === 204) {
                    showError('❌ Debug check failed: Received non-405 status code');
                } else {
                    showError(`⚠️ Received response status: ${response.status} ${response.statusText}`);
                }

            } catch (error) {
                console.error('Debug check error:', error);
                if (error.message.includes('CORS')) {
                    showError('❌ CORS Error: May need to run in a CORS-enabled environment.');
                } else if (error.message.includes('network')) {
                    showError('❌ Network Error: Check network connection and URL.');
                } else {
                    showError(`❌ Debug check failed: ${error.message}`);
                }
            }
        }


        
        function getCurrentApiUrl() {
            return getCurrentAPIConfig().endpoint;
        }

        // 頁面載入時的初始化
        window.addEventListener('load', () => {
            console.log('🚀 Parrot API Multi-Task Frontend Loaded');
            
            // API配置已固定為staging環境
            updateProviderVersions(); // 初始化提供商和版本選擇
            // 初始化 Benchmark 區域
            try {
                document.getElementById('benchmarkToggle')?.addEventListener('change', (e) => {
                    const on = e.target.checked;
                    document.getElementById('benchmarkConfig')?.classList.toggle('hidden', !on);
                    if (on) updateProviderVersionsB();
                });
            } catch {}
        });

        // 頁面卸載時清理
        window.addEventListener('beforeunload', () => {
            stopStatusCheck();
        });

        async function minimaxTTS() {
            try {
                const text = document.getElementById('minimaxText').value.trim();
                const voiceId = document.getElementById('minimaxVoiceId').value.trim();
                const groupId = document.getElementById('minimaxGroupId').value.trim();
                const apiKey = document.getElementById('minimaxApiKey').value.trim();

                if (!text) {
                    showError('請先輸入文本');
                    return;
                }
                if (!groupId && !apiKey) {
                    showError('請填寫 MINIMAX_GROUPID 與 MINIMAX_API_KEY，或在服務器設置環境變量');
                    return;
                }

                clearMessages();
                showSuccess('⏳ 正在生成音頻，請稍候...');

                const body = { text };
                if (window.minimaxCurrentVoiceId) body.voice_id = window.minimaxCurrentVoiceId;

                const response = await fetch('/minimax/t2a', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(body)
                });

                if (!response.ok) {
                    let errJson = {}, errText = '';
                    try { errText = await response.text(); errJson = JSON.parse(errText); } catch { errJson = {}; }
                    const code = errJson.provider_status_code ?? errJson.status ?? errJson.base_resp?.status_code;
                    const msg = errJson.provider_status_msg ?? errJson.base_resp?.status_msg ?? (errJson.provider_response?.base_resp?.status_msg);
                    const base = errJson.error || errJson.message || 'Request failed';
                    const details = `${base}${code ? ` [${code}]` : ''}${msg ? `: ${msg}` : ''}`;
                    console.error('Minimax TTS failed:', { status: response.status, bodyText: errText, parsed: errJson });
                    throw new Error(details || `HTTP ${response.status}`);
                }

                const blob = await response.blob();
                const url = URL.createObjectURL(blob);
                const player = document.getElementById('minimaxAudioPlayer');
                const link = document.getElementById('minimaxAudioLink');

                player.src = url;
                player.style.display = 'block';
                link.href = url;
                link.download = `minimax-${Date.now()}.mp3`;
                link.style.display = 'inline-block';

                showSuccess('✅ 生成成功，可播放或下載');
            } catch (e) {
                showError(`❌ 生成失敗: ${e.message}`);
            }
        }

        async function onStartButtonClick() {
            const isBenchmark = document.getElementById('benchmarkToggle')?.checked;
            const provider = document.getElementById('apiProvider')?.value;
            if (!isBenchmark) {
                if (provider === 'minimax') {
                    await minimaxTTS();
                } else {
                    await generateVideo();
                }
                return;
            }

            // Benchmark 模式：同一批圖片，分別用 A/B 兩組配置提交（使用 Benchmark 區域的 Prompt）
            const images = Array.from(document.getElementById('imageFile').files || []);
            if (images.length === 0) { showError('Please select at least one image file'); return; }

            const aKey = document.getElementById('apiKey')?.value || '';
            const bKey = document.getElementById('apiKeyB')?.value || '';
            const aCfg = getCurrentAPIConfig();
            const bCfg = getCurrentAPIConfigB();
            const promptA = document.getElementById('promptTextA')?.value || '';
            const promptB = document.getElementById('promptTextB')?.value || '';

            for (const img of images) {
                // A：覆寫參數後復用原有 submitTask（保留任務/輪詢/錯誤處理）
                window.benchmarkOverrideConfig = aCfg;
                window.benchmarkOverrideApiKey = aKey;
                window.benchmarkOverridePrompt = promptA;
                window.benchmarkLabel = 'A';
                window.benchmarkImageName = img.name || '';
                await submitTask(img);
                // B：
                window.benchmarkOverrideConfig = bCfg;
                window.benchmarkOverrideApiKey = bKey;
                window.benchmarkOverridePrompt = promptB;
                window.benchmarkLabel = 'B';
                window.benchmarkImageName = img.name || '';
                await submitTask(img);
                // 清理
                window.benchmarkOverrideConfig = null;
                window.benchmarkOverrideApiKey = null;
                window.benchmarkOverridePrompt = null;
                window.benchmarkLabel = null;
                window.benchmarkImageName = null;
            }
        }

        // Minimax Clone 前端交互（自動克隆）
        let minimaxCurrentVoiceId = '';
        (function initMinimaxCloneUI(){
            const upload = document.getElementById('minimaxCloneUpload');
            const input = document.getElementById('minimaxCloneFile');
            const nameEl = document.getElementById('minimaxCloneFileName');
            const statusEl = document.getElementById('minimaxCloneStatus');
            if (!upload || !input) return;
            upload.addEventListener('click', () => input.click());
            upload.addEventListener('dragover', e => { e.preventDefault(); upload.classList.add('drag-over'); });
            upload.addEventListener('dragleave', () => upload.classList.remove('drag-over'));
            upload.addEventListener('drop', e => {
                e.preventDefault(); upload.classList.remove('drag-over');
                if (e.dataTransfer?.files?.length){ input.files = e.dataTransfer.files; if (nameEl) nameEl.textContent = `Selected: ${e.dataTransfer.files[0].name}`; autoClone(); }
            });
            input.addEventListener('change', () => { const f = input.files?.[0]; if (nameEl) nameEl.textContent = f ? `Selected: ${f.name}` : ''; if (f) autoClone(); });

            async function autoClone() {
                try {
                    console.log('🚀 AUTO CLONE STARTED!!!');
                    const f = input.files?.[0];
                    if (!f) return;
                    
                    // 檢查文件類型（支持音頻和視頻文件）
                    const isAudio = f.type.startsWith('audio/') || f.name.match(/\.(mp3|wav|m4a|aac|ogg|flac)$/i);
                    const isVideo = f.type.startsWith('video/') || f.name.match(/\.(mp4|mov|avi|mkv)$/i);
                    if (!isAudio && !isVideo) {
                        if (statusEl) statusEl.textContent = '❌ 請上傳音頻或視頻文件';
                        showError('請上傳音頻文件（MP3/WAV/M4A等）或視頻文件（MP4等，將自動提取音頻）');
                        return;
                    }
                    
                    clearMessages();
                    if (statusEl) statusEl.textContent = '⏳ 正在上傳並克隆...';
                    console.log('🔄 About to send request to /minimax/clone');
                    const fd = new FormData();
                    fd.append('audio', f);
                    const resp = await fetch('/minimax/clone', { method: 'POST', body: fd });
                    console.log('📡 Got response, status:', resp.status);
                    let text = '', data = {};
                    try { text = await resp.text(); console.log('📄 Raw response text:', text); data = JSON.parse(text); } catch { data = {}; }
                    console.log('🔍 Minimax /clone response:', { status: resp.status, raw: text, parsed: data });
                    if (!resp.ok) { 
                        const code = data.provider_status_code ?? data.status ?? data.base_resp?.status_code;
                        const msg = data.provider_status_msg ?? data.base_resp?.status_msg ?? (data.provider_response?.base_resp?.status_msg);
                        const base = data.error || data.message || 'Request failed';
                        const details = `${base}${code ? ` [${code}]` : ''}${msg ? `: ${msg}` : ''}`;
                        console.error('❌ Minimax clone failed:', { status: resp.status, raw: text, parsed: data });
                        throw new Error(details || `HTTP ${resp.status}`); 
                    }
                    if (data.voice_id) {
                        minimaxCurrentVoiceId = data.voice_id;
                        if (statusEl) statusEl.textContent = `✅ 克隆成功 voice_id: ${data.voice_id}`;
                        showSuccess(`✅ 語音克隆成功，voice_id: ${data.voice_id}`);
                    }
                    if (data.preview_audio) {
                        const p = document.getElementById('minimaxClonePreview');
                        p.src = data.preview_audio; p.style.display = 'block';
                    }
                } catch (e) {
                    if (statusEl) statusEl.textContent = `❌ 克隆失敗: ${e.message}`;
                    showError(`❌ 克隆失敗: ${e.message}`);
                }
            }
        })();
    </script>
</body>
</html> 