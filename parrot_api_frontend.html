<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parrot API - Image to Video Generator</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ¬</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 16px;
        }

        .content {
            padding: 40px;
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .hidden { display: none !important; }

        .file-upload-area {
            border: 2px dashed #ddd;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            background: #fafafa;
        }

        .file-upload-area:hover {
            border-color: #4facfe;
            background: #f0f9ff;
        }

        .file-upload-area.drag-over {
            border-color: #4facfe;
            background: #e6f3ff;
        }

        .upload-icon {
            font-size: 48px;
            color: #ddd;
            margin-bottom: 15px;
        }

        .file-upload-area.has-file {
            border-color: #4caf50;
            background: #f1f8e9;
        }

        .file-upload-area.has-file .upload-icon {
            color: #4caf50;
        }

        input[type="file"] {
            display: none;
        }

        .form-control {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }

        .form-control:focus {
            outline: none;
            border-color: #4facfe;
        }

        textarea.form-control {
            resize: vertical;
            min-height: 100px;
        }

        .api-config {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 25px;
        }

        .api-config h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .btn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-bottom: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(79, 172, 254, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .status-area {
            margin-top: 30px;
            padding: 20px;
            border-radius: 10px;
            background: #f8f9fa;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #e1e5e9;
        }

        .status-item:last-child {
            border-bottom: none;
        }

        .status-label {
            font-weight: 600;
            color: #333;
        }

        .status-value {
            color: #666;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e1e5e9;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4facfe, #00f2fe);
            transition: width 0.3s ease;
            width: 0%;
        }

        .result-area {
            margin-top: 30px;
            text-align: center;
        }

        .video-container {
            margin: 20px 0;
        }

        .video-container video {
            max-width: 100%;
            border-radius: 10px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }

        .error-message {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .success-message {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .preview-image {
            max-width: 300px;
            max-height: 200px;
            border-radius: 8px;
            margin-top: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .task-card {
            background: white;
            border: 1px solid #e1e5e9;
            border-radius: 10px;
            margin-bottom: 20px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .task-card.completed {
            border-color: #4caf50;
            background: #f8fff8;
        }

        .task-card.failed {
            border-color: #f44336;
            background: #fff8f8;
        }

        .task-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e1e5e9;
        }

        .task-title {
            font-weight: 600;
            color: #333;
        }

        .task-status {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
        }

        .task-status.processing {
            background: #fff3cd;
            color: #856404;
        }

        .task-status.completed {
            background: #d4edda;
            color: #155724;
        }

        .task-status.failed {
            background: #f8d7da;
            color: #721c24;
        }

        .task-details {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 15px;
        }

        .task-detail-item {
            text-align: center;
        }

        .task-detail-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }

        .task-detail-value {
            font-weight: 600;
            color: #333;
        }

        .task-video {
            text-align: center;
            margin-top: 15px;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
            }
            
            .content {
                padding: 20px;
            }
            
            .header {
                padding: 20px;
            }

            .task-details {
                grid-template-columns: 1fr;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¬ Parrot API Image to Video</h1>
            <p>Upload an image, add a prompt, and generate beautiful videos</p>
        </div>

        <div class="content">


            <!-- API é…ç½®å€åŸŸ -->
            <div class="api-config">
                <h3>ğŸ”§ API Configuration</h3>
                <div class="form-group" style="margin-top: 10px;">
                    <label style="display:flex;align-items:center;gap:8px;">
                        <input type="checkbox" id="benchmarkToggle" /> Benchmark Modeï¼ˆé›™è·¯å°æ¯”ï¼ŒåŒåœ–è³‡ï¼‰
                    </label>
                </div>
                
                <!-- API æä¾›å•†é¸æ“‡ -->
                <div class="form-group">
                    <label for="apiProvider">API Provider:</label>
                    <select id="apiProvider" class="form-control" onchange="updateProviderVersions()">
                        <option value="staging" selected>Staging - Parrot Labs API æœå‹™å™¨</option>
                        <option value="original">Original - Original Parrot API æœå‹™å™¨</option>
                        <option value="minimax">Minimax text to audio</option>
                    </select>
                </div>

                <!-- API ç‰ˆæœ¬é¸æ“‡ -->
                <div class="form-group">
                    <label for="apiVersion">API Version:</label>
                    <select id="apiVersion" class="form-control" onchange="updateAPIDescription()">
                        <!-- ç‰ˆæœ¬é¸é …æœƒç”± JavaScript å‹•æ…‹å¡«å…… -->
                    </select>
                </div>

                <!-- ç«¯é»é¡å‹é¸æ“‡ (åƒ… Original API v0) -->
                <div class="form-group" id="endpointTypeGroup" style="display: none;">
                    <label for="endpointType">Endpoint Type:</label>
                    <select id="endpointType" class="form-control" onchange="updateAPIDescription()">
                        <option value="image-to-video">image-to-video (é»˜èª)</option>
                        <option value="image-to-video-new">image-to-video-new</option>
                        <option value="image-to-video-inner">image-to-video-inner</option>
                        <option value="image-to-video-nmd">image-to-video-nmd</option>
                        <option value="audio-to-video">audio-to-video</option>
                    </select>
                </div>

                <!-- Benchmark é…ç½®å€åŸŸ -->
                <div id="benchmarkConfig" class="section hidden" style="margin-top:12px;padding-top:12px;border-top:1px dashed #ddd;">
                    <h4 style="margin-bottom:8px;">Benchmark</h4>
                    <div class="form-group">
                        <label for="promptTextA">Prompt (A)</label>
                        <textarea id="promptTextA" class="form-control" placeholder="Prompt for A..." rows="2"></textarea>
                    </div>
                    <div class="form-group">
                        <label for="apiProviderB">API Provider (B):</label>
                        <select id="apiProviderB" class="form-control" onchange="updateProviderVersionsB()">
                            <option value="staging">Staging - Parrot Labs API æœå‹™å™¨</option>
                            <option value="original" selected>Original - Original Parrot API æœå‹™å™¨</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="apiVersionB">API Version (B):</label>
                        <select id="apiVersionB" class="form-control" onchange="updateAPIDescriptionB()"></select>
                    </div>
                    <div class="form-group" id="endpointTypeGroupB" style="display:none;">
                        <label for="endpointTypeB">Endpoint Type (B):</label>
                        <select id="endpointTypeB" class="form-control" onchange="updateAPIDescriptionB()">
                            <option value="image-to-video">image-to-video (é»˜èª)</option>
                            <option value="image-to-video-new">image-to-video-new</option>
                            <option value="image-to-video-inner">image-to-video-inner</option>
                            <option value="image-to-video-nmd">image-to-video-nmd</option>
                            <option value="audio-to-video">audio-to-video</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <div id="apiDescriptionB" style="background:#f8f9fa;padding:10px;border-radius:5px;border:1px solid #e9ecef;font-size:14px;color:#666;">è«‹é¸æ“‡ API æä¾›å•†å’Œç‰ˆæœ¬</div>
                    </div>
                    <div class="form-group">
                        <label for="apiKeyB">API Key (B):</label>
                        <input type="password" id="apiKeyB" class="form-control" value="" placeholder="Enter API Key for B">
                    </div>
                    <div class="form-group">
                        <label for="promptTextB">Prompt (B)</label>
                        <textarea id="promptTextB" class="form-control" placeholder="Prompt for B..." rows="2"></textarea>
                    </div>
                </div>

                <!-- API æè¿°é¡¯ç¤º -->
                <div class="form-group">
                    <div id="apiDescription" style="background: #f8f9fa; padding: 10px; border-radius: 5px; border: 1px solid #e9ecef; font-size: 14px; color: #666;">
                        è«‹é¸æ“‡ API æä¾›å•†å’Œç‰ˆæœ¬
                    </div>
                </div>
                <div class="form-group">
                    <label for="apiKey">API Key:</label>
                    <input type="password" id="apiKey" class="form-control" value="" placeholder="Enter your API Key">
                    <small style="color: #666; margin-top: 5px; display: block;">
                        ğŸ’¡ Tip: API Keys usually start with "pk-" or a similar prefix
                    </small>
                </div>
                <div class="form-group">
                    <button type="button" class="btn" onclick="testConnection()" style="background: #28a745; margin-bottom: 10px;">
                        ğŸ” Test Connection
                    </button>
                    <button type="button" class="btn" onclick="debugCheck()" style="background: #6c757d; margin-bottom: 10px;">
                        ğŸ› Debug Check
                    </button>
                    <button type="button" class="btn" onclick="debugTasks()" style="background: #e83e8c; margin-bottom: 10px;">
                        ğŸ“Š Debug Tasks
                    </button>
                </div>

                <!-- Text to Audio (MiniMax) -->
                <div id="minimaxSection" class="section hidden" style="margin-top: 16px; padding: 12px; border-top: 1px solid #eee; background:#fafafa; border-radius:8px;">
                    <h3 style="margin-bottom: 8px; font-size:18px;">Text to Audio (MiniMax)</h3>
                    <div class="form-group">
                        <label for="minimaxText">Text:</label>
                        <textarea id="minimaxText" class="form-control" rows="3" placeholder="è¼¸å…¥è¦åˆæˆçš„æ–‡æœ¬"></textarea>
                    </div>
                    <div class="form-group" style="margin-top:8px; padding-top: 8px; border-top: 1px dashed #e5e5e5;">
                        <h4 style="margin-bottom: 6px; font-size: 14px;">Voice Clone</h4>
                        <div class="file-upload-area" id="minimaxCloneUpload" style="cursor:pointer;">
                            <div class="upload-icon">ğŸµ</div>
                            <div class="upload-text">
                                <strong>é»æ“Šé¸æ“‡æˆ–æ‹–æ‹½ä¸Šå‚³éŸ³é »/è¦–é »</strong><br>
                                <small>æ”¯æŒ MP3/WAV/M4A/MP4ï¼›å»ºè­° 10-30 ç§’æ¸…æ™°äººè²ï¼ˆè‡ªå‹•å…‹éš†ï¼‰</small>
                            </div>
                            <input type="file" id="minimaxCloneFile" accept="audio/*,video/*" style="display:none;">
                            <div id="minimaxCloneFileName" style="margin-top: 8px; font-size: 12px; color: #666;"></div>
                        </div>
                        <div id="minimaxCloneStatus" style="margin-top:8px; font-size:12px; color:#666;"></div>
                        <audio id="minimaxClonePreview" controls style="display:none; margin-top:8px; width:100%;"></audio>
                    </div>
                    <div class="form-group">
                        <button type="button" class="btn" style="background:#007bff;" onclick="minimaxTTS()">ğŸ”ˆ ç”ŸæˆéŸ³é »</button>
                        <a id="minimaxAudioLink" style="display:none;margin-left:8px;" download>ä¸‹è¼‰éŸ³é »</a>
                        <audio id="minimaxAudioPlayer" controls style="display:none;margin-top:8px;width:100%;"></audio>
                    </div>
                </div>
            </div>

            <!-- åœ–ç‰‡ä¸Šå‚³å€åŸŸ -->
            <div class="form-group">
                <label>ğŸ“¸ Select Image(s) - Multi-select supported (Max 50)</label>
                <div class="file-upload-area" id="uploadArea">
                    <div class="upload-icon">ğŸ“</div>
                    <div class="upload-text">
                        <strong>Click to select image(s)</strong> or drag and drop them here<br>
                        <small>Supports JPG, PNG, GIF formats â€¢ Multi-select enabled â€¢ Max 50 images</small>
                    </div>
                    <input type="file" id="imageFile" accept="image/*" multiple>
                    <div id="imagePreview"></div>
                </div>
            </div>

            <!-- éŸ³é »ä¸Šå‚³ï¼ˆåƒ… audio-to-video ç«¯é»éœ€è¦ï¼‰ -->
            <div class="form-group" id="audioGroup" style="display: none;">
                <label>ğŸµ Select Audio (Required for audio-to-video)</label>
                <div class="file-upload-area" id="audioUploadArea">
                    <div class="upload-icon">ğŸµ</div>
                    <div class="upload-text">
                        <strong>Click to select audio</strong> or drag and drop here<br>
                        <small>Supports MP3, WAV, M4A, etc.</small>
                    </div>
                    <input type="file" id="audioFile" accept="audio/*">
                    <div id="audioFileName" style="margin-top: 8px; font-size: 12px; color: #666;"></div>
                </div>
            </div>

            <!-- è™•ç†è¨­ç½®ï¼ˆå·²éš±è—ï¼‰ -->

            <!-- æç¤ºè©è¼¸å…¥ -->
            <div class="form-group">
                <label for="promptText">âœ¨ Prompt (Optional)</label>
                <textarea id="promptText" class="form-control" placeholder="Describe the video effect you want to generate...&#10;e.g., a beautiful sunset scene with gentle waves"></textarea>
            </div>

            <!-- åœ–ç‰‡ç®¡ç†æŒ‰éˆ• -->
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                <button class="btn" style="background: #6c757d; width: auto; flex: none; padding: 12px 20px;" onclick="clearAllImages()">
                    ğŸ—‘ï¸ Clear All Images
                </button>
                <button class="btn" style="background: #17a2b8; width: auto; flex: none; padding: 12px 20px;" onclick="downloadLogs()">
                    ğŸ“¥ Download Logs
                </button>
                <div style="flex: 1;"></div>
                <div id="imageCount" style="align-self: center; color: #666; font-size: 14px;"></div>
            </div>

            <!-- ç”ŸæˆæŒ‰éˆ• -->
            <button class="btn" id="generateBtn" onclick="onStartButtonClick()">
                ğŸš€ Start Generating Video(s)
            </button>

            <!-- è™•ç†é€²åº¦æ¢ -->
            <div id="batchProgressArea" style="display: none; margin: 20px 0; padding: 20px; background: #f8f9fa; border-radius: 10px;">
                <h4 style="margin-bottom: 15px;">ğŸ“Š Processing Progress</h4>
                <div style="margin-bottom: 10px;">
                    <span id="batchProgressText">Processing...</span>
                </div>
                <div class="progress-bar" style="margin-bottom: 10px;">
                    <div class="progress-fill" id="batchProgressFill"></div>
                </div>
                <div style="font-size: 12px; color: #666;">
                    <span id="batchProgressDetail">Starting processing...</span>
                </div>
            </div>

            <!-- æ‰¹é‡ä¸‹è¼‰æŒ‰éˆ• -->
            <div style="margin: 20px 0; text-align: center;">
                <button class="btn" id="downloadAllBtn" onclick="downloadAllVideos()" style="background: #28a745; display: none;">
                    ğŸ“¦ Download All Completed Videos
                </button>
                <div style="margin-top: 10px; font-size: 12px; color: #666;">
                    ğŸ’¡ è¦–é »å°‡ä»¥å°æ‡‰åœ–ç‰‡åç¨±å‘½åã€‚æ”¯æ´çš„ç€è¦½å™¨å¯é¸æ“‡å­˜å„²ä½ç½®
                </div>
            </div>

            <!-- å¤šä»»å‹™ç®¡ç†å€åŸŸ -->
            <div class="tasks-area" id="tasksArea" style="display: none;">
                <h3>ğŸ“Š Task Management</h3>
                <div class="task-summary" id="taskSummary" style="margin-bottom: 20px; padding: 15px; background: #f0f9ff; border-radius: 8px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span>ğŸ“ˆ Task Stats: <span id="totalTasks">0</span> total tasks</span>
                        <span>â±ï¸ Average Time: <span id="averageTime">-</span></span>
                    </div>
                </div>
                <div id="tasksList"></div>
            </div>

            <!-- Benchmark çµæœå°æ¯”å€åŸŸ -->
            <div id="benchmarkResults" class="section" style="display:none; margin-top:16px; padding:12px; background:#f8f9ff; border:1px solid #e1e5e9; border-radius:8px;">
                <h3 style="margin-bottom:8px;">ğŸ§ª Benchmark Results (A vs B)</h3>
                <div id="benchmarkPairs" style="display:flex; flex-direction:column; gap:16px;"></div>
            </div>

            <!-- éŒ¯èª¤è¨Šæ¯å€åŸŸ -->
            <div id="errorArea"></div>
        </div>
    </div>

    <script>
        // å¤šä»»å‹™ç®¡ç†
        let tasks = new Map(); // ä½¿ç”¨ Map å­˜å„²ä»»å‹™ä¿¡æ¯
        let imageQueue = []; // ç­‰å¾…è™•ç†çš„åœ–ç‰‡éšŠåˆ—
        let processingInterval = null; // éšŠåˆ—ç®¡ç†å™¨çš„è¨ˆæ™‚å™¨
        let globalTaskCounter = 0;
        let statusCheckInterval = null;
        let pendingSubmissions = 0; // å°šæœªæ­£å¼åŠ å…¥ tasks Map çš„æäº¤æ•¸ï¼Œç”¨æ–¼æ›´ç²¾ç¢ºçš„ä½µç™¼æ§åˆ¶
        
        // API æä¾›å•†å’Œç‰ˆæœ¬é…ç½®
        const API_PROVIDERS = {
            'original': {
                name: 'Original',
                description: 'Original Parrot API æœå‹™å™¨',
                baseUrl: 'https://qazwsxedcrf3g5h.pika.art',
                apiKey: 'pk_GW7ITxUVnC271AoJaasgdATrmzjl4OnQKTmD2j6tLZM',
                versions: {
                    'v0': {
                        endpoints: {
                            'image-to-video': {
                                path: '/generate/v0/image-to-video',
                                description: 'åœ–ç‰‡è½‰è¦–é » - v0 ç‰ˆæœ¬ (é»˜èª)',
                                name: 'Original v0 (é»˜èª)'
                            },
                            'image-to-video-new': {
                                path: '/generate/v0/image-to-video-new',
                                description: 'åœ–ç‰‡è½‰è¦–é » - v0 ç‰ˆæœ¬ (æ–°ç«¯é»)',
                                name: 'Original v0 (æ–°ç«¯é»)'
                            },
                            'image-to-video-inner': {
                                path: '/generate/v0/image-to-video-inner',
                                description: 'åœ–ç‰‡è½‰è¦–é » - v0 ç‰ˆæœ¬ (å…§éƒ¨ç«¯é»)',
                                name: 'Original v0 (å…§éƒ¨ç«¯é»)'
                            },
                            'image-to-video-nmd': {
                                path: '/generate/v0/image-to-video-nmd',
                                description: 'åœ–ç‰‡è½‰è¦–é » - v0 ç‰ˆæœ¬ (NMD ç«¯é»)',
                                name: 'Original v0 (nmd)'
                            },
                            'audio-to-video': {
                                path: '/generate/v0/audio-to-video',
                                description: 'åœ–ç‰‡+éŸ³é »åˆæˆè¦–é » - v0 ç‰ˆæœ¬',
                                name: 'Original v0 (audio-to-video)'
                            }
                        },
                        defaultEndpoint: 'image-to-video',
                        description: 'åœ–ç‰‡è½‰è¦–é » - v0 ç‰ˆæœ¬',
                        name: 'Original v0'
                    }
                }
            },
            'staging': {
                name: 'Staging',
                description: 'Parrot Labs API æœå‹™å™¨',
                baseUrl: 'https://089e99349ace.pikalabs.app',
                apiKey: 'pk_fnOLPQFrhk96QscYG9hIUSw-Jn5ygl_ehSUWa9PvwZM',
                versions: {
                    'v2.2': {
                        endpoint: '/generate/2.2/i2v',
                        description: 'åœ–ç‰‡è½‰è¦–é » - v2.2 ç‰ˆæœ¬',
                        name: 'Staging v2.2'
                    }
                }
            },
            'minimax': {
                name: 'Minimax text to audio',
                description: 'MiniMax æ–‡æœ¬è½‰èªéŸ³',
                baseUrl: '',
                versions: {
                    'v1': {
                        endpoint: '/minimax/t2a',
                        description: 'æ–‡æœ¬è½‰èªéŸ³ - v1',
                        name: 'Text to Audio'
                    }
                }
            }
        };

        // ç²å–ç•¶å‰APIé…ç½® - ç¾åœ¨æ”¯æŒå‹•æ…‹é¸æ“‡
        function getCurrentAPIConfig() {
            const provider = document.getElementById('apiProvider')?.value || 'staging';
            const apiVersion = document.getElementById('apiVersion')?.value || 'v2.2';
            const endpointType = document.getElementById('endpointType')?.value;
            const versionConfig = API_PROVIDERS[provider]?.versions[apiVersion];
            
            let endpoint = '/generate/2.2/i2v'; // é»˜èª
            
            if (versionConfig) {
                if (versionConfig.endpoints) {
                    // Original API v0 æ”¯æŒå¤šå€‹ç«¯é»
                    const selectedEndpoint = endpointType && versionConfig.endpoints[endpointType] 
                        ? versionConfig.endpoints[endpointType] 
                        : versionConfig.endpoints[versionConfig.defaultEndpoint];
                    endpoint = selectedEndpoint.path;
                } else {
                    // å–®ä¸€ç«¯é»ï¼ˆStaging æˆ– Minimaxï¼‰
                    endpoint = versionConfig.endpoint;
                }
            }
            
            return {
                provider: provider,
                version: apiVersion,
                endpoint: endpoint,
                endpointType: endpointType
            };
        }

        // æ›´æ–°æä¾›å•†ç‰ˆæœ¬é¸é …
        function updateProviderVersions() {
            const providerSelect = document.getElementById('apiProvider');
            const versionSelect = document.getElementById('apiVersion');
            const endpointTypeGroup = document.getElementById('endpointTypeGroup');
            
            if (!providerSelect || !versionSelect) return;
            
            const selectedProvider = providerSelect.value;
            const providerConfig = API_PROVIDERS[selectedProvider];
            
            // æ¸…ç©ºç‰ˆæœ¬é¸é …
            versionSelect.innerHTML = '';
            
            // æ·»åŠ ç‰ˆæœ¬é¸é …
            if (providerConfig && providerConfig.versions) {
                Object.keys(providerConfig.versions).forEach(versionKey => {
                    const version = providerConfig.versions[versionKey];
                    const option = document.createElement('option');
                    option.value = versionKey;
                    option.textContent = version.name || versionKey;
                    versionSelect.appendChild(option);
                });
            }
            
            // æª¢æŸ¥æ˜¯å¦éœ€è¦é¡¯ç¤ºç«¯é»é¡å‹é¸æ“‡å™¨
            if (endpointTypeGroup) {
                const selectedVersion = versionSelect.value;
                const versionConfig = providerConfig?.versions[selectedVersion];
                
                if (versionConfig && versionConfig.endpoints) {
                    // Original API v0 æ”¯æŒå¤šå€‹ç«¯é»
                    endpointTypeGroup.style.display = 'block';
                } else {
                    // Staging API æˆ–å…¶ä»–ç‰ˆæœ¬ä½¿ç”¨å–®ä¸€ç«¯é»
                    endpointTypeGroup.style.display = 'none';
                }
            }
            
            // åˆ‡æ› UIï¼šMinimax ä¸‹éš±è—åœ–ç‰‡/ç”Ÿæˆè¦–é »ç›¸é—œï¼Œé¡¯ç¤º T2A å€å¡Š
            const isMinimax = selectedProvider === 'minimax';
            document.getElementById('uploadArea')?.closest('.form-group')?.classList.toggle('hidden', isMinimax);
            document.getElementById('audioGroup')?.classList.toggle('hidden', isMinimax);
            document.getElementById('promptText')?.closest('.form-group')?.classList.toggle('hidden', isMinimax);
            document.getElementById('generateBtn')?.classList.toggle('hidden', isMinimax);
            // é¡¯ç¤º/éš±è— minimax å€å¡Š
            document.getElementById('minimaxSection')?.classList.toggle('hidden', !isMinimax);

            // è‡ªå‹•å¡«å…¥ Minimax æ†‘è­‰ï¼ˆåƒ…ç•¶ç•™ç©ºæ™‚ï¼‰
            if (isMinimax) {
                try {
                    fetch('/minimax/env?full=1').then(r => r.json()).then(env => {
                        const gidEl = document.getElementById('minimaxGroupId');
                        const keyEl = document.getElementById('minimaxApiKey');
                        if (gidEl && !gidEl.value && env.group_id) gidEl.value = env.group_id;
                        if (keyEl && !keyEl.value && env.api_key) keyEl.value = env.api_key;
                    }).catch(() => {});
                } catch {}
            }

            // åŒæ­¥ç•¶å‰ provider çš„é»˜èª API Key åˆ°è¼¸å…¥æ¡†ï¼ˆé¿å…ä½¿ç”¨éŒ¯èª¤ provider çš„ keyï¼‰
            try {
                const keyInput = document.getElementById('apiKey');
                if (keyInput) {
                    keyInput.value = providerConfig?.apiKey || '';
                }
            } catch {}

            updateAPIDescription();
        }

        // Benchmark: æ›´æ–° B è·¯çš„æä¾›å•†/ç‰ˆæœ¬/ç«¯é»é¡¯ç¤º
        function updateProviderVersionsB() {
            const providerSelect = document.getElementById('apiProviderB');
            const versionSelect = document.getElementById('apiVersionB');
            const endpointTypeGroup = document.getElementById('endpointTypeGroupB');
            if (!providerSelect || !versionSelect) return;
            const selectedProvider = providerSelect.value;
            const providerConfig = API_PROVIDERS[selectedProvider];
            versionSelect.innerHTML = '';
            if (providerConfig && providerConfig.versions) {
                Object.keys(providerConfig.versions).forEach(versionKey => {
                    const version = providerConfig.versions[versionKey];
                    const option = document.createElement('option');
                    option.value = versionKey;
                    option.textContent = version.name || versionKey;
                    versionSelect.appendChild(option);
                });
            }
            if (endpointTypeGroup) {
                const selectedVersion = versionSelect.value;
                const versionConfig = providerConfig?.versions[selectedVersion];
                if (versionConfig && versionConfig.endpoints) {
                    endpointTypeGroup.style.display = 'block';
                } else {
                    endpointTypeGroup.style.display = 'none';
                }
            }
            // è‡ªå‹•å¡«å…¥ B çš„é»˜èª key
            try {
                const keyInput = document.getElementById('apiKeyB');
                if (keyInput) keyInput.value = providerConfig?.apiKey || '';
            } catch {}
            updateAPIDescriptionB();
        }

        function getCurrentAPIConfigB() {
            const provider = document.getElementById('apiProviderB')?.value || 'staging';
            const apiVersion = document.getElementById('apiVersionB')?.value || 'v2.2';
            const endpointType = document.getElementById('endpointTypeB')?.value;
            const versionConfig = API_PROVIDERS[provider]?.versions[apiVersion];
            let endpoint = '/generate/2.2/i2v';
            if (versionConfig) {
                if (versionConfig.endpoints) {
                    const selectedEndpoint = endpointType && versionConfig.endpoints[endpointType]
                        ? versionConfig.endpoints[endpointType]
                        : versionConfig.endpoints[versionConfig.defaultEndpoint];
                    endpoint = selectedEndpoint.path;
                } else {
                    endpoint = versionConfig.endpoint;
                }
            }
            return { provider, version: apiVersion, endpoint, endpointType };
        }

        function updateAPIDescriptionB() {
            const provider = document.getElementById('apiProviderB')?.value;
            const version = document.getElementById('apiVersionB')?.value;
            const endpointType = document.getElementById('endpointTypeB')?.value;
            const descElement = document.getElementById('apiDescriptionB');
            if (!descElement || !provider || !version) return;
            const providerConfig = API_PROVIDERS[provider];
            const versionConfig = providerConfig?.versions[version];
            if (providerConfig && versionConfig) {
                let description = `${providerConfig.description} - ${versionConfig.description}`;
                if (versionConfig.endpoints && endpointType) {
                    const endpointConfig = versionConfig.endpoints[endpointType];
                    if (endpointConfig) description += ` (${endpointConfig.description})`;
                }
                descElement.textContent = description;
            }
        }

        // æ ¹æ“šç«¯é»é¡å‹é¡¯ç¤º/éš±è—éŸ³é »ä¸Šå‚³
        function refreshAudioVisibility() {
            const endpointType = document.getElementById('endpointType')?.value;
            const audioGroup = document.getElementById('audioGroup');
            if (!audioGroup) return;
            if (endpointType === 'audio-to-video') {
                audioGroup.style.display = 'block';
            } else {
                audioGroup.style.display = 'none';
            }
        }
        document.getElementById('endpointType')?.addEventListener('change', refreshAudioVisibility);
        // åˆæ¬¡æ¸²æŸ“æ™‚ä¹Ÿåˆ·æ–°ä¸€æ¬¡
        window.addEventListener('load', refreshAudioVisibility);

        // æ›´æ–°APIæè¿°
        function updateAPIDescription() {
            const provider = document.getElementById('apiProvider')?.value;
            const version = document.getElementById('apiVersion')?.value;
            const endpointType = document.getElementById('endpointType')?.value;
            const descElement = document.getElementById('apiDescription');
            
            if (!descElement || !provider || !version) return;
            
            const providerConfig = API_PROVIDERS[provider];
            const versionConfig = providerConfig?.versions[version];
            
            if (providerConfig && versionConfig) {
                let description = `${providerConfig.description} - ${versionConfig.description}`;
                
                // å¦‚æœæ˜¯ Original API v0ï¼Œæ·»åŠ ç«¯é»é¡å‹ä¿¡æ¯
                if (versionConfig.endpoints && endpointType) {
                    const endpointConfig = versionConfig.endpoints[endpointType];
                    if (endpointConfig) {
                        description += ` (${endpointConfig.description})`;
                    }
                }
                
                descElement.textContent = description;
            }
        }
        
        // ä»»å‹™æ•¸æ“šçµæ§‹
        function createTask(videoId, promptText, imageName) {
            return {
                id: videoId,
                taskNumber: ++globalTaskCounter,
                status: 'waiting',
                progress: 0,
                promptText: promptText || '',
                imageName: imageName || '',
                startTime: null,
                endTime: null,
                duration: 0,
                // æ–°å¢è¨ˆæ™‚å­—æ®µ
                submittedAt: null,
                startedAt: null,
                finishedAt: null,
                waitDurationSec: null,
                genDurationSec: null,
                url: null,
                created: new Date(),
                retryCount: 0,
                benchmarkLabel: window.benchmarkLabel || ''
            };
        }

        // æ–‡ä»¶ä¸Šå‚³è™•ç†
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('imageFile');
        const imagePreview = document.getElementById('imagePreview');

            // é»æ“Šä¸Šå‚³å€åŸŸï¼ˆè‹¥é¸æ“‡ audio-to-videoï¼Œé»æ“ŠéŸ³é »å€åŸŸä¹Ÿèƒ½è§¸ç™¼ï¼‰
            uploadArea.addEventListener('click', () => {
                fileInput.click();
            });

            // éŸ³é »å€åŸŸé»æ“Š/æ‹–æ‹½
            const audioGroup = document.getElementById('audioGroup');
            const audioInput = document.getElementById('audioFile');
            const audioUploadArea = document.getElementById('audioUploadArea');
            const audioFileName = document.getElementById('audioFileName');
            
            audioUploadArea?.addEventListener('click', () => audioInput?.click());
            audioUploadArea?.addEventListener('dragover', (e) => {
                e.preventDefault();
                audioUploadArea.classList.add('drag-over');
            });
            audioUploadArea?.addEventListener('dragleave', () => audioUploadArea.classList.remove('drag-over'));
            audioUploadArea?.addEventListener('drop', (e) => {
                e.preventDefault();
                audioUploadArea.classList.remove('drag-over');
                if (e.dataTransfer?.files?.length) {
                    const f = e.dataTransfer.files[0];
                    audioInput.files = e.dataTransfer.files;
                    audioUploadArea.classList.add('has-file');
                    if (audioFileName) audioFileName.textContent = `Selected: ${f.name}`;
                }
            });
            audioInput?.addEventListener('change', () => {
                const f = audioInput.files?.[0];
                if (f) {
                    audioUploadArea?.classList.add('has-file');
                    if (audioFileName) audioFileName.textContent = `Selected: ${f.name}`;
                } else {
                    audioUploadArea?.classList.remove('has-file');
                    if (audioFileName) audioFileName.textContent = '';
                }
            });

        // æ‹–æ‹½ä¸Šå‚³
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('drag-over');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('drag-over');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('drag-over');
            const files = Array.from(e.dataTransfer.files);
            if (files.length > 0) {
                handleMultipleFileSelect(files);
            }
        });

        // æ–‡ä»¶é¸æ“‡è™•ç†
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleMultipleFileSelect(Array.from(e.target.files));
            }
        });

        let selectedImages = []; // å…¨å±€è®Šé‡å­˜å„²é¸ä¸­çš„åœ–ç‰‡

        async function handleMultipleFileSelect(files) {
            // éæ¿¾å‡ºåœ–ç‰‡æ–‡ä»¶
            const imageFiles = files.filter(file => file.type.startsWith('image/'));
            
            if (imageFiles.length === 0) {
                showError('Please select image files');
                return;
            }

            // æª¢æŸ¥æ˜¯å¦æœƒè¶…é50å¼µé™åˆ¶
            const totalAfterAdd = selectedImages.length + imageFiles.length;
            if (totalAfterAdd > 50) {
                const canAdd = 50 - selectedImages.length;
                if (canAdd <= 0) {
                    showError('Maximum 50 images allowed. Please remove some images first.');
                    return;
                } else {
                    showError(`Only ${canAdd} more image(s) can be added (max 50 total). Only first ${canAdd} will be added.`);
                    imageFiles.splice(canAdd); // åªä¿ç•™å‰canAddå€‹æ–‡ä»¶
                }
            }

            // é˜²æ­¢é‡è¤‡åœ–ç‰‡ï¼ˆæ ¹æ“šæ–‡ä»¶åå’Œå¤§å°ï¼‰
            const newUniqueImages = [];
            imageFiles.forEach(newFile => {
                const isDuplicate = selectedImages.some(existingFile => 
                    existingFile.name === newFile.name && existingFile.size === newFile.size
                );
                if (!isDuplicate) {
                    newUniqueImages.push(newFile);
                }
            });

            // è‡ªå‹•å°‡ AVIF è½‰ç‚º JPG
            const finalFiles = [];
            for (const f of newUniqueImages) {
                if (isAvifFile(f)) {
                    try {
                        const converted = await convertAvifToJpeg(f);
                        finalFiles.push(converted);
                    } catch (e) {
                        // è½‰æ›å¤±æ•—å‰‡å›é€€ä½¿ç”¨åŸæ–‡ä»¶
                        console.warn('AVIF to JPEG conversion failed, using original file:', e);
                        finalFiles.push(f);
                    }
                } else {
                    finalFiles.push(f);
                }
            }

            if (newUniqueImages.length === 0) {
                showError('All selected images are already added');
                return;
            }

            if (newUniqueImages.length < imageFiles.length) {
                const duplicateCount = imageFiles.length - newUniqueImages.length;
                showSuccess(`${newUniqueImages.length} image(s) added. ${duplicateCount} duplicate(s) skipped.`);
            }

            // å°‡æ–°çš„å”¯ä¸€åœ–ç‰‡ï¼ˆå«è½‰æ›å¾Œ JPGï¼‰æ·»åŠ åˆ°é¸ä¸­åˆ—è¡¨
            selectedImages = [...selectedImages, ...finalFiles];
            
            // æ›´æ–° file input çš„ files å±¬æ€§
            updateFileInput();
            
            // é¡¯ç¤ºé è¦½
            displayImagePreviews();
            
            // æ›´æ–°ä¸Šå‚³å€åŸŸç‹€æ…‹
            uploadArea.classList.add('has-file');
            updateUploadAreaText();
        }

        function isAvifFile(file) {
            return file && (file.type === 'image/avif' || /\.avif$/i.test(file.name || ''));
        }

        async function convertAvifToJpeg(file) {
            const url = URL.createObjectURL(file);
            try {
                // å„ªå…ˆä½¿ç”¨ createImageBitmap
                try {
                    const bitmap = await createImageBitmap(file);
                    const canvas = document.createElement('canvas');
                    canvas.width = bitmap.width;
                    canvas.height = bitmap.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(bitmap, 0, 0);
                    const jpegBlob = await new Promise((resolve, reject) => {
                        canvas.toBlob(b => b ? resolve(b) : reject(new Error('toBlob failed')), 'image/jpeg', 0.92);
                    });
                    const newName = (file.name || 'image').replace(/\.avif$/i, '.jpg');
                    return new File([jpegBlob], newName, { type: 'image/jpeg' });
                } catch (_) {
                    // å›é€€ä½¿ç”¨ HTMLImageElement
                    const image = await new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => resolve(img);
                        img.onerror = reject;
                        img.src = url;
                    });
                    const canvas = document.createElement('canvas');
                    canvas.width = image.width;
                    canvas.height = image.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(image, 0, 0);
                    const jpegBlob = await new Promise((resolve, reject) => {
                        canvas.toBlob(b => b ? resolve(b) : reject(new Error('toBlob failed')), 'image/jpeg', 0.92);
                    });
                    const newName = (file.name || 'image').replace(/\.avif$/i, '.jpg');
                    return new File([jpegBlob], newName, { type: 'image/jpeg' });
                }
            } finally {
                URL.revokeObjectURL(url);
            }
        }

        function updateFileInput() {
            // å‰µå»ºæ–°çš„ DataTransfer å°è±¡ä¾†æ›´æ–° file input
            const dt = new DataTransfer();
            selectedImages.forEach(file => {
                dt.items.add(file);
            });
            fileInput.files = dt.files;
        }

        function displayImagePreviews() {
            if (selectedImages.length === 0) {
                imagePreview.innerHTML = '';
                uploadArea.classList.remove('has-file');
                updateUploadAreaText();
                return;
            }

            let previewHTML = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px; margin-top: 15px;">';
            
            selectedImages.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const previewItem = document.createElement('div');
                    previewItem.style.cssText = 'position: relative; text-align: center; background: #f8f9fa; border-radius: 8px; padding: 8px;';
                    previewItem.innerHTML = `
                        <img src="${e.target.result}" style="width: 100%; height: 80px; object-fit: cover; border-radius: 6px;" alt="Preview ${index + 1}">
                        <div style="font-size: 11px; color: #666; margin-top: 4px; word-break: break-all;">${file.name}</div>
                        <div style="font-size: 10px; color: #999;">${(file.size / 1024 / 1024).toFixed(2)} MB</div>
                        <button onclick="removeImage(${index})" style="position: absolute; top: 2px; right: 2px; background: #ff4757; color: white; border: none; border-radius: 50%; width: 20px; height: 20px; font-size: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center;">Ã—</button>
                    `;
                    
                    // æ›´æ–°é è¦½å®¹å™¨
                    const container = document.getElementById('imagePreview');
                    if (!container.querySelector('.preview-grid')) {
                        container.innerHTML = '<div class="preview-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px; margin-top: 15px;"></div>';
                    }
                    const grid = container.querySelector('.preview-grid');
                    grid.appendChild(previewItem);
                };
                reader.readAsDataURL(file);
            });
        }

        function removeImage(index) {
            selectedImages.splice(index, 1);
            updateFileInput();
            
            // é‡æ–°é¡¯ç¤ºæ‰€æœ‰é è¦½
            imagePreview.innerHTML = '';
            if (selectedImages.length > 0) {
                displayImagePreviews();
            } else {
                uploadArea.classList.remove('has-file');
            }
            updateUploadAreaText();
        }

        function updateUploadAreaText() {
            const uploadText = document.querySelector('.upload-text');
            const imageCountDiv = document.getElementById('imageCount');
            
            if (selectedImages.length === 0) {
                uploadText.innerHTML = '<strong>Click to select image(s)</strong> or drag and drop them here<br><small>Supports JPG, PNG, GIF formats â€¢ Multi-select enabled â€¢ Max 50 images</small>';
                imageCountDiv.textContent = '';
            } else {
                const remaining = 50 - selectedImages.length;
                if (remaining > 0) {
                    uploadText.innerHTML = `<strong>${selectedImages.length}/50 image(s) selected</strong><br><small>Click to add ${remaining} more images or drag and drop</small>`;
                    imageCountDiv.textContent = `${selectedImages.length}/50 images selected`;
                } else {
                    uploadText.innerHTML = `<strong>50/50 images selected (Maximum reached)</strong><br><small>Remove some images to add different ones</small>`;
                    imageCountDiv.textContent = `50/50 images selected (Max reached)`;
                }
            }
        }

        function clearAllImages() {
            if (selectedImages.length === 0) {
                showError('No images to clear');
                return;
            }
            
            if (confirm(`Are you sure you want to remove all ${selectedImages.length} selected image(s)?`)) {
                selectedImages = [];
                updateFileInput();
                imagePreview.innerHTML = '';
                uploadArea.classList.remove('has-file');
                updateUploadAreaText();
                showSuccess('All images cleared');
            }
        }

        // å–å¾—ä½µç™¼ä¸Šé™ï¼ˆè‹¥UIå·²ç§»é™¤ï¼Œæä¾›å®‰å…¨é»˜èªå€¼ï¼‰
        function getConcurrencyLimit() {
            const el = document.getElementById('concurrencyLimit');
            const n = parseInt(el?.value || '10', 10);
            if (Number.isNaN(n) || n <= 0) return 10;
            return Math.min(n, 20);
        }

        // ç”Ÿæˆè¦–é » - ä½¿ç”¨æ™ºèƒ½éšŠåˆ—å’Œä½µç™¼æ§åˆ¶
        async function generateVideo() {
            const apiKey = document.getElementById('apiKey').value;
            const concurrencyLimit = getConcurrencyLimit();
            const imageFiles = Array.from(document.getElementById('imageFile').files);

            // é©—è­‰è¼¸å…¥
            if (!apiKey) {
                showError('Please enter your API Key');
                return;
            }
            if (imageFiles.length === 0) {
                showError('Please select at least one image file');
                return;
            }

            // åˆå§‹åŒ–
            clearMessages();
            setButtonLoading(true);
            showBatchProgress();
            
            // å°‡æ‰€æœ‰åœ–ç‰‡æ”¾å…¥éšŠåˆ—
            imageQueue = [...imageFiles];
            const totalTasks = imageQueue.length;
            
            console.log('=== New Concurrent Task Submission ===');
            console.log('Selected images:', totalTasks);
            console.log('Concurrency Limit:', concurrencyLimit);
            console.log('====================================');
            
            showSuccess(`ğŸš€ Queued ${totalTasks} image(s) for generation...`);
            
            // å•Ÿå‹•éšŠåˆ—ç®¡ç†å™¨
            if (processingInterval) clearInterval(processingInterval);
            processingInterval = setInterval(() => queueManager(concurrencyLimit, totalTasks), 2000); // æ¯2ç§’æª¢æŸ¥ä¸€æ¬¡
            
            // ç«‹å³è§¸ç™¼ä¸€æ¬¡ä»¥å¿«é€Ÿå•Ÿå‹•
            queueManager(concurrencyLimit, totalTasks);

            // å•Ÿå‹•ç‹€æ…‹è¼ªè©¢
            if (!statusCheckInterval) {
                startStatusCheck();
            }
        }
        
        // è¼”åŠ©å‡½æ•¸ï¼šæ›´æ–°ä»»å‹™å¡ç‰‡åŠå…¶æ‰€æœ‰å­å…ƒç´ çš„ID
        function updateCardIds(oldId, newId) {
            const card = document.getElementById(`task-${oldId}`);
            if (!card) return;

            // é¸æ“‡æ‰€æœ‰å¸¶æœ‰èˆŠIDçš„å…ƒç´ 
            const elementsToUpdate = card.querySelectorAll(`[id$="-${oldId}"]`);
            
            elementsToUpdate.forEach(el => {
                el.id = el.id.replace(oldId, newId);
            });
            
            // æ›´æ–°ä¸»å¡ç‰‡çš„ID
            card.id = `task-${newId}`;
            
            // ç‰¹åˆ¥è™•ç†onclickäº‹ä»¶
            const downloadLink = card.querySelector(`a[onclick*="'${oldId}'"]`);
            if (downloadLink) {
                downloadLink.setAttribute('onclick', `downloadTaskVideo('${newId}')`);
            }
        }

        // éšŠåˆ—ç®¡ç†å™¨
        function queueManager(_limit, totalTasks) {
            // æ¯æ¬¡å‹•æ…‹å–å¾—ä½µç™¼ä¸Šé™ï¼ˆUIå¯èƒ½å·²éš±è—ï¼‰
            const concurrencyLimit = getConcurrencyLimit();
            const activeTasks = Array.from(tasks.values()).filter(t => !['completed', 'failed', 'finished', 'error'].includes(t.status)).length;
            const effectiveActive = activeTasks + pendingSubmissions; // æŠŠå°šæœªåŠ å…¥ Map çš„æäº¤ä¹Ÿç®—é€²å»
            const canSubmitCount = concurrencyLimit - effectiveActive;
            
            console.log(`[Queue Manager] Active (in Map): ${activeTasks}, Pending Submissions: ${pendingSubmissions}, Queue: ${imageQueue.length}, Can Submit: ${canSubmitCount}`);
            
            if (canSubmitCount > 0 && imageQueue.length > 0) {
                const itemsToSubmit = imageQueue.splice(0, canSubmitCount);
                console.log(`[Queue Manager] Submitting ${itemsToSubmit.length} new tasks.`);
                
                showSuccess(`Submitting ${itemsToSubmit.length} new tasks...`);

                // å¸¶æœ‰äº¤éŒ¯å»¶é²åœ°æäº¤ä»»å‹™ï¼Œä»¥é¿å…è«‹æ±‚é¢¨æš´
                (async () => {
                    for (const imageFile of itemsToSubmit) {
                        pendingSubmissions++; // æ¨™è¨˜ç‚ºæ­£åœ¨æäº¤
                        submitTask(imageFile).finally(() => {
                            pendingSubmissions--; // æäº¤çµæŸï¼ˆæˆåŠŸæˆ–å¤±æ•—ï¼‰
                        });
                        await new Promise(resolve => setTimeout(resolve, 500)); // å¢åŠ åˆ°500ms
                    }
                })();
            }
            
            const submittedCount = totalTasks - imageQueue.length;
            const completedCount = submittedCount - activeTasks;
            updateBatchProgress(completedCount, totalTasks, null, null, `Submitted: ${submittedCount}/${totalTasks} | Active: ${effectiveActive}`);

            // å¦‚æœéšŠåˆ—ç‚ºç©ºä¸”æ²’æœ‰æ´»å‹•ä»»å‹™ï¼Œå‰‡åœæ­¢
            if (imageQueue.length === 0 && activeTasks === 0) {
                console.log('[Queue Manager] All tasks completed. Stopping manager.');
                clearInterval(processingInterval);
                processingInterval = null;
                setButtonLoading(false);
                
                const finalCompletedCount = Array.from(tasks.values()).filter(t => ['completed', 'finished'].includes(t.status)).length;
                showSuccess(`ğŸ‰ All ${finalCompletedCount}/${totalTasks} tasks processed!`);
                updateBatchProgress(finalCompletedCount, totalTasks, null, null, `All tasks processed!`);

                setTimeout(() => {
                    hideBatchProgress();
                }, 5000);
            }
        }

        // æäº¤å–®å€‹ä»»å‹™ï¼ŒåŒ…å«é‡è©¦é‚è¼¯
        async function submitTask(imageFile) {
            // è‹¥æœ‰ Benchmark è¦†è“‹ï¼Œä½¿ç”¨è¦†è“‹åƒæ•¸
            const apiKey = (window.benchmarkOverrideApiKey ?? document.getElementById('apiKey').value) || '';
            const apiConfig = window.benchmarkOverrideConfig || getCurrentAPIConfig();
            const promptText = (window.benchmarkOverridePrompt ?? document.getElementById('promptText').value) || '';
            const MAX_RETRIES = 20; // æé«˜é‡è©¦ä¸Šé™
            const RETRY_DELAY = 8000; // 8ç§’é‡è©¦é–“éš”

            let lastError = 'Unknown error';

            // å‰µå»ºä¸€å€‹è‡¨æ™‚ä»»å‹™ç”¨æ–¼UIå±•ç¤º
            const tempId = `submitting-${Date.now()}-${Math.random()}`;
            const task = createTask(tempId, promptText, imageFile.name);
            task.status = 'submitting';
            task.submittedAt = Date.now();
            // å­˜å„²APIé…ç½®ä¿¡æ¯åˆ°ä»»å‹™
            task.apiProvider = apiConfig.provider;
            task.apiVersion = apiConfig.version;
            task.apiEndpointType = apiConfig.endpointType;
            task.apiKey = apiKey;
            tasks.set(tempId, task);
            createTaskCard(task);
            updateTaskCard(task);
            
            // æ›´æ–°APIä¿¡æ¯é¡¯ç¤º
            const apiInfoElement = document.getElementById(`api-info-${tempId}`);
            if (apiInfoElement) {
                const providerConfig = API_PROVIDERS[apiConfig.provider];
                const baseUrl = providerConfig.baseUrl;
                const keyDisplay = apiKey ? `${apiKey.substring(0, 6)}...${apiKey.substring(apiKey.length - 6)}` : 'Server Default';
                const endpointInfo = apiConfig.endpointType ? ` | ğŸ¯ ${apiConfig.endpointType}` : '';
                apiInfoElement.innerHTML = `ğŸ“ ${apiConfig.provider} | ğŸŒ ${baseUrl} | ğŸ”— ${apiConfig.version}${endpointInfo} | ğŸ”‘ ${keyDisplay}`;
            }
            
            showTasksArea();

            // audio-to-video éœ€è¦éŸ³é »æ–‡ä»¶ï¼Œç„¡å‰‡ç›´æ¥å¤±æ•—ä¸¦è¿”å›
            if (apiConfig.endpointType === 'audio-to-video') {
                const audioInputPre = document.getElementById('audioFile');
                const audioFilePre = audioInputPre?.files?.[0];
                if (!audioFilePre) {
                    const errMsg = 'audio-to-video requires an audio file';
                    lastError = errMsg;
                    task.status = 'failed';
                    updateTaskCard(task);
                    showError(errMsg);
                    return;
                }
            }
            
            for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
                task.retryCount = attempt;
                updateTaskCard(task);
                
                try {
                    if (attempt > 0) {
                        console.log(`[Retry] Attempt ${attempt}/${MAX_RETRIES} for ${imageFile.name}...`);
                        await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));
                    }

                    // æº–å‚™ FormData å’Œ headers
                    const formData = new FormData();
                    formData.append('image', imageFile);
                    formData.append('provider', apiConfig.provider);
                    formData.append('version', apiConfig.version);
                    if (apiConfig.endpointType) formData.append('endpoint_type', apiConfig.endpointType);
                    // å¦‚æœé¸æ“‡çš„æ˜¯ audio-to-videoï¼Œé™„å¸¶éŸ³é »æ–‡ä»¶
                    if (apiConfig.endpointType === 'audio-to-video') {
                        const audioInput = document.getElementById('audioFile');
                        const audioFile = audioInput?.files?.[0];
                        if (!audioFile) {
                            showError('audio-to-video requires an audio file');
                            throw new Error('Missing audio file');
                        }
                        formData.append('audio', audioFile);
                    }
                    if (promptText.trim()) formData.append('promptText', promptText.trim());
                    const headers = {};
                    if (apiKey) headers['X-API-KEY'] = apiKey; // å¦‚æœç”¨æˆ·æä¾›äº†API Keyå°±ä½¿ç”¨ï¼Œå¦åˆ™ä½¿ç”¨æœåŠ¡å™¨é»˜è®¤çš„
                    
            // è¨˜éŒ„è©³ç´°çš„APIèª¿ç”¨ä¿¡æ¯
                    const providerConfig = API_PROVIDERS[apiConfig.provider];
                    const baseUrl = providerConfig.baseUrl;
                    const fullUrl = baseUrl + apiConfig.endpoint;
                    
                    console.log('=== Video Generation API Call ===');
                    console.log('ğŸ“ Provider:', apiConfig.provider);
                    console.log('ğŸ”— Version:', apiConfig.version);
                    if (apiConfig.endpointType) console.log('ğŸ¯ Endpoint Type:', apiConfig.endpointType);
                    console.log('ğŸŒ Base URL:', baseUrl);
                    console.log('ğŸ¯ Endpoint:', apiConfig.endpoint);
                    console.log('ğŸ”— Full URL:', fullUrl);
                    console.log('ğŸš€ Proxy Endpoint:', '/api/generate');
                    console.log('ğŸ”‘ API Key:', apiKey ? `${apiKey.substring(0, 8)}...${apiKey.substring(apiKey.length - 8)}` : 'Using default from server');
                    console.log('ğŸ“ Prompt:', promptText.trim() || 'No prompt');
                    console.log('ğŸ“ Image:', imageFile.name, `(${(imageFile.size / 1024).toFixed(2)} KB)`);
                    console.log('ğŸ“‹ Headers:', headers);
                    
                    const response = await fetch('/api/generate', { method: 'POST', headers, body: formData });
                    const result = await response.json().catch(() => ({}));
                    
                    // è¨˜éŒ„éŸ¿æ‡‰ä¿¡æ¯
                    console.log('=== API Response ===');
                    console.log('ğŸ“Š Status:', response.status, response.statusText);
                    console.log('ğŸ“ Result:', result);

                    if (response.ok) {
                        // é¡¯ç¤ºè©³ç´°çš„æˆåŠŸä¿¡æ¯
                    const successDetails = `
âœ… Video Generation Started Successfully!

ğŸ†” Video ID: ${result.video_id}
ğŸ“ Provider: ${apiConfig.provider}${window.benchmarkLabel ? ` (${window.benchmarkLabel})` : ''}
ğŸ”— Version: ${apiConfig.version}
${apiConfig.endpointType ? `ğŸ¯ Endpoint Type: ${apiConfig.endpointType}` : ''}
ğŸŒ Base URL: ${baseUrl}
ğŸ¯ Endpoint: ${apiConfig.endpoint}
ğŸ”— Full URL: ${fullUrl}
ğŸ”‘ API Key: ${apiKey ? `${apiKey.substring(0, 8)}...${apiKey.substring(apiKey.length - 8)}` : 'Server Default'}
ğŸ“ Prompt: ${(window.benchmarkOverridePrompt ?? promptText).trim() || 'No prompt provided'}
ğŸ“ Image: ${imageFile.name} (${(imageFile.size / 1024).toFixed(2)} KB)
ğŸ—ï¸ Worker: ${result.worker || 'Not specified'}
ğŸ“Š Status: ${result.status || 'pending'}
â° Time: ${new Date().toLocaleTimeString()}
                        `;
                        
                        console.log('=== Video Generation Success ===');
                        console.log(successDetails);
                        console.log(`âœ… Task submitted successfully: ${result.video_id} for ${imageFile.name}`);
                        
                        // æäº¤æˆåŠŸï¼Œç”¨çœŸå¯¦IDæ›¿æ›è‡¨æ™‚ID
                        const realId = result.video_id;
                        const oldApiInfo = document.getElementById(`api-info-${task.id}`);
                        const apiInfoContent = oldApiInfo ? oldApiInfo.innerHTML : '';
                        
                        tasks.delete(task.id); // åˆªé™¤è‡¨æ™‚ä»»å‹™
                        
                        updateCardIds(task.id, realId); // æ›´æ–°DOMä¸­æ‰€æœ‰ç›¸é—œID
                        
                        task.id = realId; // æ›´æ–°JSå°è±¡çš„ID
                        task.status = 'waiting'; // é‡ç½®ç‹€æ…‹
                        // å­˜å„²è©³ç´°ä¿¡æ¯åˆ°ä»»å‹™å°è±¡
                        task.submissionDetails = {
                            videoId: result.video_id,
                            provider: apiConfig.provider,
                            baseUrl: baseUrl,
                            endpoint: apiConfig.endpoint,
                            fullUrl: fullUrl,
                            apiKey: apiKey ? `${apiKey.substring(0, 8)}...${apiKey.substring(apiKey.length - 8)}` : 'Server Default',
                            prompt: promptText.trim() || 'No prompt provided',
                            imageInfo: `${imageFile.name} (${(imageFile.size / 1024).toFixed(2)} KB)`,
                            worker: result.worker || 'Not specified',
                            submittedAt: new Date().toLocaleTimeString()
                        };
                        tasks.set(realId, task); // ç”¨çœŸå¯¦IDå­˜å„²
                        
                        updateTaskCard(task); // ç”¨æ–°IDæ›´æ–°ä¸€æ¬¡UI
                        
                        // æ¢å¾©APIä¿¡æ¯é¡¯ç¤ºä¸¦æ·»åŠ è©³ç´°ä¿¡æ¯
                        const newApiInfo = document.getElementById(`api-info-${realId}`);
                        if (newApiInfo) {
                            const enhancedApiInfo = `
ğŸ“ ${apiConfig.provider} | ğŸŒ ${baseUrl} | ğŸ”— ${apiConfig.version} | ğŸ”‘ ${apiKey ? `${apiKey.substring(0, 6)}...${apiKey.substring(apiKey.length - 6)}` : 'Server Default'}
<br><small>ğŸ—ï¸ Worker: ${result.worker || 'Not specified'} | â° ${new Date().toLocaleTimeString()}</small>
                            `;
                            newApiInfo.innerHTML = enhancedApiInfo;
                        }
                        return; // æˆåŠŸï¼Œé€€å‡ºå¾ªç’°
                    }
                    
                    lastError = result.detail || result.message || `HTTP ${response.status}`;
                    // å¢åŠ å°ç¶²çµ¡éŒ¯èª¤çš„åˆ¤æ–·
                    if (response.status === 0 || !response.status) {
                        lastError = "Network Error. Is the proxy server running?";
                    }
                    const isRetryable = response.status === 429 || response.status >= 500;

                    if (isRetryable && attempt < MAX_RETRIES) {
                        console.warn(`[Retry] Will retry for ${imageFile.name}. Error: ${lastError}`);
                        task.status = `retrying (${attempt + 1})`;
                        updateTaskCard(task);
                        continue;
                    } else {
                        // éå¯é‡è©¦éŒ¯èª¤ï¼Œç›´æ¥æ¨™è¨˜å¤±æ•—ä¸¦çµæŸ
                        task.status = 'failed';
                        updateTaskCard(task);
                        showError(lastError);
                        return;
                    }

                } catch (error) {
                    lastError = error.message || 'Request error';
                    // åƒ…é‡å°ç¶²è·¯é¡éŒ¯èª¤é‡è©¦
                    const isNetwork = lastError.toLowerCase().includes('network');
                    if (isNetwork && attempt < MAX_RETRIES) {
                        task.status = `retrying (${attempt + 1})`;
                        updateTaskCard(task);
                        continue;
                    }
                    // éç¶²è·¯éŒ¯èª¤ç›´æ¥å¤±æ•—
                    task.status = 'failed';
                    updateTaskCard(task);
                    showError(lastError);
                    return;
                }
            }

            // æ‰€æœ‰é‡è©¦å¤±æ•—
            console.error(`âŒ Task failed for ${imageFile.name} after ${MAX_RETRIES} retries. Final error: ${lastError}`);
            task.status = 'failed';
            updateTaskCard(task);
        }

        // æª¢æŸ¥è¦–é »ç‹€æ…‹
        async function checkVideoStatus() {
            const apiKey = document.getElementById('apiKey').value;
            const apiConfig = getCurrentAPIConfig();
            const baseUrl = '/';  // ä½¿ç”¨æœ¬åœ°ä»£ç†
            
            if (!apiKey) return;
            
            const activeTasks = Array.from(tasks.values()).filter(task => 
                !['finished', 'completed', 'failed', 'error'].includes(task.status)
            );
            
            if (activeTasks.length === 0) {
                stopStatusCheck();
                return;
            }

            // æª¢æŸ¥æ‰€æœ‰æ´»èºä»»å‹™
            for (const task of activeTasks) {
                try {
                    // æº–å‚™ headersï¼ˆstaging ä½¿ç”¨å¾Œç«¯é…ç½®çš„ API Keyï¼‰
                    const headers = {
                        'Accept': 'application/json'
                    };
                    if (apiKey) {
                        headers['X-API-KEY'] = apiKey;
                    }
                    
                    const response = await fetch(`${baseUrl}videos/${task.id}?provider=${apiConfig.provider}`, {
                        headers: headers
                    });

                    if (response.ok) {
                        const result = await response.json();
                        updateTaskFromAPI(task, result);
                    }
                } catch (error) {
                    console.error(`æª¢æŸ¥ä»»å‹™ ${task.id} ç‹€æ…‹æ™‚å‡ºéŒ¯:`, error);
                }
            }
            
            // æ›´æ–°çµ±è¨ˆ
            updateTasksSummary();
        }

        function updateTaskFromAPI(task, result) {
            console.log(`=== Task #${task.taskNumber} Status Update ===`);
            console.log('Full API Response:', result);
            
            // æ›´æ–°ä»»å‹™æ•¸æ“š
            const prevStatus = task.status;
            task.status = result.status || task.status;
            task.progress = result.progress || task.progress;
            task.url = result.url || task.url;
            
            // è¨ˆæ™‚ï¼šç­‰å¾…æ™‚é–“ï¼ˆsubmitted -> startedï¼‰èˆ‡ç”Ÿæˆæ™‚é–“ï¼ˆstarted -> finishedï¼‰
            if (!task.startedAt && (task.status === 'started' || task.progress > 0)) {
                task.startedAt = Date.now();
                if (task.submittedAt) {
                    task.waitDurationSec = Math.max(0, Math.round((task.startedAt - task.submittedAt) / 1000));
                }
            }
            if (!task.finishedAt && (task.status === 'finished' || task.status === 'completed')) {
                task.finishedAt = Date.now();
                if (task.startedAt) {
                    task.genDurationSec = Math.max(0, Math.round((task.finishedAt - task.startedAt) / 1000));
                }
            }
            
            // èˆŠçš„é€šç”¨è¨ˆæ™‚å…¼å®¹ï¼ˆä¿ç•™ç¾æœ‰UIï¼‰
            if (task.progress > 0 && !task.startTime) {
                task.startTime = Date.now();
                console.log(`â±ï¸ Task #${task.taskNumber} timer started`);
            }
            
            // å¦‚æœä»»å‹™å®Œæˆä¸”é‚„æ²’è¨˜éŒ„çµæŸæ™‚é–“ï¼Œè¨˜éŒ„çµæŸæ™‚é–“
            const isCompleted = ['completed', 'finished', 'done'].includes(task.status);
            if (isCompleted && !task.endTime) {
                task.endTime = Date.now();
                console.log(`ğŸ‰ Task #${task.taskNumber} completed!`);
            }
            
            // æ›´æ–°UI
            updateTaskCard(task);
            
            // æ›´æ–°åˆ° Map ä¸­
            tasks.set(task.id, task);

            // è‹¥ç‚º Benchmarkï¼Œå˜—è©¦åˆä½µåˆ°å·¦å³å°æ¯”
            try { maybeRenderBenchmarkPair(task); } catch {}
        }

        // ä¸‹è¼‰æ—¥èªŒï¼šè¼¸å‡º CSVï¼ŒåŒ…å« id, provider, version, endpointType, prompt, submittedAt, startedAt, finishedAt, waitSec, genSec
        function downloadLogs() {
            const header = [
                'taskNumber','id','provider','version','endpointType','prompt','submittedAt','startedAt','finishedAt','waitSec','genSec','status','url'
            ];
            const rows = [header.join(',')];
            for (const task of tasks.values()) {
                const submittedAt = task.submittedAt ? new Date(task.submittedAt).toLocaleString() : '';
                const startedAt = task.startedAt ? new Date(task.startedAt).toLocaleString() : '';
                const finishedAt = task.finishedAt ? new Date(task.finishedAt).toLocaleString() : '';
                const waitSec = task.waitDurationSec != null ? task.waitDurationSec : (task.submittedAt && task.startedAt ? Math.round((task.startedAt - task.submittedAt)/1000) : '');
                const genSec = task.genDurationSec != null ? task.genDurationSec : (task.startedAt && task.finishedAt ? Math.round((task.finishedAt - task.startedAt)/1000) : '');
                const provider = task.apiProvider || '';
                const version = task.apiVersion || '';
                const endpointType = task.apiEndpointType || '';
                const prompt = (task.promptText || '').replaceAll('\n',' ').replaceAll('"','""');
                const line = [
                    task.taskNumber,
                    `"${task.id}"`,
                    provider,
                    version,
                    endpointType,
                    `"${prompt}"`,
                    `"${submittedAt}"`,
                    `"${startedAt}"`,
                    `"${finishedAt}"`,
                    waitSec,
                    genSec,
                    task.status || '',
                    task.url || ''
                ].join(',');
                rows.push(line);
            }
            const csv = rows.join('\n');
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `parrot_logs_${new Date().toISOString().replace(/[:.]/g,'-')}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // é–‹å§‹ç‹€æ…‹æª¢æŸ¥
        function startStatusCheck() {
            if (statusCheckInterval) {
                clearInterval(statusCheckInterval);
            }
            statusCheckInterval = setInterval(checkVideoStatus, 3000); // æ¯3ç§’æª¢æŸ¥ä¸€æ¬¡
            checkVideoStatus(); // ç«‹å³æª¢æŸ¥ä¸€æ¬¡
        }

        // åœæ­¢ç‹€æ…‹æª¢æŸ¥
        function stopStatusCheck() {
            if (statusCheckInterval) {
                clearInterval(statusCheckInterval);
                statusCheckInterval = null;
                console.log('â¹ï¸ All tasks completed, stopping status check');
            }
        }

        // é¡¯ç¤ºç‹€æ…‹å€åŸŸ
        function showStatusArea() {
            document.getElementById('statusArea').style.display = 'block';
        }

        // è¨­ç½®æŒ‰éˆ•è¼‰å…¥ç‹€æ…‹
        function setButtonLoading(loading) {
            const btn = document.getElementById('generateBtn');
            if (!btn) return;
            // å§‹çµ‚ä¿æŒå¯é»æ“Šï¼Œä¸¦ç¶­æŒå•Ÿå‹•æ–‡æ¡ˆï¼Œå…è¨±æŒçºŒæäº¤
            btn.disabled = false;
            btn.textContent = 'ğŸš€ Start Generating Video(s)';
        }

        // æ‰¹é‡è™•ç†é€²åº¦æ¢ç®¡ç†
        function showBatchProgress() {
            document.getElementById('batchProgressArea').style.display = 'block';
        }

        function hideBatchProgress() {
            document.getElementById('batchProgressArea').style.display = 'none';
        }

        function updateBatchProgress(current, total, batchNumber, totalBatches, detail) {
            const progressPercent = total > 0 ? Math.round((current / total) * 100) : 0;
            const progressText = document.getElementById('batchProgressText');
            const progressFill = document.getElementById('batchProgressFill');
            const progressDetail = document.getElementById('batchProgressDetail');
            
            progressText.textContent = `Progress: ${current}/${total} tasks (${progressPercent}%)`;
            progressFill.style.width = `${progressPercent}%`;
            progressDetail.textContent = detail || 'Processing...';
        }

        // é¡¯ç¤ºéŒ¯èª¤è¨Šæ¯
        function showError(message) {
            const errorArea = document.getElementById('errorArea');
            errorArea.innerHTML = `<div class="error-message">âŒ ${message}</div>`;
        }

        // é¡¯ç¤ºæˆåŠŸè¨Šæ¯
        function showSuccess(message) {
            const errorArea = document.getElementById('errorArea');
            errorArea.innerHTML = `<div class="success-message">âœ… ${message}</div>`;
        }

        // æ¸…é™¤è¨Šæ¯
        function clearMessages() {
            document.getElementById('errorArea').innerHTML = '';
        }

        // ä»»å‹™UIç®¡ç†
        function showTasksArea() {
            document.getElementById('tasksArea').style.display = 'block';
        }

        function createTaskCard(task) {
            const tasksList = document.getElementById('tasksList');
            
            const taskCard = document.createElement('div');
            taskCard.className = 'task-card';
            taskCard.id = `task-${task.id}`;
            
            taskCard.innerHTML = `
                <div class="task-header">
                    <div class="task-title">ğŸ“‹ Task #${task.taskNumber}</div>
                    <div class="task-status processing" id="status-${task.id}">Processing</div>
                </div>
                <div class="task-details">
                    <div class="task-detail-item">
                        <div class="task-detail-label">Video ID</div>
                        <div class="task-detail-value" style="font-size: 11px;">${task.id.substring(0, 12)}...</div>
                    </div>
                    <div class="task-detail-item">
                        <div class="task-detail-label">Progress</div>
                        <div class="task-detail-value" id="progress-${task.id}">0%</div>
                    </div>
                    <div class="task-detail-item">
                        <div class="task-detail-label">Wait</div>
                        <div class="task-detail-value" id="wait-${task.id}">-</div>
                    </div>
                    <div class="task-detail-item">
                        <div class="task-detail-label">Gen</div>
                        <div class="task-detail-value" id="gen-${task.id}">-</div>
                    </div>
                    <div class="task-detail-item">
                        <div class="task-detail-label">â±ï¸ Time</div>
                        <div class="task-detail-value" id="time-${task.id}">Waiting...</div>
                    </div>
                    <div class="task-detail-item">
                        <div class="task-detail-label">ğŸ” Retries</div>
                        <div class="task-detail-value" id="retries-${task.id}">${task.retryCount}</div>
                    </div>
                </div>
                <div style="font-size: 13px; color: #666; margin-bottom: 8px;">
                    ğŸ–¼ï¸ Image: ${task.imageName} | ğŸ’¬ Prompt: ${task.promptText || 'None'}
                </div>
                <div style="font-size: 12px; color: #888; margin-bottom: 10px; padding: 5px; background: #f8f9fa; border-radius: 3px;" id="api-info-${task.id}">
                    ğŸ“ API: Loading... | ğŸ”— Version: Loading... | ğŸ”‘ Key: Loading...
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill-${task.id}"></div>
                </div>
                <div class="task-video" id="video-${task.id}" style="display: none;"></div>
            `;
            
            // æ’å…¥åˆ°æœ€å‰é¢ï¼ˆæœ€æ–°çš„ä»»å‹™åœ¨ä¸Šé¢ï¼‰
            tasksList.insertBefore(taskCard, tasksList.firstChild);
        }

        function updateTaskCard(task) {
            const statusElement = document.getElementById(`status-${task.id}`);
            const progressElement = document.getElementById(`progress-${task.id}`);
            const timeElement = document.getElementById(`time-${task.id}`);
            const waitElement = document.getElementById(`wait-${task.id}`);
            const genElement = document.getElementById(`gen-${task.id}`);
            const progressFillElement = document.getElementById(`progress-fill-${task.id}`);
            const taskCard = document.getElementById(`task-${task.id}`);
            const retriesElement = document.getElementById(`retries-${task.id}`);
            
            if (!statusElement) return;

            // æ›´æ–°é‡è©¦æ¬¡æ•¸
            if(retriesElement) retriesElement.textContent = task.retryCount;
            
            // æ›´æ–°é€²åº¦
            progressElement.textContent = `${task.progress}%`;
            progressFillElement.style.width = `${task.progress}%`;
            
            // æ›´æ–°æ™‚é–“
            if (task.startTime) {
                const elapsed = task.endTime ? 
                    Math.floor((task.endTime - task.startTime) / 1000) :
                    Math.floor((Date.now() - task.startTime) / 1000);
                
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                const timeText = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
                
                timeElement.textContent = task.endTime ? 
                    `âœ… ${timeText}` : 
                    `ğŸ”„ ${timeText}`;
                    
                task.duration = elapsed;
            }

            // æ–°å¢ï¼šé¡¯ç¤ºç­‰å¾…/ç”Ÿæˆæ™‚é–“ï¼ˆå³æ™‚æ›´æ–°ï¼Œåƒè€ƒ time çš„å‹•æ…‹é¡¯ç¤ºé‚è¼¯ï¼‰
            if (waitElement) {
                let waitSec = null;
                if (task.submittedAt) {
                    if (task.startedAt) {
                        // å·²é–‹å§‹ï¼Œå›ºå®šç‚ºæäº¤åˆ°é–‹å§‹çš„è€—æ™‚
                        const fixed = task.waitDurationSec ?? Math.round((task.startedAt - task.submittedAt) / 1000);
                        waitSec = Math.max(0, fixed);
                    } else {
                        // æœªé–‹å§‹ï¼Œå‹•æ…‹ç´¯åŠ 
                        waitSec = Math.max(0, Math.round((Date.now() - task.submittedAt) / 1000));
                    }
                }
                waitElement.textContent = waitSec != null ? `${waitSec}s` : '-';
            }
            if (genElement) {
                let genSec = null;
                if (task.startedAt) {
                    if (task.finishedAt) {
                        // å·²å®Œæˆï¼Œå›ºå®šç‚ºé–‹å§‹åˆ°å®Œæˆçš„è€—æ™‚
                        const fixed = task.genDurationSec ?? Math.round((task.finishedAt - task.startedAt) / 1000);
                        genSec = Math.max(0, fixed);
                    } else {
                        // ç”Ÿæˆä¸­ï¼Œå‹•æ…‹ç´¯åŠ 
                        genSec = Math.max(0, Math.round((Date.now() - task.startedAt) / 1000));
                    }
                }
                genElement.textContent = genSec != null ? `${genSec}s` : '-';
            }
            
            // æ›´æ–°ç‹€æ…‹
            statusElement.className = 'task-status';
            if (task.status === 'finished' || task.status === 'completed') {
                statusElement.classList.add('completed');
                statusElement.textContent = 'âœ… Completed';
                taskCard.classList.add('completed');
                
                if (task.url) {
                    showTaskVideo(task);
                }
            } else if (task.status === 'failed' || task.status === 'error') {
                statusElement.classList.add('failed');
                statusElement.textContent = 'âŒ Failed';
                taskCard.classList.add('failed');
            } else if (task.status.startsWith('retrying')) {
                statusElement.classList.add('processing');
                statusElement.textContent = `â³ Retrying...`;
            } else if (task.status === 'submitting') {
                statusElement.classList.add('processing');
                statusElement.textContent = `ğŸ“¤ Submitting...`;
            } else {
                statusElement.classList.add('processing');
                statusElement.textContent = 'ğŸ”„ Processing';
            }
        }

        function showTaskVideo(task) {
            const videoContainer = document.getElementById(`video-${task.id}`);
            if (!videoContainer || !task.url) return;
            
            videoContainer.style.display = 'block';
            const label = task.benchmarkLabel ? `<span style="margin-right:8px; padding:2px 6px; border-radius:10px; background:#eef; color:#335; font-size:12px;">${task.benchmarkLabel}</span>` : '';
            const endpointInfo = task.submissionDetails ? `${task.submissionDetails.endpoint}` : '';
            const promptInfo = (task.promptText || '').replaceAll('<','&lt;').replaceAll('>','&gt;');
            videoContainer.innerHTML = `
                <div style="display:flex; flex-direction:column; gap:6px; align-items:center;">
                    <div style="font-size:12px; color:#666;">${label}${endpointInfo}</div>
                    <video controls width="60%" preload="metadata" style="display: block; margin: 6px auto;">
                        <source src="${task.url}" type="video/mp4">
                        Your browser does not support video playback.
                    </video>
                    <div style="font-size:12px; color:#555; max-width:60%; white-space:pre-wrap; word-break:break-word;">ğŸ“ ${promptInfo || 'No prompt'}</div>
                    <div style="margin-top: 6px; font-size: 12px; color: #666;">
                        ğŸ¬ <a href="${task.url}" target="_blank" style="color: #4facfe;">Open Video</a> |
                        <a href="javascript:void(0)" onclick="downloadTaskVideo('${task.id}')" style="color: #4facfe;">ğŸ’¾ Download</a>
                    </div>
                </div>
            `;
        }

        // ==== Benchmark å°æ¯”æ¸²æŸ“ ====
        function getPairKey(task) {
            // ä»¥åœ–ç‰‡åä½œç‚ºé…å°éµ
            return (task.imageName || '').toLowerCase();
        }

        function maybeRenderBenchmarkPair(task) {
            if (!task.benchmarkLabel) return; // é Benchmark è·³é
            const pairKey = getPairKey(task);
            if (!pairKey) return;
            // æ‰¾åŒåœ–å¦ä¸€åŠ
            const other = Array.from(tasks.values()).find(t => t !== task && t.imageName === task.imageName && t.benchmarkLabel && t.url);
            if (!other || !task.url) return;

            // æ§‹å»ºå·¦å³å°æ¯”å¡
            const container = document.getElementById('benchmarkResults');
            const pairs = document.getElementById('benchmarkPairs');
            if (!container || !pairs) return;
            container.style.display = 'block';

            const promptA = task.benchmarkLabel === 'A' ? (task.promptText || '') : (other.promptText || '');
            const promptB = task.benchmarkLabel === 'B' ? (task.promptText || '') : (other.promptText || '');
            const endpointA = task.benchmarkLabel === 'A' ? (task.submissionDetails?.endpoint || '') : (other.submissionDetails?.endpoint || '');
            const endpointB = task.benchmarkLabel === 'B' ? (task.submissionDetails?.endpoint || '') : (other.submissionDetails?.endpoint || '');

            const safe = s => (s || '').replaceAll('<','&lt;').replaceAll('>','&gt;');

            const pairDiv = document.createElement('div');
            pairDiv.style.cssText = 'display:flex; gap:12px; align-items:flex-start; justify-content:center;';
            pairDiv.innerHTML = `
                <div style="flex:1; text-align:center; background:#fff; border:1px solid #e1e5e9; border-radius:6px; padding:8px;">
                    <div style="font-size:12px; color:#666; margin-bottom:4px;">A â€¢ ${safe(endpointA)}</div>
                    <video controls width="100%" preload="metadata" style="max-width:420px;">
                        <source src="${task.benchmarkLabel === 'A' ? task.url : other.url}" type="video/mp4">
                    </video>
                    <div style="font-size:12px; color:#555; white-space:pre-wrap; word-break:break-word; margin-top:4px;">ğŸ“ ${safe(promptA)}</div>
                </div>
                <div style="flex:1; text-align:center; background:#fff; border:1px solid #e1e5e9; border-radius:6px; padding:8px;">
                    <div style="font-size:12px; color:#666; margin-bottom:4px;">B â€¢ ${safe(endpointB)}</div>
                    <video controls width="100%" preload="metadata" style="max-width:420px;">
                        <source src="${task.benchmarkLabel === 'B' ? task.url : other.url}" type="video/mp4">
                    </video>
                    <div style="font-size:12px; color:#555; white-space:pre-wrap; word-break:break-word; margin-top:4px;">ğŸ“ ${safe(promptB)}</div>
                </div>
            `;
            pairs.prepend(pairDiv);
        }

        async function downloadTaskVideo(taskId) {
            const task = tasks.get(taskId);
            if (!task || !task.url) {
                showError('è¦–é »è³‡è¨Šä¸å®Œæ•´ï¼Œç„¡æ³•ä¸‹è¼‰');
                return;
            }
            
            try {
                // ç”ŸæˆåŸºæ–¼åœ–ç‰‡åç¨±çš„æ–‡ä»¶åï¼Œæ·»åŠ ä»»å‹™IDç¢ºä¿å”¯ä¸€æ€§
                const imageName = (task.imageName || '').replace(/\.[^/.]+$/, '') || 'video';
                const shortTaskId = task.id.substring(0, 8); // ä½¿ç”¨ä»»å‹™IDå‰8ä½
                const defaultFileName = `${imageName}.mp4`;
                
                console.log('ğŸ”„ Downloading single video:', {
                    taskId: task.id,
                    imageName: task.imageName,
                    url: task.url,
                    defaultFileName: defaultFileName,
                    fullTask: task
                });
                
                // æª¢æŸ¥æ˜¯å¦æ”¯æ´ File System Access API (Chrome 86+) ä¸”åœ¨ HTTPS ç’°å¢ƒ
                const isSecureContext = window.isSecureContext || location.protocol === 'https:';
                const hasFileSystemAPI = 'showSaveFilePicker' in window;
                
                console.log('File System API availability:', {
                    hasFileSystemAPI,
                    isSecureContext,
                    protocol: location.protocol
                });
                
                if (hasFileSystemAPI && isSecureContext) {
                    try {
                        // ä½¿ç”¨æ–°çš„ File System Access API è®“ç”¨æˆ¶é¸æ“‡å­˜å„²ä½ç½®
                        const fileHandle = await window.showSaveFilePicker({
                            suggestedName: defaultFileName,
                            types: [{
                                description: 'Video files',
                                accept: {
                                    'video/mp4': ['.mp4']
                                }
                            }]
                        });
                        
                        showSuccess('é–‹å§‹ä¸‹è¼‰è¦–é »...');
                        
                        const response = await fetch(task.url, {
                            method: 'GET',
                            headers: {
                                'Accept': 'video/mp4,video/*,*/*'
                            }
                        });
                        
                        if (!response.ok) {
                            throw new Error(`ä¸‹è¼‰å¤±æ•—: ${response.status} ${response.statusText}`);
                        }
                        
                        const writableStream = await fileHandle.createWritable();
                        await response.body.pipeTo(writableStream);
                        
                        showSuccess('âœ… è¦–é »ä¸‹è¼‰æˆåŠŸï¼');
                        return;
                    } catch (filePickerError) {
                        if (filePickerError.name === 'AbortError') {
                            showError('ä¸‹è¼‰å·²å–æ¶ˆ');
                            return;
                        }
                        console.log('ğŸ“ File picker failed, falling back to regular download:', filePickerError.message);
                    }
                }
                
                // é™ç´šåˆ°å‚³çµ±ä¸‹è¼‰æ–¹å¼
                showSuccess('é–‹å§‹ä¸‹è¼‰è¦–é »...');
                
                const response = await fetch(task.url, {
                    method: 'GET',
                    headers: {
                        'Accept': 'video/mp4,video/*,*/*'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`ä¸‹è¼‰å¤±æ•—: ${response.status} ${response.statusText}`);
                }
                
                const blob = await response.blob();
                
                // å‰µå»ºä¸‹è¼‰é€£çµ
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = defaultFileName;
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                // æ¸…ç† blob URL
                window.URL.revokeObjectURL(url);
                
                showSuccess(`âœ… è¦–é »ä¸‹è¼‰æˆåŠŸï¼æª”åï¼š${defaultFileName}`);
                
            } catch (error) {
                console.error('âŒ Download failed:', error);
                showError(`ä¸‹è¼‰å¤±æ•—: ${error.message}`);
                
                // å¦‚æœ fetch å¤±æ•—ï¼Œå˜—è©¦ç›´æ¥æ‰“é–‹é€£çµ
                console.log('ğŸ”„ Fallback: Opening video URL directly');
                window.open(task.url, '_blank');
            }
        }

        function updateTasksSummary() {
            const totalTasksElement = document.getElementById('totalTasks');
            const averageTimeElement = document.getElementById('averageTime');
            
            const completedTasks = Array.from(tasks.values()).filter(task => 
                task.endTime && (task.status === 'finished' || task.status === 'completed')
            );
            
            totalTasksElement.textContent = tasks.size;
            
            if (completedTasks.length > 0) {
                const totalTime = completedTasks.reduce((sum, task) => sum + task.duration, 0);
                const avgTime = Math.round(totalTime / completedTasks.length);
                const minutes = Math.floor(avgTime / 60);
                const seconds = avgTime % 60;
                
                const avgText = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
                averageTimeElement.textContent = `${avgText} (${completedTasks.length}/${tasks.size})`;
            } else {
                averageTimeElement.textContent = '-';
            }
            
            // é¡¯ç¤º/éš±è—ä¸‹è¼‰æŒ‰éˆ•
            const downloadBtn = document.getElementById('downloadAllBtn');
            const completedVideos = Array.from(tasks.values()).filter(task => 
                (task.status === 'finished' || task.status === 'completed') && task.url
            );
            
            if (downloadBtn) {
                if (completedVideos.length > 0) {
                    downloadBtn.style.display = 'block';
                    downloadBtn.textContent = `ğŸ“¦ Download All Completed Videos (${completedVideos.length})`;
                } else {
                    downloadBtn.style.display = 'none';
                }
            }
        }

        // ä¸‹è¼‰æ‰€æœ‰å®Œæˆçš„è¦–é »
        async function downloadAllVideos() {
            console.log('ğŸ”„ Starting batch download...');
            
            const completedVideos = Array.from(tasks.values()).filter(task => 
                (task.status === 'finished' || task.status === 'completed') && task.url
            );
            
            console.log(`ğŸ“‹ Found ${completedVideos.length} completed videos:`, completedVideos.map(t => ({
                id: t.id,
                imageName: t.imageName,
                promptText: t.promptText,
                url: t.url
            })));
            
            if (completedVideos.length === 0) {
                showError('No completed videos to download');
                return;
            }
            
            const downloadBtn = document.getElementById('downloadAllBtn');
            const originalText = downloadBtn.textContent;
            downloadBtn.disabled = true;
            downloadBtn.textContent = 'ğŸ“¥ Downloading...';
            
            try {
                let successCount = 0;
                let failCount = 0;
                
                for (let i = 0; i < completedVideos.length; i++) {
                    const task = completedVideos[i];
                    
                    try {
                        console.log(`ğŸ“¥ Downloading video ${i + 1}/${completedVideos.length}:`, {
                            taskId: task.id,
                            imageName: task.imageName,
                            url: task.url
                        });
                        
                        // ä½¿ç”¨ fetch ä¸‹è¼‰è¦–é »æ–‡ä»¶
                        const response = await fetch(task.url, {
                            method: 'GET',
                            headers: {
                                'Accept': 'video/mp4,video/*,*/*'
                            }
                        });
                        
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        
                        const blob = await response.blob();
                        
                        // å‰µå»ºä¸‹è¼‰é€£çµ
                        const url = window.URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        
                        // ä½¿ç”¨åœ–ç‰‡åç¨±ä½œç‚ºè¦–é »æª”åï¼Œæ·»åŠ ä»»å‹™IDç¢ºä¿å”¯ä¸€æ€§
                        const imageName = (task.imageName || '').replace(/\.[^/.]+$/, '') || `video_${task.taskNumber}`;
                        const fileName = `${imageName}.mp4`;
                        link.download = fileName;
                        link.style.display = 'none';
                        
                        console.log(`ğŸ’¾ Download filename: ${fileName}`);
                        
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        
                        // æ¸…ç† blob URL
                        window.URL.revokeObjectURL(url);
                        
                        successCount++;
                        
                        // æ›´æ–°æŒ‰éˆ•æ–‡å­—é¡¯ç¤ºé€²åº¦
                        downloadBtn.textContent = `ğŸ“¥ Downloading... (${i + 1}/${completedVideos.length})`;
                        
                        // çŸ­æš«å»¶é²é¿å…ç€è¦½å™¨é˜»æ­¢å¤šå€‹ä¸‹è¼‰
                        if (i < completedVideos.length - 1) {
                            await new Promise(resolve => setTimeout(resolve, 800));
                        }
                        
                    } catch (error) {
                        console.error(`âŒ Failed to download video ${task.taskNumber}:`, error);
                        failCount++;
                    }
                }
                
                // é¡¯ç¤ºçµæœ
                if (successCount === completedVideos.length) {
                    showSuccess(`âœ… Successfully started download for all ${successCount} video(s)!`);
                } else if (successCount > 0) {
                    showSuccess(`âš ï¸ Downloaded ${successCount}/${completedVideos.length} video(s). ${failCount} failed.`);
                } else {
                    showError(`âŒ Failed to download any videos. Please try downloading individually.`);
                }
                
                // ç¢ºä¿ä»»å‹™ç‹€æ…‹ä¿æŒä¸è®Š
                console.log(`ğŸ“Š Tasks status after download:`, Array.from(tasks.values()).length, 'tasks remaining');
                
            } catch (error) {
                console.error('âŒ Batch download error:', error);
                showError(`Download failed: ${error.message}`);
            } finally {
                downloadBtn.disabled = false;
                downloadBtn.textContent = originalText;
                
                // å¼·åˆ¶æ›´æ–°ä»»å‹™æ‘˜è¦ä»¥ç¢ºä¿UIæ­£ç¢º
                updateTasksSummary();
            }
        }

        // èª¿è©¦ä»»å‹™æ•¸æ“š
        function debugTasks() {
            console.log('=== Debug Tasks Info ===');
            console.log('Total tasks:', tasks.size);
            console.log('Tasks Map:', tasks);
            
            Array.from(tasks.values()).forEach((task, index) => {
                console.log(`Task ${index + 1}:`, {
                    id: task.id,
                    taskNumber: task.taskNumber,
                    imageName: task.imageName,
                    promptText: task.promptText,
                    status: task.status,
                    url: task.url
                });
            });
            
            showSuccess('èª¿è©¦ä¿¡æ¯å·²è¼¸å‡ºåˆ°æ§åˆ¶å°ï¼Œè«‹æŒ‰F12æŸ¥çœ‹');
        }

        // æ¸¬è©¦é€£æ¥åŠŸèƒ½
        async function testConnection() {
            console.log('testConnection function called');
            
            const apiKey = document.getElementById('apiKey').value;
            const apiConfig = getCurrentAPIConfig();
            const apiUrl = apiConfig.endpoint;

            if (!apiKey) {
                showError('Please enter API Key first');
                return;
            }

            clearMessages();
            
            // ç²å–å®Œæ•´URLä¿¡æ¯
            const providerConfig = API_PROVIDERS[apiConfig.provider];
            const baseUrl = providerConfig.baseUrl;
            const fullUrl = baseUrl + apiConfig.endpoint;
            
            // ä½¿ç”¨æ­£ç¢ºçš„ API Keyï¼ˆå¦‚æœç”¨æˆ¶æ²’æœ‰è¼¸å…¥ï¼Œä½¿ç”¨é…ç½®ä¸­çš„é»˜èªå€¼ï¼‰
            const effectiveApiKey = apiKey || providerConfig.apiKey;
            
            // é¡¯ç¤ºèª¿è©¦ä¿¡æ¯
            const debugInfo = `
ğŸ” <strong>Test Connection Debug Info:</strong><br>
ğŸ“ <strong>Provider:</strong> ${apiConfig.provider}<br>
ğŸ”— <strong>API Version:</strong> ${apiConfig.version}<br>
ğŸŒ <strong>Base URL:</strong> ${baseUrl}<br>
ğŸ¯ <strong>Endpoint:</strong> ${apiConfig.endpoint}<br>
ğŸ”— <strong>Full URL:</strong> ${fullUrl}<br>
ğŸ”‘ <strong>API Key:</strong> ${effectiveApiKey.substring(0, 8)}...${effectiveApiKey.substring(effectiveApiKey.length - 8)}<br>
â³ Sending test request...
            `;
            showSuccess(debugInfo);

            try {
                console.log('=== Test Connection Debug Info ===');
                console.log('Provider:', apiConfig.provider);
                console.log('API Version:', apiConfig.version);
                console.log('Base URL:', baseUrl);
                console.log('Endpoint:', apiConfig.endpoint);
                console.log('Full URL:', fullUrl);
                console.log('Proxy Endpoint:', apiUrl);
                console.log('API Key:', `${apiKey.substring(0, 8)}...${apiKey.substring(apiKey.length - 8)}`);

                // å‰µå»ºä¸€å€‹æœ€å°çš„æ¸¬è©¦è«‹æ±‚é«”
                const formData = new FormData();
                formData.append('prompt', 'test connection');
                formData.append('provider', getCurrentAPIConfig().provider);
                formData.append('version', getCurrentAPIConfig().version);
                
                // å‰µå»ºä¸€å€‹1x1åƒç´ çš„æ¸¬è©¦åœ–ç‰‡
                const canvas = document.createElement('canvas');
                canvas.width = 1;
                canvas.height = 1;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, 1, 1);
                
                // å°‡canvasè½‰æ›ç‚ºblob
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                formData.append('image', blob, 'test.png');

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'X-API-KEY': effectiveApiKey
                    },
                    body: formData
                });

                console.log('=== Response Info ===');
                console.log('Status:', response.status, response.statusText);
                console.log('Headers:', [...response.headers.entries()]);

                // è®€å–éŸ¿æ‡‰å…§å®¹
                let responseText = '';
                try {
                    responseText = await response.text();
                    console.log('Response content:', responseText);
                } catch (e) {
                    console.log('Could not read response content:', e);
                    responseText = 'Could not read response content';
                }

                // é¡¯ç¤ºå®Œæ•´çš„æ¸¬è©¦çµæœ
                const resultInfo = `
ğŸ” <strong>Test Connection Results:</strong><br>
ğŸ“ <strong>Provider:</strong> ${apiConfig.provider}<br>
ğŸ”— <strong>API Version:</strong> ${apiConfig.version}<br>
ğŸŒ <strong>Base URL:</strong> ${baseUrl}<br>
ğŸ¯ <strong>Endpoint:</strong> ${apiConfig.endpoint}<br>
ğŸ”— <strong>Full URL:</strong> ${fullUrl}<br>
ğŸ”‘ <strong>API Key:</strong> ${effectiveApiKey.substring(0, 8)}...${effectiveApiKey.substring(effectiveApiKey.length - 8)}<br>
ğŸ“Š <strong>Response Status:</strong> ${response.status} ${response.statusText}<br>
ğŸ“ <strong>Response Content:</strong><br>
<pre style="background: #f5f5f5; padding: 10px; border-radius: 5px; max-height: 200px; overflow-y: auto; font-size: 12px; white-space: pre-wrap;">${responseText}</pre>
                `;

                if (response.status === 200 || response.status === 201 || response.status === 202) {
                    showSuccess(resultInfo + '<br>âœ… <strong>Connection test successful!</strong>');
                } else if (response.status === 401) {
                    showError(resultInfo + '<br>âŒ <strong>Authentication failed: API Key might be invalid</strong>');
                } else if (response.status === 403) {
                    showError(resultInfo + '<br>âŒ <strong>Forbidden: API Key might not have access</strong>');
                } else if (response.status === 404) {
                    showError(resultInfo + '<br>âŒ <strong>API endpoint not found: Please check the URL</strong>');
                } else if (response.status === 400) {
                    showError(resultInfo + '<br>âš ï¸ <strong>Bad Request: API Key or request format may be incorrect</strong>');
                } else if (response.status === 500) {
                    showError(resultInfo + '<br>âš ï¸ <strong>Server Error: API service may be temporarily unavailable</strong>');
                } else {
                    showError(resultInfo + `<br>âš ï¸ <strong>Received response status: ${response.status} ${response.statusText}</strong>`);
                }

            } catch (error) {
                console.error('Connection test error:', error);
                
                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    showError('âŒ Network Error: Could not connect to server. Check URL and network connection.');
                } else if (error.message.includes('CORS')) {
                    showError('âŒ CORS Error: Cross-origin request blocked by browser.');
                } else {
                    showError(`âŒ Connection failed: ${error.message}`);
                }
            }
        }

        // æ·»åŠ èª¿è©¦æª¢æŸ¥åŠŸèƒ½
        async function debugCheck() {
            console.log('debugCheck function called');
            const apiKey = document.getElementById('apiKey').value;
            const apiConfig = getCurrentAPIConfig();
            const apiUrl = apiConfig.endpoint;

            if (!apiKey) {
                showError('Please enter API Key first');
                return;
            }

            clearMessages();
            showSuccess('Performing debug check...');

            try {
                // å˜—è©¦ä¸€å€‹ç°¡å–®çš„è«‹æ±‚ä¾†é€²è¡Œèª¿è©¦æª¢æŸ¥
                const response = await fetch(apiUrl, {
                    method: 'OPTIONS',
                    headers: {
                        'X-API-KEY': apiKey,
                    }
                });

                console.log('Debug check response:', response.status, response.statusText);

                if (response.status === 405) {
                    showSuccess('âœ… Debug check successful!');
                } else if (response.status === 200 || response.status === 204) {
                    showError('âŒ Debug check failed: Received non-405 status code');
                } else {
                    showError(`âš ï¸ Received response status: ${response.status} ${response.statusText}`);
                }

            } catch (error) {
                console.error('Debug check error:', error);
                if (error.message.includes('CORS')) {
                    showError('âŒ CORS Error: May need to run in a CORS-enabled environment.');
                } else if (error.message.includes('network')) {
                    showError('âŒ Network Error: Check network connection and URL.');
                } else {
                    showError(`âŒ Debug check failed: ${error.message}`);
                }
            }
        }


        
        function getCurrentApiUrl() {
            return getCurrentAPIConfig().endpoint;
        }

        // é é¢è¼‰å…¥æ™‚çš„åˆå§‹åŒ–
        window.addEventListener('load', () => {
            console.log('ğŸš€ Parrot API Multi-Task Frontend Loaded');
            
            // APIé…ç½®å·²å›ºå®šç‚ºstagingç’°å¢ƒ
            updateProviderVersions(); // åˆå§‹åŒ–æä¾›å•†å’Œç‰ˆæœ¬é¸æ“‡
            // åˆå§‹åŒ– Benchmark å€åŸŸ
            try {
                document.getElementById('benchmarkToggle')?.addEventListener('change', (e) => {
                    const on = e.target.checked;
                    document.getElementById('benchmarkConfig')?.classList.toggle('hidden', !on);
                    if (on) updateProviderVersionsB();
                });
            } catch {}
        });

        // é é¢å¸è¼‰æ™‚æ¸…ç†
        window.addEventListener('beforeunload', () => {
            stopStatusCheck();
        });

        async function minimaxTTS() {
            try {
                const text = document.getElementById('minimaxText').value.trim();
                const voiceId = document.getElementById('minimaxVoiceId').value.trim();
                const groupId = document.getElementById('minimaxGroupId').value.trim();
                const apiKey = document.getElementById('minimaxApiKey').value.trim();

                if (!text) {
                    showError('è«‹å…ˆè¼¸å…¥æ–‡æœ¬');
                    return;
                }
                if (!groupId && !apiKey) {
                    showError('è«‹å¡«å¯« MINIMAX_GROUPID èˆ‡ MINIMAX_API_KEYï¼Œæˆ–åœ¨æœå‹™å™¨è¨­ç½®ç’°å¢ƒè®Šé‡');
                    return;
                }

                clearMessages();
                showSuccess('â³ æ­£åœ¨ç”ŸæˆéŸ³é »ï¼Œè«‹ç¨å€™...');

                const body = { text };
                if (window.minimaxCurrentVoiceId) body.voice_id = window.minimaxCurrentVoiceId;

                const response = await fetch('/minimax/t2a', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(body)
                });

                if (!response.ok) {
                    let errJson = {}, errText = '';
                    try { errText = await response.text(); errJson = JSON.parse(errText); } catch { errJson = {}; }
                    const code = errJson.provider_status_code ?? errJson.status ?? errJson.base_resp?.status_code;
                    const msg = errJson.provider_status_msg ?? errJson.base_resp?.status_msg ?? (errJson.provider_response?.base_resp?.status_msg);
                    const base = errJson.error || errJson.message || 'Request failed';
                    const details = `${base}${code ? ` [${code}]` : ''}${msg ? `: ${msg}` : ''}`;
                    console.error('Minimax TTS failed:', { status: response.status, bodyText: errText, parsed: errJson });
                    throw new Error(details || `HTTP ${response.status}`);
                }

                const blob = await response.blob();
                const url = URL.createObjectURL(blob);
                const player = document.getElementById('minimaxAudioPlayer');
                const link = document.getElementById('minimaxAudioLink');

                player.src = url;
                player.style.display = 'block';
                link.href = url;
                link.download = `minimax-${Date.now()}.mp3`;
                link.style.display = 'inline-block';

                showSuccess('âœ… ç”ŸæˆæˆåŠŸï¼Œå¯æ’­æ”¾æˆ–ä¸‹è¼‰');
            } catch (e) {
                showError(`âŒ ç”Ÿæˆå¤±æ•—: ${e.message}`);
            }
        }

        async function onStartButtonClick() {
            const isBenchmark = document.getElementById('benchmarkToggle')?.checked;
            const provider = document.getElementById('apiProvider')?.value;
            if (!isBenchmark) {
                if (provider === 'minimax') {
                    await minimaxTTS();
                } else {
                    await generateVideo();
                }
                return;
            }

            // Benchmark æ¨¡å¼ï¼šåŒä¸€æ‰¹åœ–ç‰‡ï¼Œåˆ†åˆ¥ç”¨ A/B å…©çµ„é…ç½®æäº¤ï¼ˆä½¿ç”¨ Benchmark å€åŸŸçš„ Promptï¼‰
            const images = Array.from(document.getElementById('imageFile').files || []);
            if (images.length === 0) { showError('Please select at least one image file'); return; }

            const aKey = document.getElementById('apiKey')?.value || '';
            const bKey = document.getElementById('apiKeyB')?.value || '';
            const aCfg = getCurrentAPIConfig();
            const bCfg = getCurrentAPIConfigB();
            const promptA = document.getElementById('promptTextA')?.value || '';
            const promptB = document.getElementById('promptTextB')?.value || '';

            for (const img of images) {
                // Aï¼šè¦†å¯«åƒæ•¸å¾Œå¾©ç”¨åŸæœ‰ submitTaskï¼ˆä¿ç•™ä»»å‹™/è¼ªè©¢/éŒ¯èª¤è™•ç†ï¼‰
                window.benchmarkOverrideConfig = aCfg;
                window.benchmarkOverrideApiKey = aKey;
                window.benchmarkOverridePrompt = promptA;
                window.benchmarkLabel = 'A';
                window.benchmarkImageName = img.name || '';
                await submitTask(img);
                // Bï¼š
                window.benchmarkOverrideConfig = bCfg;
                window.benchmarkOverrideApiKey = bKey;
                window.benchmarkOverridePrompt = promptB;
                window.benchmarkLabel = 'B';
                window.benchmarkImageName = img.name || '';
                await submitTask(img);
                // æ¸…ç†
                window.benchmarkOverrideConfig = null;
                window.benchmarkOverrideApiKey = null;
                window.benchmarkOverridePrompt = null;
                window.benchmarkLabel = null;
                window.benchmarkImageName = null;
            }
        }

        // Minimax Clone å‰ç«¯äº¤äº’ï¼ˆè‡ªå‹•å…‹éš†ï¼‰
        let minimaxCurrentVoiceId = '';
        (function initMinimaxCloneUI(){
            const upload = document.getElementById('minimaxCloneUpload');
            const input = document.getElementById('minimaxCloneFile');
            const nameEl = document.getElementById('minimaxCloneFileName');
            const statusEl = document.getElementById('minimaxCloneStatus');
            if (!upload || !input) return;
            upload.addEventListener('click', () => input.click());
            upload.addEventListener('dragover', e => { e.preventDefault(); upload.classList.add('drag-over'); });
            upload.addEventListener('dragleave', () => upload.classList.remove('drag-over'));
            upload.addEventListener('drop', e => {
                e.preventDefault(); upload.classList.remove('drag-over');
                if (e.dataTransfer?.files?.length){ input.files = e.dataTransfer.files; if (nameEl) nameEl.textContent = `Selected: ${e.dataTransfer.files[0].name}`; autoClone(); }
            });
            input.addEventListener('change', () => { const f = input.files?.[0]; if (nameEl) nameEl.textContent = f ? `Selected: ${f.name}` : ''; if (f) autoClone(); });

            async function autoClone() {
                try {
                    console.log('ğŸš€ AUTO CLONE STARTED!!!');
                    const f = input.files?.[0];
                    if (!f) return;
                    
                    // æª¢æŸ¥æ–‡ä»¶é¡å‹ï¼ˆæ”¯æŒéŸ³é »å’Œè¦–é »æ–‡ä»¶ï¼‰
                    const isAudio = f.type.startsWith('audio/') || f.name.match(/\.(mp3|wav|m4a|aac|ogg|flac)$/i);
                    const isVideo = f.type.startsWith('video/') || f.name.match(/\.(mp4|mov|avi|mkv)$/i);
                    if (!isAudio && !isVideo) {
                        if (statusEl) statusEl.textContent = 'âŒ è«‹ä¸Šå‚³éŸ³é »æˆ–è¦–é »æ–‡ä»¶';
                        showError('è«‹ä¸Šå‚³éŸ³é »æ–‡ä»¶ï¼ˆMP3/WAV/M4Aç­‰ï¼‰æˆ–è¦–é »æ–‡ä»¶ï¼ˆMP4ç­‰ï¼Œå°‡è‡ªå‹•æå–éŸ³é »ï¼‰');
                        return;
                    }
                    
                    clearMessages();
                    if (statusEl) statusEl.textContent = 'â³ æ­£åœ¨ä¸Šå‚³ä¸¦å…‹éš†...';
                    console.log('ğŸ”„ About to send request to /minimax/clone');
                    const fd = new FormData();
                    fd.append('audio', f);
                    const resp = await fetch('/minimax/clone', { method: 'POST', body: fd });
                    console.log('ğŸ“¡ Got response, status:', resp.status);
                    let text = '', data = {};
                    try { text = await resp.text(); console.log('ğŸ“„ Raw response text:', text); data = JSON.parse(text); } catch { data = {}; }
                    console.log('ğŸ” Minimax /clone response:', { status: resp.status, raw: text, parsed: data });
                    if (!resp.ok) { 
                        const code = data.provider_status_code ?? data.status ?? data.base_resp?.status_code;
                        const msg = data.provider_status_msg ?? data.base_resp?.status_msg ?? (data.provider_response?.base_resp?.status_msg);
                        const base = data.error || data.message || 'Request failed';
                        const details = `${base}${code ? ` [${code}]` : ''}${msg ? `: ${msg}` : ''}`;
                        console.error('âŒ Minimax clone failed:', { status: resp.status, raw: text, parsed: data });
                        throw new Error(details || `HTTP ${resp.status}`); 
                    }
                    if (data.voice_id) {
                        minimaxCurrentVoiceId = data.voice_id;
                        if (statusEl) statusEl.textContent = `âœ… å…‹éš†æˆåŠŸ voice_id: ${data.voice_id}`;
                        showSuccess(`âœ… èªéŸ³å…‹éš†æˆåŠŸï¼Œvoice_id: ${data.voice_id}`);
                    }
                    if (data.preview_audio) {
                        const p = document.getElementById('minimaxClonePreview');
                        p.src = data.preview_audio; p.style.display = 'block';
                    }
                } catch (e) {
                    if (statusEl) statusEl.textContent = `âŒ å…‹éš†å¤±æ•—: ${e.message}`;
                    showError(`âŒ å…‹éš†å¤±æ•—: ${e.message}`);
                }
            }
        })();
    </script>
</body>
</html> 