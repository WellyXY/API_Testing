<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parrot API - Image to Video Generator</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üé¨</text></svg>">
    <style>
        /* ========== Design System ========== */
        :root {
            /* Color system - Material Design inspired */
            --primary-color: #2196f3;
            --primary-dark: #1976d2;
            --primary-light: #64b5f6;
            --accent-color: #00bcd4;
            --success-color: #4caf50;
            --warning-color: #ff9800;
            --error-color: #f44336;
            
            /* Neutral colors */
            --text-primary: #212121;
            --text-secondary: #757575;
            --text-disabled: #bdbdbd;
            --divider: #e0e0e0;
            
            /* Background colors */
            --bg-primary: #ffffff;
            --bg-secondary: #fafafa;
            --bg-tertiary: #f5f5f5;
            
            /* Spacing system - 8px grid */
            --spacing-xs: 4px;
            --spacing-sm: 8px;
            --spacing-md: 16px;
            --spacing-lg: 24px;
            --spacing-xl: 32px;
            --spacing-xxl: 40px;
            
            /* Border radius */
            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 12px;
            
            /* Shadows */
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
            --shadow-md: 0 3px 6px rgba(0,0,0,0.15), 0 2px 4px rgba(0,0,0,0.12);
            --shadow-lg: 0 10px 20px rgba(0,0,0,0.15), 0 3px 6px rgba(0,0,0,0.10);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            background: var(--bg-tertiary);
            min-height: 100vh;
            padding: var(--spacing-lg);
            color: var(--text-primary);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            background: var(--bg-primary);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            padding: var(--spacing-xl) var(--spacing-xxl);
            margin-bottom: var(--spacing-lg);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-left h1 {
            font-size: 24px;
            font-weight: 500;
            margin-bottom: var(--spacing-xs);
            color: var(--text-primary);
        }

        .header-left p {
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 400;
        }

        .header-right {
            display: flex;
            gap: var(--spacing-sm);
            align-items: center;
        }

        .content {
            display: grid !important;
            grid-template-columns: 360px 1fr !important;
            gap: var(--spacing-lg);
            align-items: start;
            width: 100%;
        }

        /* Card System */
        .card {
            background: var(--bg-primary);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-sm);
            padding: var(--spacing-lg);
            margin-bottom: var(--spacing-lg);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-md);
            border-bottom: 1px solid var(--divider);
        }

        .card-title {
            font-size: 16px;
            font-weight: 500;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
        }

        .card-subtitle {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: var(--spacing-xs);
        }

        .step-indicator {
            background: var(--primary-color);
            color: white;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 500;
        }

        .sidebar {
            position: sticky;
            top: var(--spacing-lg);
        }

        .main-area {
            min-height: 80vh;
        }

        .form-group {
            margin-bottom: var(--spacing-lg);
        }

        .form-group label {
            display: block;
            margin-bottom: var(--spacing-sm);
            font-weight: 500;
            color: var(--text-primary);
            font-size: 14px;
        }

        .hidden { display: none !important; }

        .file-upload-area {
            border: 2px dashed var(--divider);
            border-radius: var(--radius-lg);
            padding: var(--spacing-xl);
            text-align: center;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            background: var(--bg-primary);
            position: relative;
            overflow: hidden;
        }

        .file-upload-area:hover {
            border-color: var(--primary-color);
            background: #f5f9ff;
            box-shadow: 0 0 0 4px rgba(33, 150, 243, 0.05);
        }

        .file-upload-area.drag-over {
            border-color: var(--primary-color);
            background: #e3f2fd;
            border-style: solid;
            transform: scale(1.02);
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.2);
        }

        .upload-icon {
            font-size: 42px;
            color: var(--text-disabled);
            margin-bottom: var(--spacing-sm);
            transition: all 0.3s ease;
        }

        .file-upload-area:hover .upload-icon {
            transform: scale(1.1);
            color: var(--primary-color);
        }

        .file-upload-area.has-file {
            border-color: var(--success-color);
            background: #f1f8f4;
            border-style: solid;
        }

        .file-upload-area.has-file .upload-icon {
            color: var(--success-color);
        }

        .upload-text strong {
            display: block;
            font-size: 14px;
            color: var(--text-primary);
            margin-bottom: var(--spacing-xs);
        }

        .upload-text small {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        /* Info Badge */
        .info-badge {
            display: inline-flex;
            align-items: center;
            gap: var(--spacing-xs);
            padding: 4px 10px;
            background: #e3f2fd;
            color: var(--primary-color);
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
        }

        /* Description Box */
        .description-box {
            background: var(--bg-secondary);
            padding: var(--spacing-md);
            border-radius: var(--radius-sm);
            border-left: 3px solid var(--primary-color);
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.6;
        }

        input[type="file"] {
            display: none;
        }

        .form-control {
            width: 100%;
            padding: 12px 16px;
            border: 1px solid var(--divider);
            border-radius: var(--radius-sm);
            font-size: 14px;
            font-family: inherit;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        .form-control:hover {
            border-color: var(--text-disabled);
        }

        .form-control:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
        }

        textarea.form-control {
            resize: vertical;
            min-height: 100px;
            line-height: 1.5;
        }

        /* Removed .api-config and .api-config h3 - now using card classes */

        /* Toggle Switch (iOS Style) */
        .toggle-container {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            padding: var(--spacing-md);
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
            margin-bottom: var(--spacing-md);
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 48px;
            height: 28px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .3s;
            border-radius: 28px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        input:checked + .slider {
            background-color: var(--primary-color);
        }

        input:checked + .slider:before {
            transform: translateX(20px);
        }

        .toggle-label {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
            flex: 1;
        }

        .toggle-hint {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: var(--spacing-xs);
        }

        /* Compact Select */
        .select-row {
            display: grid;
            grid-template-columns: 120px 1fr;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        .select-row label {
            font-size: 13px;
            font-weight: 500;
            color: var(--text-secondary);
            margin: 0;
        }

        /* Section Divider */
        .section-divider {
            height: 1px;
            background: var(--divider);
            margin: var(--spacing-lg) 0;
        }

        /* Benchmark Section */
        #benchmarkConfig {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-lg);
        }
        
        .benchmark-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--spacing-lg);
        }
        
        .benchmark-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
            box-shadow: 0 8px 24px rgba(102, 126, 234, 0.15);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .benchmark-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 100%);
            pointer-events: none;
        }
        
        .benchmark-section:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 32px rgba(102, 126, 234, 0.25);
        }
        
        .benchmark-section:first-child {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            box-shadow: 0 8px 24px rgba(245, 87, 108, 0.15);
        }
        
        .benchmark-section:first-child:hover {
            box-shadow: 0 12px 32px rgba(245, 87, 108, 0.25);
        }

        .benchmark-section h4 {
            font-size: 16px;
            font-weight: 600;
            color: white;
            margin-bottom: var(--spacing-lg);
            display: flex;
            align-items: center;
            gap: var(--spacing-sm);
            position: relative;
            z-index: 1;
            text-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .benchmark-section .form-group {
            position: relative;
            z-index: 1;
        }
        
        .benchmark-section label {
            color: rgba(255,255,255,0.95);
            font-weight: 500;
            font-size: 13px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        
        .benchmark-section .form-control {
            background: white;
            border: 1px solid rgba(255,255,255,0.3);
            backdrop-filter: blur(10px);
            color: var(--text-primary);
            position: relative;
            z-index: 2;
        }
        
        .benchmark-section .form-control:focus {
            background: white;
            border-color: rgba(255,255,255,0.6);
            box-shadow: 0 0 0 3px rgba(255,255,255,0.2);
        }
        
        .benchmark-section select.form-control {
            background: white;
            cursor: pointer;
        }
        
        .benchmark-section select.form-control option {
            background: white;
            color: var(--text-primary);
        }
        
        .benchmark-section .description-box {
            background: rgba(255,255,255,0.15);
            border-left: 3px solid rgba(255,255,255,0.5);
            color: white;
            backdrop-filter: blur(10px);
            font-size: 11px;
            line-height: 1.4;
            max-height: 60px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .benchmark-section .description-box::before {
            content: 'üìã ';
        }
        
        /* Âú®Â∞èÂ±èÂπï‰∏äÂûÇÁõ¥ÊéíÂàó */
        @media (max-width: 1024px) {
            .benchmark-grid {
                grid-template-columns: 1fr;
            }
        }

        .btn {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: var(--radius-sm);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            width: 100%;
            text-transform: none;
            letter-spacing: 0;
            box-shadow: var(--shadow-sm);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: var(--spacing-sm);
        }

        .btn:hover {
            background: var(--primary-dark);
            box-shadow: var(--shadow-md);
            transform: translateY(-1px);
        }

        .btn:active {
            transform: translateY(0);
            box-shadow: var(--shadow-sm);
        }

        .btn:disabled {
            background: var(--text-disabled);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* Button Variants */
        .btn-primary {
            background: var(--primary-color);
        }

        .btn-primary:hover {
            background: var(--primary-dark);
        }

        .btn-success {
            background: var(--success-color);
        }

        .btn-success:hover {
            background: #388e3c;
        }

        /* Toggle Switch */
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: var(--primary-color);
        }

        input:focus + .slider {
            box-shadow: 0 0 1px var(--primary-color);
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-secondary:hover {
            background: #545b62;
        }

        .btn-outline {
            background: transparent;
            border: 1px solid var(--divider);
            color: var(--text-primary);
            box-shadow: none;
        }

        .btn-outline:hover {
            background: var(--bg-secondary);
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        .btn-sm {
            padding: 6px 12px;
            font-size: 12px;
        }

        .btn-lg {
            padding: 14px 28px;
            font-size: 15px;
            font-weight: 600;
        }

        /* Button Group */
        .btn-group {
            display: flex;
            gap: var(--spacing-sm);
            margin-bottom: var(--spacing-md);
        }

        .btn-group .btn {
            flex: 1;
        }

        /* Icon Button */
        .icon-btn {
            width: 36px;
            height: 36px;
            padding: 0;
            border-radius: 50%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .status-area {
            margin-top: var(--spacing-xl);
            padding: var(--spacing-lg);
            border-radius: var(--radius-md);
            background: var(--bg-secondary);
            border: 1px solid var(--divider);
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: var(--spacing-sm) 0;
            border-bottom: 1px solid var(--divider);
        }

        .status-item:last-child {
            border-bottom: none;
        }

        .status-label {
            font-weight: 500;
            color: var(--text-primary);
            font-size: 14px;
        }

        .status-value {
            color: var(--text-secondary);
            font-size: 14px;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background: var(--divider);
            border-radius: 2px;
            overflow: hidden;
            margin: var(--spacing-sm) 0;
        }

        .progress-fill {
            height: 100%;
            background: var(--primary-color);
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            width: 0%;
        }

        .result-area {
            margin-top: var(--spacing-xl);
            text-align: center;
        }

        .video-container {
            margin: var(--spacing-lg) 0;
        }

        .video-container video {
            max-width: 100%;
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-md);
        }

        .error-message {
            background: #ffebee;
            border-left: 4px solid var(--error-color);
            color: #c62828;
            padding: var(--spacing-md);
            border-radius: var(--radius-sm);
            margin: var(--spacing-md) 0;
            font-size: 14px;
        }

        .success-message {
            background: #e8f5e9;
            border-left: 4px solid var(--success-color);
            color: #2e7d32;
            padding: var(--spacing-md);
            border-radius: var(--radius-sm);
            margin: var(--spacing-md) 0;
            font-size: 14px;
        }

        .preview-image {
            max-width: 300px;
            max-height: 200px;
            border-radius: var(--radius-md);
            margin-top: var(--spacing-md);
            box-shadow: var(--shadow-sm);
        }

        .task-card {
            background: var(--bg-primary);
            border: 1px solid var(--divider);
            border-radius: var(--radius-md);
            margin-bottom: var(--spacing-lg);
            padding: var(--spacing-lg);
            box-shadow: var(--shadow-sm);
            transition: box-shadow 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .task-card:hover {
            box-shadow: var(--shadow-md);
        }

        .task-card.completed {
            border-color: var(--success-color);
            background: #f1f8f4;
        }

        .task-card.failed {
            border-color: var(--error-color);
            background: #fef5f5;
        }

        .task-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--spacing-md);
            padding-bottom: var(--spacing-sm);
            border-bottom: 1px solid var(--divider);
        }

        .task-title {
            font-weight: 500;
            color: var(--text-primary);
            font-size: 14px;
        }

        .task-status {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .task-status.processing {
            background: #fff4e5;
            color: #e65100;
        }

        .task-status.completed {
            background: #e8f5e9;
            color: #2e7d32;
        }

        .task-status.failed {
            background: #ffebee;
            color: #c62828;
        }

        .task-details {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        .task-detail-item {
            text-align: center;
        }

        .task-detail-label {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: var(--spacing-xs);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .task-detail-value {
            font-weight: 500;
            color: var(--text-primary);
            font-size: 14px;
        }

        .task-video {
            text-align: center;
            margin-top: var(--spacing-md);
        }

        /* Adjust sidebar width on smaller screens */
        @media (max-width: 1100px) {
            .content {
                grid-template-columns: 320px 1fr !important;
            }
        }

        /* Switch to single column on very small screens */
        @media (max-width: 600px) {
            .content {
                grid-template-columns: 1fr !important;
            }
            
            .sidebar {
                position: relative;
                top: 0;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: var(--spacing-sm);
            }
            
            .header {
                flex-direction: column;
                text-align: center;
                padding: var(--spacing-lg);
            }
            
            .header-left h1 {
                font-size: 20px;
            }
            
            .header-left p {
                font-size: 13px;
            }
            
            .header-right {
                width: 100%;
                justify-content: center;
                margin-top: var(--spacing-md);
            }

            .content {
                grid-template-columns: 1fr;
                gap: var(--spacing-md);
            }

            .task-details {
                grid-template-columns: repeat(2, 1fr);
                gap: var(--spacing-sm);
            }
            
            .file-upload-area {
                padding: var(--spacing-lg);
            }
            
            .select-row {
                grid-template-columns: 1fr;
                gap: var(--spacing-xs);
            }
            
            .select-row label {
                margin-bottom: var(--spacing-xs);
            }
            
            .btn-group {
                flex-direction: column;
            }
            
            .card {
                padding: var(--spacing-md);
            }
        }
    </style>
    <!-- HLS.js for streaming support -->
    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-left">
                <h1>üé¨ Parrot API</h1>
                <p>Professional Image-to-Video Generator</p>
            </div>
            <div class="header-right">
                <span class="info-badge">‚ö° Fast Processing</span>
                <span class="info-badge">üéØ Multi-Provider Support</span>
            </div>
        </div>

        <div class="content">
            <div class="sidebar">


            <!-- API Configuration -->
            <div class="card">
                <div class="card-header">
                    <div>
                        <div class="card-title">
                            <span class="step-indicator">1</span>
                            API Configuration
                        </div>
                        <div class="card-subtitle">Select your provider and version</div>
                    </div>
                </div>
                
                <!-- Benchmark Toggle -->
                <div class="toggle-container">
                    <label class="switch">
                        <input type="checkbox" id="benchmarkToggle">
                        <span class="slider"></span>
                    </label>
                    <div style="flex:1;">
                        <div class="toggle-label">Benchmark Mode</div>
                        <div class="toggle-hint">Compare two API configurations side-by-side</div>
                    </div>
                </div>
                
                <!-- API Path A -->
                <div style="margin-top: var(--spacing-md);">
                    <div class="select-row">
                        <label for="apiProvider">Provider:</label>
                        <select id="apiProvider" class="form-control" onchange="updateProviderVersions()">
                            <option value="original" selected>Original - Parrot API</option>
                            <option value="testing">üß™ Testing (New Architecture)</option>
                            <option value="staging">Staging - Parrot Labs</option>
                        <option value="candy">Candy (Lipsync)</option>
                            <option value="minimax">Minimax TTS</option>
                        </select>
                    </div>

                    <div class="select-row">
                        <label for="apiVersion">Version:</label>
                        <select id="apiVersion" class="form-control" onchange="updateAPIDescription()">
                            <!-- Version options populated dynamically by JavaScript -->
                        </select>
                    </div>

                    <div class="select-row" id="endpointTypeGroup" style="display: none;">
                        <label for="endpointType">Endpoint:</label>
                        <select id="endpointType" class="form-control" onchange="updateAPIDescription()">
                            <option value="image-to-video-v2" selected>image-to-video-v2 (default)</option>
                            <option value="image-to-video">image-to-video</option>
                            <option value="image-to-video-new">image-to-video-new</option>
                            <option value="image-to-video-inner">image-to-video-inner</option>
                            <option value="image-to-video-nmd">image-to-video-nmd</option>
                            <option value="image-to-video-v2">image-to-video-v2</option>
                            <option value="audio-to-video">audio-to-video</option>
                        </select>
                    </div>
                </div>

                <!-- Benchmark Configuration -->
                <div id="benchmarkConfig" class="section hidden">
                    <div class="section-divider"></div>
                    
                    <div class="benchmark-grid">
                        <!-- Path A -->
                        <div class="benchmark-section">
                            <h4>üÖ∞Ô∏è Path A Configuration</h4>
                            <div class="form-group">
                                <label for="promptTextA">Prompt (A)</label>
                                <textarea id="promptTextA" class="form-control" placeholder="Enter prompt for path A..." rows="3"></textarea>
                            </div>
                        </div>
                        
                        <!-- Path B -->
                        <div class="benchmark-section">
                            <h4>üÖ±Ô∏è Path B Configuration</h4>
                            
                            <div class="form-group">
                                <label for="apiProviderB">Provider</label>
                                <select id="apiProviderB" class="form-control" onchange="updateProviderVersionsB()">
                                    <option value="testing">üß™ Testing (New Architecture)</option>
                                    <option value="staging">Staging - Parrot Labs</option>
                                    <option value="candy">Candy (Lipsync)</option>
                                    <option value="original" selected>Original - Parrot API</option>
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label for="apiVersionB">Version</label>
                                <select id="apiVersionB" class="form-control" onchange="updateAPIDescriptionB()"></select>
                            </div>
                            
                            <div class="form-group" id="endpointTypeGroupB" style="display:none;">
                                <label for="endpointTypeB">Endpoint</label>
                                <select id="endpointTypeB" class="form-control" onchange="updateAPIDescriptionB()">
                                    <option value="image-to-video">image-to-video (default)</option>
                                    <option value="image-to-video-new">image-to-video-new</option>
                                    <option value="image-to-video-inner">image-to-video-inner</option>
                                    <option value="image-to-video-nmd">image-to-video-nmd</option>
                                    <option value="image-to-video-v2">image-to-video-v2</option>
                                    <option value="audio-to-video">audio-to-video</option>
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label for="promptTextB">Prompt (B)</label>
                                <textarea id="promptTextB" class="form-control" placeholder="Enter prompt for path B..." rows="3"></textarea>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- API Description -->
                <div class="form-group">
                    <div id="apiDescription" class="description-box">
                        Select API provider and version above
                    </div>
                </div>
                
                <!-- API Key -->
                <div class="form-group">
                    <label for="apiKey">API Key</label>
                    <input type="password" id="apiKey" class="form-control" value="" placeholder="pk-xxxxx">
                    <small style="color: var(--text-secondary); margin-top: 6px; display: block; font-size: 12px;">
                        üí° Usually starts with "pk-" prefix
                    </small>
                </div>
                
                <!-- Debug Tools -->
                <div class="btn-group">
                    <button type="button" class="btn btn-success btn-sm" onclick="testConnection()">
                        üîç Test
                    </button>
                    <button type="button" class="btn btn-secondary btn-sm" onclick="debugCheck()">
                        üêõ Debug
                    </button>
                    <button type="button" class="btn btn-secondary btn-sm" onclick="debugTasks()">
                        üìä Tasks
                    </button>
                </div>

                <!-- Text to Audio (MiniMax) -->
                <div id="minimaxSection" class="section hidden">
                    <div class="section-divider"></div>
                    <h4 style="font-size: 14px; font-weight: 500; margin-bottom: var(--spacing-md);">üéµ Text to Audio (MiniMax)</h4>
                    
                    <div class="form-group">
                        <label for="minimaxText">Text</label>
                        <textarea id="minimaxText" class="form-control" rows="3" placeholder="Enter text to synthesize..."></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label>Voice Clone (Optional)</label>
                        <div class="file-upload-area" id="minimaxCloneUpload" style="cursor:pointer; padding: var(--spacing-lg);">
                            <div class="upload-icon">üéµ</div>
                            <div class="upload-text">
                                <strong>Upload audio/video for voice cloning</strong>
                                <small>MP3/WAV/M4A/MP4 ‚Ä¢ 10-30 seconds recommended</small>
                            </div>
                            <input type="file" id="minimaxCloneFile" accept="audio/*,video/*" style="display:none;">
                            <div id="minimaxCloneFileName" style="margin-top: 8px; font-size: 12px; color: var(--text-secondary);"></div>
                        </div>
                        <div id="minimaxCloneStatus" style="margin-top:8px; font-size:12px; color:var(--text-secondary);"></div>
                        <audio id="minimaxClonePreview" controls style="display:none; margin-top:8px; width:100%;"></audio>
                    </div>
                    
                    <button type="button" class="btn btn-primary" onclick="minimaxTTS()">üîà Generate Audio</button>
                    <a id="minimaxAudioLink" style="display:none;margin-left:8px;" download>Download</a>
                    <audio id="minimaxAudioPlayer" controls style="display:none;margin-top:8px;width:100%;"></audio>
                </div>
            </div>
            </div>
            <!-- End Sidebar -->
            
            <!-- Main Area -->
            <div class="main-area">

            <!-- Step 2: Upload Images -->
            <div class="card">
                <div class="card-header">
                    <div>
                        <div class="card-title">
                            <span class="step-indicator">2</span>
                            Upload Images
                        </div>
                        <div class="card-subtitle">Select one or multiple images (max 50)</div>
                    </div>
                    <div id="imageCount" style="font-size: 13px; color: var(--text-secondary);"></div>
                </div>
                
                <div class="file-upload-area" id="uploadArea">
                    <div class="upload-icon">üìÅ</div>
                    <div class="upload-text">
                        <strong>Click to select or drag and drop</strong>
                        <small>JPG, PNG, GIF ‚Ä¢ Multi-select enabled ‚Ä¢ Max 50 images</small>
                    </div>
                    <input type="file" id="imageFile" accept="image/*" multiple>
                    <div id="imagePreview"></div>
                </div>
                
                <!-- Audio Upload (for audio-to-video) -->
                <div id="audioGroup" style="display: none; margin-top: var(--spacing-md);">
                    <label>üéµ Audio File (Required for audio-to-video)</label>
                    <div class="file-upload-area" id="audioUploadArea">
                        <div class="upload-icon">üéµ</div>
                        <div class="upload-text">
                            <strong>Click to select audio</strong>
                            <small>MP3, WAV, M4A supported</small>
                        </div>
                        <input type="file" id="audioFile" accept="audio/*">
                        <div id="audioFileName" style="margin-top: 8px; font-size: 12px; color: var(--text-secondary);"></div>
                    </div>
                </div>
            </div>

            <!-- Step 3: Prompt & Generate -->
            <div class="card">
                <div class="card-header">
                    <div>
                        <div class="card-title">
                            <span class="step-indicator">3</span>
                            Prompt & Generate
                        </div>
                        <div class="card-subtitle">Describe the video effect (optional)</div>
                    </div>
                </div>
                
                <!-- i2i Toggle -->
                <div class="form-group" style="display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--bg-secondary); border-radius: var(--radius-md); margin-bottom: var(--spacing-md);">
                    <label style="margin: 0; font-weight: 500; display: flex; align-items: center; gap: 8px;">
                        üé® Enable reference image
                    </label>
                    <label class="switch" style="margin-left: auto;">
                        <input type="checkbox" id="i2iToggle" onchange="toggleI2IMode()">
                        <span class="slider"></span>
                    </label>
                </div>

                <!-- Sticking Video Toggle -->
                <div class="form-group" style="display: flex; align-items: center; gap: 12px; padding: 12px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border-radius: var(--radius-md); margin-bottom: var(--spacing-md); color: white;">
                    <label style="margin: 0; font-weight: 500; display: flex; align-items: center; gap: 8px;">
                        üé¨ Sticking Video (AI Prompt Generation)
                    </label>
                    <label class="switch" style="margin-left: auto;">
                        <input type="checkbox" id="stickingVideoToggle" onchange="toggleStickingVideoMode()">
                        <span class="slider"></span>
                    </label>
                </div>
                <div id="stickingVideoHint" class="description-box" style="display: none; margin-bottom: var(--spacing-md);">
                    ‚ö° <strong>Sticking Video Mode:</strong> AI will generate 3 image variants from your reference, then create videos for each variant. This will produce 3 final videos.
                </div>

                <!-- Prompt (unified for both i2i and i2v) -->
                <div class="form-group">
                    <label for="promptText">
                        <span id="promptLabel">Prompt</span>
                        <span id="promptHint" style="font-size: 12px; color: var(--text-secondary);">(for video generation)</span>
                    </label>
                    <textarea id="promptText" class="form-control" rows="3" placeholder="E.g., a beautiful sunset scene with gentle waves..."></textarea>
                </div>

                <div class="btn-group">
                    <button class="btn btn-outline btn-sm" onclick="clearAllImages()">
                        üóëÔ∏è Clear Images
                    </button>
                    <button class="btn btn-outline btn-sm" onclick="downloadLogs()">
                        üì• Logs
                    </button>
                </div>

                <button class="btn btn-primary btn-lg" id="generateBtn" onclick="onStartButtonClick()">
                    <span id="generateBtnText">üöÄ Generate Videos</span>
                </button>
            </div>

            <!-- Processing Progress -->
            <div id="batchProgressArea" class="card" style="display: none;">
                <div class="card-header">
                    <div class="card-title">üìä Processing Progress</div>
                </div>
                <div style="margin-bottom: var(--spacing-sm);">
                    <span id="batchProgressText" style="font-size: 14px; font-weight: 500; color: var(--text-primary);">Processing...</span>
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="batchProgressFill"></div>
                </div>
                <div style="font-size: 12px; color: var(--text-secondary); margin-top: var(--spacing-sm);">
                    <span id="batchProgressDetail">Starting processing...</span>
                </div>
            </div>

            <!-- Batch Download -->
            <div class="card" id="downloadAllCard" style="display: none;">
                <div class="card-header">
                    <div class="card-title">üì¶ Batch Download</div>
                </div>
                <button class="btn btn-success" id="downloadAllBtn" onclick="downloadAllVideos()">
                    üì¶ Download All Completed Videos
                </button>
                <div style="margin-top: var(--spacing-sm); font-size: 12px; color: var(--text-secondary);">
                    üí° Videos will be named after their corresponding images
                </div>
            </div>

            <!-- Sticking Video Merge Download -->
            <div class="card" id="downloadStickingCard" style="display: none; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                <div class="card-header" style="border-bottom-color: rgba(255,255,255,0.2);">
                    <div class="card-title" style="color: white;">üé¨ Sticking Video Merge</div>
                </div>
                <button class="btn btn-success" id="downloadStickingBtn" onclick="downloadMergedStickingVideos()" style="background: white; color: #667eea; font-weight: 600;">
                    üí´ Merge & Download (Fade Effect)
                </button>
                <div style="margin-top: var(--spacing-sm); font-size: 12px; color: rgba(255,255,255,0.9); background: rgba(0,0,0,0.2); padding: 8px; border-radius: 4px;">
                    üí° Merges 3 variants with smooth fade transitions
                </div>
            </div>

            <!-- Task Management -->
            <div class="tasks-area" id="tasksArea" style="display: none;">
                <div class="card">
                    <div class="card-header">
                        <div class="card-title">üìä Task Management</div>
                    </div>
                    <div class="task-summary" id="taskSummary" style="padding: var(--spacing-md); background: var(--bg-secondary); border-radius: var(--radius-md); margin-bottom: var(--spacing-md);">
                        <div style="display: flex; justify-content: space-between; align-items: center; font-size: 13px;">
                            <span>üìà Total: <strong id="totalTasks">0</strong> tasks</span>
                            <span>‚è±Ô∏è Avg Time: <strong id="averageTime">-</strong></span>
                        </div>
                    </div>
                    <div id="tasksList"></div>
                </div>
            </div>

            <!-- Benchmark Results -->
            <div id="benchmarkResults" class="card" style="display:none;">
                <div class="card-header">
                    <div class="card-title">üß™ Benchmark Results (A vs B)</div>
                    <div style="display:flex; gap:var(--spacing-sm);">
                        <button class="btn btn-success btn-sm" id="downloadMergedBtn" onclick="downloadMergedBenchmark()">‚¨áÔ∏è Top Pair</button>
                        <button class="btn btn-outline btn-sm" id="downloadMergedAllBtn" onclick="downloadMergedAll()">‚¨áÔ∏è All (ZIP)</button>
                    </div>
                </div>
                <div id="benchmarkPairs" style="display:flex; flex-direction:column; gap:var(--spacing-md);"></div>
            </div>
            <!-- End Benchmark Results Card -->
            
            </div>
            <!-- End Main Area -->
            
        </div>
        <!-- End Content (two-column layout) -->
        
    </div>
    <!-- End Container -->

    <script>
        // Multi-task management
        let tasks = new Map(); // Store task information
        let imageQueue = []; // Image queue for processing
        let processingInterval = null; // Queue manager timer
        let globalTaskCounter = 0;
        let statusCheckInterval = null;
        let pendingSubmissions = 0; // Pending submissions not yet added to tasks Map
        
        // API Provider and version configuration
        const API_PROVIDERS = {
            'testing': {
                name: 'Testing (New Architecture)',
                description: 'Êñ∞ÊµãËØïÊû∂ÊûÑ - ÈúÄË¶Å SSH ÈößÈÅì',
                baseUrl: 'http://localhost:9580',
                apiKey: 'test-api-key-123456',
                versions: {
                    'v1': {
                        endpoints: {
                            'image-to-video': {
                                path: '/api/v1/generate/v0/image-to-video',
                                description: 'Image to Video - v1 (Êñ∞Êû∂ÊûÑ)',
                                name: 'Testing v1 (image-to-video)',
                                queryPath: '/api/v1/generate/v0/videos' // Êü•ËØ¢Ë∑ØÂæÑ
                            }
                        },
                        defaultEndpoint: 'image-to-video-v2',
                        description: 'Image to Video - v1 (Êñ∞ÊµãËØïÊû∂ÊûÑ)',
                        name: 'Testing v1'
                    }
                }
            },
            'original': {
                name: 'Original',
                description: 'Original Parrot API Server',
                baseUrl: 'https://qazwsxedcrf3g5h.pika.art',
                apiKey: 'pk_GW7ITxUVnC271AoJaasgdATrmzjl4OnQKTmD2j6tLZM',
                versions: {
                    'v0': {
                        endpoints: {
                            'image-to-video': {
                                path: '/generate/v0/image-to-video',
                                description: 'Image to Video - v0 (default)',
                                name: 'Original v0 (default)'
                            },
                            'image-to-video-new': {
                                path: '/generate/v0/image-to-video-new',
                                description: 'Image to Video - v0 (new endpoint)',
                                name: 'Original v0 (new)'
                            },
                            'image-to-video-inner': {
                                path: '/generate/v0/image-to-video-inner',
                                description: 'Image to Video - v0 (internal endpoint)',
                                name: 'Original v0 (internal)'
                            },
                            'image-to-video-nmd': {
                                path: '/generate/v0/image-to-video-nmd',
                                description: 'Image to Video - v0 (NMD endpoint)',
                                name: 'Original v0 (nmd)'
                            },
                            'image-to-video-v2': {
                                path: '/generate/v0/image-to-video-v2',
                                description: 'Image to Video - v2 (new version)',
                                name: 'Original v0 (v2)'
                            },
                            'audio-to-video': {
                                path: '/generate/v0/audio-to-video',
                                description: 'Image + Audio to Video - v0',
                                name: 'Original v0 (audio-to-video)'
                            }
                        },
                        defaultEndpoint: 'image-to-video',
                        description: 'Image to Video - v0',
                        name: 'Original v0'
                    }
                }
            },
            'staging': {
                name: 'Staging',
                description: 'Parrot Labs API Server',
                baseUrl: 'https://089e99349ace.pikalabs.app',
                apiKey: 'pk_fnOLPQFrhk96QscYG9hIUSw-Jn5ygl_ehSUWa9PvwZM',
                versions: {
                    'v2.2': {
                        endpoint: '/generate/2.2/i2v',
                        description: 'ÂúñÁâáËΩâË¶ñÈ†ª - v2.2 ÁâàÊú¨',
                        name: 'Staging v2.2'
                    }
                }
            },
            'candy': {
                name: 'Candy (Lipsync)',
                description: 'Pika Candy audio-to-video (lipsync)',
                baseUrl: 'https://candy-api.pika.art',
                apiKey: 'test-api-key-123456',
                versions: {
                    'v0': {
                        endpoints: {
                            'audio-to-video': {
                                path: '/api/v1/generate/v0/audio-to-video',
                                description: 'Image + Audio to Video (lipsync)',
                                name: 'Candy v0 (audio-to-video)'
                            }
                        },
                        defaultEndpoint: 'audio-to-video',
                        description: 'Audio to Video - v0',
                        name: 'Candy v0'
                    }
                }
            },
            'minimax': {
                name: 'Minimax text to audio',
                description: 'MiniMax ÊñáÊú¨ËΩâË™ûÈü≥',
                baseUrl: '',
                versions: {
                    'v1': {
                        endpoint: '/minimax/t2a',
                        description: 'ÊñáÊú¨ËΩâË™ûÈü≥ - v1',
                        name: 'Text to Audio'
                    }
                }
            }
        };

        // Áç≤ÂèñÁï∂ÂâçAPIÈÖçÁΩÆ - ÁèæÂú®ÊîØÊåÅÂãïÊÖãÈÅ∏Êìá
        function getCurrentAPIConfig() {
            const provider = document.getElementById('apiProvider')?.value || 'staging';
            const apiVersion = document.getElementById('apiVersion')?.value || 'v2.2';
            const endpointType = document.getElementById('endpointType')?.value;
            const versionConfig = API_PROVIDERS[provider]?.versions[apiVersion];
            
            let endpoint = '/generate/2.2/i2v'; // ÈªòË™ç
            
            if (versionConfig) {
                if (versionConfig.endpoints) {
                    // Original API v0 ÊîØÊåÅÂ§öÂÄãÁ´ØÈªû
                    const selectedEndpoint = endpointType && versionConfig.endpoints[endpointType] 
                        ? versionConfig.endpoints[endpointType] 
                        : versionConfig.endpoints[versionConfig.defaultEndpoint];
                    endpoint = selectedEndpoint.path;
                } else {
                    // ÂñÆ‰∏ÄÁ´ØÈªûÔºàStaging Êàñ MinimaxÔºâ
                    endpoint = versionConfig.endpoint;
                }
            }
            
            return {
                provider: provider,
                version: apiVersion,
                endpoint: endpoint,
                endpointType: endpointType
            };
        }

        // Êõ¥Êñ∞Êèê‰æõÂïÜÁâàÊú¨ÈÅ∏È†Ö
        function updateProviderVersions() {
            const providerSelect = document.getElementById('apiProvider');
            const versionSelect = document.getElementById('apiVersion');
            const endpointTypeGroup = document.getElementById('endpointTypeGroup');
            
            if (!providerSelect || !versionSelect) return;
            
            const selectedProvider = providerSelect.value || 'original';
            const providerConfig = API_PROVIDERS[selectedProvider];
            
            // Ê∏ÖÁ©∫ÁâàÊú¨ÈÅ∏È†Ö
            versionSelect.innerHTML = '';
            
            // Ê∑ªÂä†ÁâàÊú¨ÈÅ∏È†Ö
            if (providerConfig && providerConfig.versions) {
                Object.keys(providerConfig.versions).forEach(versionKey => {
                    const version = providerConfig.versions[versionKey];
                    const option = document.createElement('option');
                    option.value = versionKey;
                    option.textContent = version.name || versionKey;
                    versionSelect.appendChild(option);
                });
            }
            
            // Ëã•ÁÇ∫ originalÔºåÂº∑Âà∂ÈÅ∏Êìá v0
            if (selectedProvider === 'original') {
                versionSelect.value = 'v0';
            }

            // Ê™¢Êü•ÊòØÂê¶ÈúÄË¶ÅÈ°ØÁ§∫Á´ØÈªûÈ°ûÂûãÈÅ∏ÊìáÂô®
            if (endpointTypeGroup) {
                const selectedVersion = versionSelect.value;
                const versionConfig = providerConfig?.versions[selectedVersion];
                
                if (versionConfig && versionConfig.endpoints) {
                    // Original API v0 ÊîØÊåÅÂ§öÂÄãÁ´ØÈªû
                    endpointTypeGroup.style.display = 'block';
                } else {
                    // Staging API ÊàñÂÖ∂‰ªñÁâàÊú¨‰ΩøÁî®ÂñÆ‰∏ÄÁ´ØÈªû
                    endpointTypeGroup.style.display = 'none';
                }
            }
            
            // ÂàáÊèõ UIÔºöMinimax ‰∏ãÈö±ËóèÂúñÁâá/ÁîüÊàêË¶ñÈ†ªÁõ∏ÈóúÔºåÈ°ØÁ§∫ T2A ÂçÄÂ°ä
            const isMinimax = selectedProvider === 'minimax';
            const isCandy = selectedProvider === 'candy';
            document.getElementById('uploadArea')?.closest('.form-group')?.classList.toggle('hidden', isMinimax);
            document.getElementById('audioGroup')?.classList.toggle('hidden', isMinimax ? false : false);
            // Candy Ëàá Original/Staging È°ØÁ§∫‰∏ªÁîüÊàêÂçÄÂ°äÔºõMinimax Èö±Ëóè
            document.getElementById('promptText')?.closest('.form-group')?.classList.toggle('hidden', isMinimax);
            document.getElementById('generateBtn')?.classList.toggle('hidden', isMinimax);
            // È°ØÁ§∫/Èö±Ëóè minimax ÂçÄÂ°ä
            document.getElementById('minimaxSection')?.classList.toggle('hidden', !isMinimax);

            // Ëá™ÂãïÂ°´ÂÖ• Minimax ÊÜëË≠âÔºàÂÉÖÁï∂ÁïôÁ©∫ÊôÇÔºâ
            if (isMinimax) {
                try {
                    fetch('/minimax/env?full=1').then(r => r.json()).then(env => {
                        const gidEl = document.getElementById('minimaxGroupId');
                        const keyEl = document.getElementById('minimaxApiKey');
                        if (gidEl && !gidEl.value && env.group_id) gidEl.value = env.group_id;
                        if (keyEl && !keyEl.value && env.api_key) keyEl.value = env.api_key;
                    }).catch(() => {});
                } catch {}
            }

            // ÂêåÊ≠•Áï∂Ââç provider ÁöÑÈªòË™ç API Key Âà∞Ëº∏ÂÖ•Ê°ÜÔºàÈÅøÂÖç‰ΩøÁî®ÈåØË™§ provider ÁöÑ keyÔºâ
            try {
                const keyInput = document.getElementById('apiKey');
                if (keyInput) {
                    keyInput.value = providerConfig?.apiKey || '';
                }
            } catch {}

            // ÂàáÊèõÂà∞ candy ÊôÇÔºåÈ†êË®≠ÈÅ∏‰∏≠ audio-to-video ‰∏¶È°ØÁ§∫Èü≥Ë®ä‰∏äÂÇ≥
            if (selectedProvider === 'candy') {
                const et = document.getElementById('endpointType');
                if (et) et.value = 'audio-to-video';
                document.getElementById('audioGroup')?.classList.remove('hidden');
            }

            updateAPIDescription();
        }

        // Benchmark: Êõ¥Êñ∞ B Ë∑ØÁöÑÊèê‰æõÂïÜ/ÁâàÊú¨/Á´ØÈªûÈ°ØÁ§∫
        function updateProviderVersionsB() {
            const providerSelect = document.getElementById('apiProviderB');
            const versionSelect = document.getElementById('apiVersionB');
            const endpointTypeGroup = document.getElementById('endpointTypeGroupB');
            if (!providerSelect || !versionSelect) return;
            const selectedProvider = providerSelect.value || 'original';
            const providerConfig = API_PROVIDERS[selectedProvider];
            versionSelect.innerHTML = '';
            if (providerConfig && providerConfig.versions) {
                Object.keys(providerConfig.versions).forEach(versionKey => {
                    const version = providerConfig.versions[versionKey];
                    const option = document.createElement('option');
                    option.value = versionKey;
                    option.textContent = version.name || versionKey;
                    versionSelect.appendChild(option);
                });
            }

            // Default to original/v0 and endpoint image-to-video-v2
            if (selectedProvider === 'original') {
                versionSelect.value = 'v0';
                const et = document.getElementById('endpointType');
                if (et) et.value = 'image-to-video-v2';
            }
            if (endpointTypeGroup) {
                const selectedVersion = versionSelect.value;
                const versionConfig = providerConfig?.versions[selectedVersion];
                if (versionConfig && versionConfig.endpoints) {
                    endpointTypeGroup.style.display = 'block';
                } else {
                    endpointTypeGroup.style.display = 'none';
                }
            }
            // Ëá™ÂãïÂ°´ÂÖ• B ÁöÑÈªòË™ç key
            try {
                const keyInput = document.getElementById('apiKeyB');
                if (keyInput) keyInput.value = providerConfig?.apiKey || '';
            } catch {}
            updateAPIDescriptionB();
        }

        function getCurrentAPIConfigB() {
            const provider = document.getElementById('apiProviderB')?.value || 'staging';
            const apiVersion = document.getElementById('apiVersionB')?.value || 'v2.2';
            const endpointType = document.getElementById('endpointTypeB')?.value;
            const versionConfig = API_PROVIDERS[provider]?.versions[apiVersion];
            let endpoint = '/generate/2.2/i2v';
            if (versionConfig) {
                if (versionConfig.endpoints) {
                    const selectedEndpoint = endpointType && versionConfig.endpoints[endpointType]
                        ? versionConfig.endpoints[endpointType]
                        : versionConfig.endpoints[versionConfig.defaultEndpoint];
                    endpoint = selectedEndpoint.path;
                } else {
                    endpoint = versionConfig.endpoint;
                }
            }
            return { provider, version: apiVersion, endpoint, endpointType };
        }

        function updateAPIDescriptionB() {
            const provider = document.getElementById('apiProviderB')?.value;
            const version = document.getElementById('apiVersionB')?.value;
            const endpointType = document.getElementById('endpointTypeB')?.value;
            const descElement = document.getElementById('apiDescriptionB');
            if (!descElement || !provider || !version) return;
            const providerConfig = API_PROVIDERS[provider];
            const versionConfig = providerConfig?.versions[version];
            if (providerConfig && versionConfig) {
                // ÁÆÄÂåñÊèèËø∞ÊñáÂ≠ó
                let description = `${version}`;
                if (versionConfig.endpoints && endpointType) {
                    const endpointConfig = versionConfig.endpoints[endpointType];
                    if (endpointConfig) {
                        // Âè™ÊòæÁ§∫ endpoint Á±ªÂûãÔºå‰∏çÊòæÁ§∫ÂÆåÊï¥ÊèèËø∞
                        description += ` ‚Ä¢ ${endpointType}`;
                    }
                } else {
                    description = versionConfig.description;
                }
                descElement.textContent = description;
            }
        }

        // Ê†πÊìöÁ´ØÈªûÈ°ûÂûãÈ°ØÁ§∫/Èö±ËóèÈü≥È†ª‰∏äÂÇ≥
        function refreshAudioVisibility() {
            const endpointType = document.getElementById('endpointType')?.value;
            const audioGroup = document.getElementById('audioGroup');
            if (!audioGroup) return;
            if (endpointType === 'audio-to-video') {
                audioGroup.style.display = 'block';
            } else {
                audioGroup.style.display = 'none';
            }
        }
        document.getElementById('endpointType')?.addEventListener('change', refreshAudioVisibility);
        // ÂàùÊ¨°Ê∏≤ÊüìÊôÇ‰πüÂà∑Êñ∞‰∏ÄÊ¨°
        window.addEventListener('load', refreshAudioVisibility);

        // Êõ¥Êñ∞APIÊèèËø∞
        function updateAPIDescription() {
            const provider = document.getElementById('apiProvider')?.value;
            const version = document.getElementById('apiVersion')?.value;
            const endpointType = document.getElementById('endpointType')?.value;
            const descElement = document.getElementById('apiDescription');
            
            if (!descElement || !provider || !version) return;
            
            const providerConfig = API_PROVIDERS[provider];
            const versionConfig = providerConfig?.versions[version];
            
            if (providerConfig && versionConfig) {
                let description = `${providerConfig.description} - ${versionConfig.description}`;
                
                // Â¶ÇÊûúÊòØ Original API v0ÔºåÊ∑ªÂä†Á´ØÈªûÈ°ûÂûã‰ø°ÊÅØ
                if (versionConfig.endpoints && endpointType) {
                    const endpointConfig = versionConfig.endpoints[endpointType];
                    if (endpointConfig) {
                        description += ` (${endpointConfig.description})`;
                    }
                }
                
                descElement.textContent = description;
            }
        }
        
        // ‰ªªÂãôÊï∏ÊìöÁµêÊßã
        function createTask(videoId, promptText, imageName) {
            return {
                id: videoId,
                taskNumber: ++globalTaskCounter,
                status: 'waiting',
                progress: 0,
                promptText: promptText || '',
                imageName: imageName || '',
                startTime: null,
                endTime: null,
                duration: 0,
                // Êñ∞Â¢ûË®àÊôÇÂ≠óÊÆµ
                submittedAt: null,
                startedAt: null,
                finishedAt: null,
                waitDurationSec: null,
                genDurationSec: null,
                url: null,
                created: new Date(),
                retryCount: 0,
                benchmarkLabel: window.benchmarkLabel || ''
            };
        }

        // Êñá‰ª∂‰∏äÂÇ≥ËôïÁêÜ
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('imageFile');
        const imagePreview = document.getElementById('imagePreview');

            // ÈªûÊìä‰∏äÂÇ≥ÂçÄÂüüÔºàËã•ÈÅ∏Êìá audio-to-videoÔºåÈªûÊìäÈü≥È†ªÂçÄÂüü‰πüËÉΩËß∏ÁôºÔºâ
            uploadArea.addEventListener('click', () => {
                fileInput.click();
            });

            // Èü≥È†ªÂçÄÂüüÈªûÊìä/ÊãñÊãΩ
            const audioGroup = document.getElementById('audioGroup');
            const audioInput = document.getElementById('audioFile');
            const audioUploadArea = document.getElementById('audioUploadArea');
            const audioFileName = document.getElementById('audioFileName');
            
            audioUploadArea?.addEventListener('click', () => audioInput?.click());
            audioUploadArea?.addEventListener('dragover', (e) => {
                e.preventDefault();
                audioUploadArea.classList.add('drag-over');
            });
            audioUploadArea?.addEventListener('dragleave', () => audioUploadArea.classList.remove('drag-over'));
            audioUploadArea?.addEventListener('drop', (e) => {
                e.preventDefault();
                audioUploadArea.classList.remove('drag-over');
                if (e.dataTransfer?.files?.length) {
                    const f = e.dataTransfer.files[0];
                    audioInput.files = e.dataTransfer.files;
                    audioUploadArea.classList.add('has-file');
                    if (audioFileName) audioFileName.textContent = `Selected: ${f.name}`;
                }
            });
            audioInput?.addEventListener('change', () => {
                const f = audioInput.files?.[0];
                if (f) {
                    audioUploadArea?.classList.add('has-file');
                    if (audioFileName) audioFileName.textContent = `Selected: ${f.name}`;
                } else {
                    audioUploadArea?.classList.remove('has-file');
                    if (audioFileName) audioFileName.textContent = '';
                }
            });

        // ÊãñÊãΩ‰∏äÂÇ≥
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('drag-over');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('drag-over');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('drag-over');
            const files = Array.from(e.dataTransfer.files);
            if (files.length > 0) {
                handleMultipleFileSelect(files);
            }
        });

        // Êñá‰ª∂ÈÅ∏ÊìáËôïÁêÜ
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleMultipleFileSelect(Array.from(e.target.files));
            }
        });

        let selectedImages = []; // ÂÖ®Â±ÄËÆäÈáèÂ≠òÂÑ≤ÈÅ∏‰∏≠ÁöÑÂúñÁâá

        async function handleMultipleFileSelect(files) {
            // ÈÅéÊøæÂá∫ÂúñÁâáÊñá‰ª∂
            const imageFiles = files.filter(file => file.type.startsWith('image/'));
            
            if (imageFiles.length === 0) {
                showError('Please select image files');
                return;
            }

            // Ê™¢Êü•ÊòØÂê¶ÊúÉË∂ÖÈÅé50ÂºµÈôêÂà∂
            const totalAfterAdd = selectedImages.length + imageFiles.length;
            if (totalAfterAdd > 50) {
                const canAdd = 50 - selectedImages.length;
                if (canAdd <= 0) {
                    showError('Maximum 50 images allowed. Please remove some images first.');
                    return;
                } else {
                    showError(`Only ${canAdd} more image(s) can be added (max 50 total). Only first ${canAdd} will be added.`);
                    imageFiles.splice(canAdd); // Âè™‰øùÁïôÂâçcanAddÂÄãÊñá‰ª∂
                }
            }

            // Èò≤Ê≠¢ÈáçË§áÂúñÁâáÔºàÊ†πÊìöÊñá‰ª∂ÂêçÂíåÂ§ßÂ∞èÔºâ
            const newUniqueImages = [];
            imageFiles.forEach(newFile => {
                const isDuplicate = selectedImages.some(existingFile => 
                    existingFile.name === newFile.name && existingFile.size === newFile.size
                );
                if (!isDuplicate) {
                    newUniqueImages.push(newFile);
                }
            });

            // Ëá™ÂãïÂ∞á AVIF ËΩâÁÇ∫ JPG
            const finalFiles = [];
            for (const f of newUniqueImages) {
                if (isAvifFile(f)) {
                    try {
                        const converted = await convertAvifToJpeg(f);
                        finalFiles.push(converted);
                    } catch (e) {
                        // ËΩâÊèõÂ§±ÊïóÂâáÂõûÈÄÄ‰ΩøÁî®ÂéüÊñá‰ª∂
                        console.warn('AVIF to JPEG conversion failed, using original file:', e);
                        finalFiles.push(f);
                    }
                } else {
                    finalFiles.push(f);
                }
            }

            if (newUniqueImages.length === 0) {
                showError('All selected images are already added');
                return;
            }

            if (newUniqueImages.length < imageFiles.length) {
                const duplicateCount = imageFiles.length - newUniqueImages.length;
                showSuccess(`${newUniqueImages.length} image(s) added. ${duplicateCount} duplicate(s) skipped.`);
            }

            // Â∞áÊñ∞ÁöÑÂîØ‰∏ÄÂúñÁâáÔºàÂê´ËΩâÊèõÂæå JPGÔºâÊ∑ªÂä†Âà∞ÈÅ∏‰∏≠ÂàóË°®
            selectedImages = [...selectedImages, ...finalFiles];
            
            // Êõ¥Êñ∞ file input ÁöÑ files Â±¨ÊÄß
            updateFileInput();
            
            // È°ØÁ§∫È†êË¶Ω
            displayImagePreviews();
            
            // Êõ¥Êñ∞‰∏äÂÇ≥ÂçÄÂüüÁãÄÊÖã
            uploadArea.classList.add('has-file');
            updateUploadAreaText();
        }

        function isAvifFile(file) {
            return file && (file.type === 'image/avif' || /\.avif$/i.test(file.name || ''));
        }

        async function convertAvifToJpeg(file) {
            const url = URL.createObjectURL(file);
            try {
                // ÂÑ™ÂÖà‰ΩøÁî® createImageBitmap
                try {
                    const bitmap = await createImageBitmap(file);
                    const canvas = document.createElement('canvas');
                    canvas.width = bitmap.width;
                    canvas.height = bitmap.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(bitmap, 0, 0);
                    const jpegBlob = await new Promise((resolve, reject) => {
                        canvas.toBlob(b => b ? resolve(b) : reject(new Error('toBlob failed')), 'image/jpeg', 0.92);
                    });
                    const newName = (file.name || 'image').replace(/\.avif$/i, '.jpg');
                    return new File([jpegBlob], newName, { type: 'image/jpeg' });
                } catch (_) {
                    // ÂõûÈÄÄ‰ΩøÁî® HTMLImageElement
                    const image = await new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => resolve(img);
                        img.onerror = reject;
                        img.src = url;
                    });
                    const canvas = document.createElement('canvas');
                    canvas.width = image.width;
                    canvas.height = image.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(image, 0, 0);
                    const jpegBlob = await new Promise((resolve, reject) => {
                        canvas.toBlob(b => b ? resolve(b) : reject(new Error('toBlob failed')), 'image/jpeg', 0.92);
                    });
                    const newName = (file.name || 'image').replace(/\.avif$/i, '.jpg');
                    return new File([jpegBlob], newName, { type: 'image/jpeg' });
                }
            } finally {
                URL.revokeObjectURL(url);
            }
        }

        function updateFileInput() {
            // ÂâµÂª∫Êñ∞ÁöÑ DataTransfer Â∞çË±°‰æÜÊõ¥Êñ∞ file input
            const dt = new DataTransfer();
            selectedImages.forEach(file => {
                dt.items.add(file);
            });
            fileInput.files = dt.files;
        }

        function displayImagePreviews() {
            if (selectedImages.length === 0) {
                imagePreview.innerHTML = '';
                uploadArea.classList.remove('has-file');
                updateUploadAreaText();
                return;
            }

            let previewHTML = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px; margin-top: 15px;">';
            
            selectedImages.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const previewItem = document.createElement('div');
                    previewItem.style.cssText = 'position: relative; text-align: center; background: #f8f9fa; border-radius: 8px; padding: 8px;';
                    previewItem.innerHTML = `
                        <img src="${e.target.result}" style="width: 100%; height: 80px; object-fit: cover; border-radius: 6px;" alt="Preview ${index + 1}">
                        <div style="font-size: 11px; color: #666; margin-top: 4px; word-break: break-all;">${file.name}</div>
                        <div style="font-size: 10px; color: #999;">${(file.size / 1024 / 1024).toFixed(2)} MB</div>
                        <button onclick="removeImage(${index})" style="position: absolute; top: 2px; right: 2px; background: #ff4757; color: white; border: none; border-radius: 50%; width: 20px; height: 20px; font-size: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center;">√ó</button>
                    `;
                    
                    // Êõ¥Êñ∞È†êË¶ΩÂÆπÂô®
                    const container = document.getElementById('imagePreview');
                    if (!container.querySelector('.preview-grid')) {
                        container.innerHTML = '<div class="preview-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px; margin-top: 15px;"></div>';
                    }
                    const grid = container.querySelector('.preview-grid');
                    grid.appendChild(previewItem);
                };
                reader.readAsDataURL(file);
            });
        }

        function removeImage(index) {
            selectedImages.splice(index, 1);
            updateFileInput();
            
            // ÈáçÊñ∞È°ØÁ§∫ÊâÄÊúâÈ†êË¶Ω
            imagePreview.innerHTML = '';
            if (selectedImages.length > 0) {
                displayImagePreviews();
            } else {
                uploadArea.classList.remove('has-file');
            }
            updateUploadAreaText();
        }

        function updateUploadAreaText() {
            const uploadText = document.querySelector('.upload-text');
            const imageCountDiv = document.getElementById('imageCount');
            
            if (selectedImages.length === 0) {
                uploadText.innerHTML = '<strong>Click to select image(s)</strong> or drag and drop them here<br><small>Supports JPG, PNG, GIF formats ‚Ä¢ Multi-select enabled ‚Ä¢ Max 50 images</small>';
                imageCountDiv.textContent = '';
            } else {
                const remaining = 50 - selectedImages.length;
                if (remaining > 0) {
                    uploadText.innerHTML = `<strong>${selectedImages.length}/50 image(s) selected</strong><br><small>Click to add ${remaining} more images or drag and drop</small>`;
                    imageCountDiv.textContent = `${selectedImages.length}/50 images selected`;
                } else {
                    uploadText.innerHTML = `<strong>50/50 images selected (Maximum reached)</strong><br><small>Remove some images to add different ones</small>`;
                    imageCountDiv.textContent = `50/50 images selected (Max reached)`;
                }
            }
        }

        // i2i Mode Toggle
        function toggleI2IMode() {
            const i2iToggle = document.getElementById('i2iToggle');
            const stickingVideoToggle = document.getElementById('stickingVideoToggle');
            const generateBtnText = document.getElementById('generateBtnText');
            const promptHint = document.getElementById('promptHint');
            
            // Disable sticking video if i2i is enabled
            if (i2iToggle.checked) {
                stickingVideoToggle.checked = false;
                stickingVideoToggle.disabled = true;
                document.getElementById('stickingVideoHint').style.display = 'none';
                generateBtnText.textContent = 'üé® Generate Videos';
                promptHint.textContent = '(with reference image)';
            } else {
                stickingVideoToggle.disabled = false;
                generateBtnText.textContent = 'üöÄ Generate Videos';
                promptHint.textContent = '(for video generation)';
            }
        }

        // Sticking Video Mode Toggle
        function toggleStickingVideoMode() {
            const stickingVideoToggle = document.getElementById('stickingVideoToggle');
            const i2iToggle = document.getElementById('i2iToggle');
            const generateBtnText = document.getElementById('generateBtnText');
            const promptHint = document.getElementById('promptHint');
            const stickingVideoHint = document.getElementById('stickingVideoHint');
            
            if (stickingVideoToggle.checked) {
                // Disable i2i if sticking video is enabled
                i2iToggle.checked = false;
                i2iToggle.disabled = true;
                stickingVideoHint.style.display = 'block';
                generateBtnText.textContent = 'üé¨ Generate Sticking Videos (3x)';
                promptHint.textContent = '(AI will generate variants)';
            } else {
                i2iToggle.disabled = false;
                stickingVideoHint.style.display = 'none';
                generateBtnText.textContent = 'üöÄ Generate Videos';
                promptHint.textContent = '(for video generation)';
            }
        }

        // Process Sticking Video - Generate prompts and create multiple variants
        async function processStickingVideo(imageFile, videoPrompt) {
            console.log('üé¨ Starting Sticking Video process...');
            console.log(`üì∑ Image: ${imageFile.name}`);
            console.log(`üìù Video Prompt: ${videoPrompt}`);
            
            try {
                // Step 1: Call backend to generate prompts
                showSuccess(`ü§ñ Generating AI prompts for ${imageFile.name}...`);
                
                const formData = new FormData();
                formData.append('image', imageFile);
                formData.append('video_prompt', videoPrompt);
                
                console.log('üì§ [Gemini] Sending request to /generate-prompts...');
                console.log(`üì§ [Gemini] Image: ${imageFile.name}, Size: ${(imageFile.size / 1024).toFixed(2)}KB`);
                console.log(`üì§ [Gemini] Video Prompt: ${videoPrompt}`);
                
                const startTime = Date.now();
                const response = await fetch('/generate-prompts', {
                    method: 'POST',
                    body: formData
                });
                
                const elapsed = ((Date.now() - startTime) / 1000).toFixed(2);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error(`‚ùå [Gemini] Failed after ${elapsed}s: ${response.status}`);
                    throw new Error(`Prompt generation failed: ${response.status} - ${errorText}`);
                }
                
                const result = await response.json();
                console.log(`‚úÖ [Gemini] Completed in ${elapsed}s`);
                console.log('‚úÖ [Gemini] Generated prompts:', result);
                
                let imagePrompts = result.image_prompts || [];
                let videoPrompts = result.video_prompts || [];
                if (imagePrompts.length > 2) imagePrompts = imagePrompts.slice(0, 2);
                if (videoPrompts.length > 2) videoPrompts = videoPrompts.slice(0, 2);
                
                if (imagePrompts.length === 0 || videoPrompts.length === 0) {
                    throw new Error('No prompts generated');
                }
                
                showSuccess(`‚úÖ Generated ${imagePrompts.length} prompt variants! Starting baseline + variants...`);
                
                // Step 2: Âü∫Á∑ö(Áõ¥Êé• i2v) + ËÆäÈ´î(ÂÖ©Ê¢ùÔºöi2i‚Üíi2v)
                console.log('üöÄ Starting parallel processing: baseline + variants...');

                // Âü∫Á∑öÔºö‰ΩøÁî®‰∏äÂÇ≥ÂúñÁâá + ÂéüÂßãË¶ñÈ†ª Prompt ‰ΩúÁÇ∫Á¨¨1Ê¢ù
                const baselinePromise = (async () => {
                    try {
                        showSuccess('üé¨ [1/3] Submitting baseline video (reference image + original prompt)...');
                        window.stickingVideoOverridePrompt = videoPrompt;
                        window.stickingVideoVariantIndex = 1;
                        window.stickingVideoTotalVariants = imagePrompts.length + 1;
                        await submitTaskForStickingVideo(imageFile, videoPrompt, 1, imageFile.name, '(baseline)');
                        console.log('‚úÖ Baseline video submitted');
                    } finally {
                        window.stickingVideoOverridePrompt = null;
                        window.stickingVideoVariantIndex = null;
                        window.stickingVideoTotalVariants = null;
                    }
                })();
                
                // Âπ∂Ë°åÁîüÊàêÊâÄÊúâÂõæÁâáÂèò‰Ωì
                const i2iPromises = imagePrompts.map(async (imagePrompt, i) => {
                    console.log(`\n${'='.repeat(70)}`);
                    console.log(`üé® Processing variant ${i + 1}/${imagePrompts.length} (parallel)`);
                    console.log(`${'='.repeat(70)}`);
                    console.log(`üìù Image Prompt: ${imagePrompt.substring(0, 100)}...`);
                    
                    try {
                        showSuccess(`üé® [${i + 1}/${imagePrompts.length}] Generating image variant (parallel)...`);
                        const processedImage = await processI2I(imageFile, imagePrompt);
                        console.log(`‚úÖ Variant ${i + 1} image generated`);
                        return { processedImage, videoPrompt: videoPrompts[i], imagePrompt, index: i + 2 };
                    } catch (error) {
                        console.error(`‚ùå Variant ${i + 1} i2i failed:`, error);
                        throw error;
                    }
                });
                
                // Á≠âÂæÖÂü∫Á∑öËàá i2i ÂÆåÊàê
                const i2iResults = await Promise.allSettled([baselinePromise, ...i2iPromises]);
                
                // Âπ∂Ë°åÊèê‰∫§ÊâÄÊúâ i2v ‰ªªÂä°
                const i2vPromises = i2iResults.slice(1).map(async (result, i) => {
                    if (result.status === 'fulfilled') {
                        const { processedImage, videoPrompt, imagePrompt, index } = result.value; // 2 or 3
                        
                        console.log(`üìù Video Prompt ${index}: ${videoPrompt.substring(0, 100)}...`);
                        showSuccess(`üé¨ [${index}/3] Submitting video generation (parallel)...`);
                        
                        window.stickingVideoOverridePrompt = videoPrompt;
                        window.stickingVideoVariantIndex = index;
                        window.stickingVideoTotalVariants = imagePrompts.length;
                        
                        try {
                            await submitTaskForStickingVideo(processedImage, videoPrompt, index, imageFile.name, imagePrompt);
                            console.log(`‚úÖ Variant ${index} submitted`);
                        } finally {
                            window.stickingVideoOverridePrompt = null;
                            window.stickingVideoVariantIndex = null;
                            window.stickingVideoTotalVariants = null;
                        }
                    } else {
                        console.error(`‚ùå Variant ${i + 2} was skipped due to i2i failure`);
                        showError(`‚ùå Variant ${i + 2} failed: ${result.reason?.message || 'Unknown error'}`);
                    }
                });
                
                // Á≠âÂæÖÊâÄÊúâ i2v Êèê‰∫§ÂÆåÊàê
                await Promise.allSettled(i2vPromises);
                
                const successCount = i2iResults.filter(r => r.status === 'fulfilled').length; // include baseline
                showSuccess(`üéâ Submitted baseline + ${Math.max(0, successCount - 1)}/${imagePrompts.length} variants!`);
                return true;
                
            } catch (error) {
                console.error('‚ùå Sticking Video process failed:', error);
                showError(`‚ùå Sticking Video failed: ${error.message}`);
                throw error;
            }
        }

        // Modified submitTask for Sticking Video (submits a single variant)
        async function submitTaskForStickingVideo(processedImageFile, videoPrompt, variantIndex, originalImageName, imagePrompt) {
            const apiKey = document.getElementById('apiKey').value || '';
            const apiConfig = getCurrentAPIConfig();
            const MAX_RETRIES = 20;
            const RETRY_DELAY = 8000;
            
            let lastError = 'Unknown error';
            
            // Create task with variant info
            const tempId = `sticking-${Date.now()}-${Math.random()}`;
            const displayName = `[Sticking ${variantIndex}] ${originalImageName}`;
            const task = createTask(tempId, videoPrompt, displayName);
            task.stickingVideoMode = true;
            task.stickingVideoVariant = variantIndex;
            task.imagePrompt = imagePrompt || '';
            task.status = 'submitting';
            task.submittedAt = Date.now();
            task.apiProvider = apiConfig.provider;
            task.apiVersion = apiConfig.version;
            task.apiEndpointType = apiConfig.endpointType;
            task.apiKey = apiKey;
            tasks.set(tempId, task);
            createTaskCard(task);
            updateTaskCard(task);
            showTasksArea();
            
            // Submission logic (similar to submitTask)
            for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
                task.retryCount = attempt;
                updateTaskCard(task);
                
                try {
                    if (attempt > 0) {
                        console.log(`[Retry] Attempt ${attempt}/${MAX_RETRIES} for sticking video variant ${variantIndex}...`);
                        await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));
                    }
                    
                    const formData = new FormData();
                    formData.append('image', processedImageFile);
                    formData.append('provider', apiConfig.provider);
                    formData.append('version', apiConfig.version);
                    if (apiConfig.endpointType) formData.append('endpoint_type', apiConfig.endpointType);
                    if (videoPrompt.trim()) formData.append('promptText', videoPrompt.trim());
                    
                    const headers = {};
                    if (apiKey) headers['X-API-KEY'] = apiKey;
                    
                    // Ê†πÊçÆ provider ÂÜ≥ÂÆöËØ∑Ê±Ç URL
                    let requestUrl;
                    if (apiConfig.provider === 'testing') {
                        // Êñ∞Êû∂ÊûÑÈÄöËøá‰ª£ÁêÜËØ∑Ê±ÇÔºàËß£ÂÜ≥ CORS ÈóÆÈ¢òÔºâ
                        const apiPath = apiConfig.endpoint.replace(/^\//, '');
                        requestUrl = `/testing-proxy/${apiPath}`;
                    } else {
                        requestUrl = '/api/generate';
                    }
                    
                    console.log(`üì§ Submitting sticking video variant ${variantIndex} to API...`);
                    const response = await fetch(requestUrl, { method: 'POST', headers, body: formData });
                    const result = await response.json().catch(() => ({}));
                    
                    console.log('üìä API Response:', response.status, result);
                    
                    if (response.ok) {
                        const realId = result.video_id;
                        tasks.delete(task.id);
                        updateCardIds(task.id, realId);
                        task.id = realId;
                        task.status = 'waiting';
                        tasks.set(realId, task);
                        
                        if (!statusCheckInterval) {
                            try { startStatusCheck(); } catch {}
                        }
                        
                        updateTaskCard(task);
                        console.log(`‚úÖ Sticking video variant ${variantIndex} submitted: ${realId}`);
                        return;
                    }
                    
                    lastError = result.detail || result.message || `HTTP ${response.status}`;
                    const isRetryable = response.status === 429 || response.status >= 500;
                    
                    if (isRetryable && attempt < MAX_RETRIES) {
                        console.warn(`[Retry] Will retry variant ${variantIndex}. Error: ${lastError}`);
                        task.status = `retrying (${attempt + 1})`;
                        updateTaskCard(task);
                        continue;
                    } else {
                        task.status = 'failed';
                        updateTaskCard(task);
                        showError(lastError);
                        return;
                    }
                    
                } catch (error) {
                    lastError = error.message || 'Request error';
                    const isNetwork = lastError.toLowerCase().includes('network');
                    if (isNetwork && attempt < MAX_RETRIES) {
                        task.status = `retrying (${attempt + 1})`;
                        updateTaskCard(task);
                        continue;
                    }
                    task.status = 'failed';
                    updateTaskCard(task);
                    showError(lastError);
                    return;
                }
            }
            
            console.error(`‚ùå Sticking video variant ${variantIndex} failed after ${MAX_RETRIES} retries`);
            task.status = 'failed';
            updateTaskCard(task);
        }

        // Call Seedream API for i2i
        async function processI2I(imageFile, prompt) {
            const i2iStartTime = Date.now();
            console.log('üé® [Seedream] Starting i2i process...');
            console.log(`üìù [Seedream] Prompt: ${prompt.substring(0, 100)}...`);
            console.log(`üñºÔ∏è [Seedream] Input Image: ${imageFile.name} (${imageFile.type}), Size: ${(imageFile.size / 1024).toFixed(2)}KB`);
            
            return new Promise((resolve, reject) => {
                // Convert image to JPEG format (Seedream doesn't support webp)
                const img = new Image();
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    img.onload = async function() {
                        try {
                            // Create canvas and convert to JPEG
                            const canvas = document.createElement('canvas');
                            canvas.width = img.width;
                            canvas.height = img.height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0);
                            
                            // Convert to JPEG base64 (Seedream API needs data URL format)
                            const base64Image = canvas.toDataURL('image/jpeg', 0.95);
                            const conversionTime = ((Date.now() - i2iStartTime) / 1000).toFixed(2);
                            console.log(`üîÑ [Seedream] Converted to JPEG in ${conversionTime}s`);
                            
                            const seedreamPayload = {
                                model: "ep-20250921042133-t769x",
                                prompt: prompt,
                                image: base64Image,
                                size: "1440x2560",
                                watermark: false
                            };

                            console.log('üì§ [Seedream] Sending API request via proxy...');
                            
                            // Use our proxy server endpoint
                            const response = await fetch('/seedream/generate', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify(seedreamPayload)
                            });

                            const apiElapsed = ((Date.now() - i2iStartTime) / 1000).toFixed(2);
                            
                            if (!response.ok) {
                                const errorText = await response.text();
                                console.error(`‚ùå [Seedream] API failed after ${apiElapsed}s: ${response.status}`);
                                throw new Error(`Seedream API returned ${response.status}: ${errorText}`);
                            }

                            const result = await response.json();
                            console.log(`‚úÖ [Seedream] API responded in ${apiElapsed}s`);
                            console.log('üì¶ [Seedream] Response data:', result);
                            
                            if (result.data && result.data.length > 0) {
                                const imageData = result.data[0];
                                
                                // ÂÑ™ÂÖà‰ΩøÁî® base64 Êï∏ÊìöÔºàÂæåÁ´ØÂ∑≤‰∏ãËºâ‰∏¶ËΩâÊèõÔºâ
                                if (imageData.base64) {
                                    console.log('üì¶ [Seedream] Using base64 data from server (CORS bypass)');
                                    // Convert base64 to File
                                    const base64Data = imageData.base64.split(',')[1];
                                    const binaryData = atob(base64Data);
                                    const arrayBuffer = new Uint8Array(binaryData.length);
                                    for (let i = 0; i < binaryData.length; i++) {
                                        arrayBuffer[i] = binaryData.charCodeAt(i);
                                    }
                                    const blob = new Blob([arrayBuffer], { type: 'image/jpeg' });
                                    const newFile = new File([blob], `i2i_${imageFile.name}`, { type: 'image/jpeg' });
                                    const totalElapsed = ((Date.now() - i2iStartTime) / 1000).toFixed(2);
                                    console.log(`‚úÖ [Seedream] i2i complete in ${totalElapsed}s, Output: ${(newFile.size / 1024).toFixed(2)}KB`);
                                    resolve(newFile);
                                } else if (imageData.url) {
                                    // ÂõûÈÄÄÔºöÂòóË©¶Áõ¥Êé•‰∏ãËºâ URLÔºàÂèØËÉΩÊúâ CORS ÂïèÈ°åÔºâ
                                    console.log('üñºÔ∏è [Seedream] Generated image URL:', imageData.url);
                                    console.log('üì• [Seedream] Downloading generated image...');
                                    const imgResponse = await fetch(imageData.url);
                                    if (!imgResponse.ok) {
                                        throw new Error(`Failed to download generated image: ${imgResponse.status}`);
                                    }
                                    const blob = await imgResponse.blob();
                                    const newFile = new File([blob], `i2i_${imageFile.name}`, { type: 'image/jpeg' });
                                    const totalElapsed = ((Date.now() - i2iStartTime) / 1000).toFixed(2);
                                    console.log(`‚úÖ [Seedream] i2i complete in ${totalElapsed}s, Output: ${(newFile.size / 1024).toFixed(2)}KB`);
                                    resolve(newFile);
                                } else {
                                    throw new Error('No image data (base64 or URL) returned');
                                }
                            } else {
                                throw new Error('Seedream API returned no image data');
                            }
                        } catch (error) {
                            const errorElapsed = ((Date.now() - i2iStartTime) / 1000).toFixed(2);
                            console.error(`‚ùå [Seedream] i2i failed after ${errorElapsed}s:`, error);
                            reject(error);
                        }
                    };
                    
                    img.onerror = (error) => {
                        console.error('‚ùå Image loading error:', error);
                        reject(new Error('Failed to load image for conversion'));
                    };
                    
                    img.src = e.target.result;
                };
                
                reader.onerror = (error) => {
                    console.error('‚ùå FileReader error:', error);
                    reject(error);
                };
                
                reader.readAsDataURL(imageFile);
            });
        }

        function clearAllImages() {
            if (selectedImages.length === 0) {
                showError('No images to clear');
                return;
            }
            
            if (confirm(`Are you sure you want to remove all ${selectedImages.length} selected image(s)?`)) {
                selectedImages = [];
                updateFileInput();
                imagePreview.innerHTML = '';
                uploadArea.classList.remove('has-file');
                updateUploadAreaText();
                showSuccess('All images cleared');
            }
        }

        // ÂèñÂæó‰ΩµÁôº‰∏äÈôêÔºàËã•UIÂ∑≤ÁßªÈô§ÔºåÊèê‰æõÂÆâÂÖ®ÈªòË™çÂÄºÔºâ
        function getConcurrencyLimit() {
            const el = document.getElementById('concurrencyLimit');
            const n = parseInt(el?.value || '10', 10);
            if (Number.isNaN(n) || n <= 0) return 10;
            return Math.min(n, 20);
        }

        // ÁîüÊàêË¶ñÈ†ª - ‰ΩøÁî®Êô∫ËÉΩÈöäÂàóÂíå‰ΩµÁôºÊéßÂà∂
        async function generateVideo() {
            const apiKey = document.getElementById('apiKey').value;
            const concurrencyLimit = getConcurrencyLimit();
            const imageFiles = Array.from(document.getElementById('imageFile').files);

            // È©óË≠âËº∏ÂÖ•
            if (!apiKey) {
                showError('Please enter your API Key');
                return;
            }
            if (imageFiles.length === 0) {
                showError('Please select at least one image file');
                return;
            }

            // ÂàùÂßãÂåñ
            clearMessages();
            setButtonLoading(true);
            showBatchProgress();
            
            // Â∞áÊâÄÊúâÂúñÁâáÊîæÂÖ•ÈöäÂàó
            imageQueue = [...imageFiles];
            const totalTasks = imageQueue.length;
            
            console.log('=== New Concurrent Task Submission ===');
            console.log('Selected images:', totalTasks);
            console.log('Concurrency Limit:', concurrencyLimit);
            console.log('====================================');
            
            showSuccess(`üöÄ Queued ${totalTasks} image(s) for generation...`);
            
            // ÂïüÂãïÈöäÂàóÁÆ°ÁêÜÂô®
            if (processingInterval) clearInterval(processingInterval);
            processingInterval = setInterval(() => queueManager(concurrencyLimit, totalTasks), 2000); // ÊØè2ÁßíÊ™¢Êü•‰∏ÄÊ¨°
            
            // Á´ãÂç≥Ëß∏Áôº‰∏ÄÊ¨°‰ª•Âø´ÈÄüÂïüÂãï
            queueManager(concurrencyLimit, totalTasks);

            // ÂïüÂãïÁãÄÊÖãËº™Ë©¢
            if (!statusCheckInterval) {
                startStatusCheck();
            }
        }
        
        // ËºîÂä©ÂáΩÊï∏ÔºöÊõ¥Êñ∞‰ªªÂãôÂç°ÁâáÂèäÂÖ∂ÊâÄÊúâÂ≠êÂÖÉÁ¥†ÁöÑID
        function updateCardIds(oldId, newId) {
            const card = document.getElementById(`task-${oldId}`);
            if (!card) return;

            // ÈÅ∏ÊìáÊâÄÊúâÂ∏∂ÊúâËàäIDÁöÑÂÖÉÁ¥†
            const elementsToUpdate = card.querySelectorAll(`[id$="-${oldId}"]`);
            
            elementsToUpdate.forEach(el => {
                el.id = el.id.replace(oldId, newId);
            });
            
            // Êõ¥Êñ∞‰∏ªÂç°ÁâáÁöÑID
            card.id = `task-${newId}`;
            
            // ÁâπÂà•ËôïÁêÜonclick‰∫ã‰ª∂
            const downloadLink = card.querySelector(`a[onclick*="'${oldId}'"]`);
            if (downloadLink) {
                downloadLink.setAttribute('onclick', `downloadTaskVideo('${newId}')`);
            }
        }

        // ÈöäÂàóÁÆ°ÁêÜÂô®
        function queueManager(_limit, totalTasks) {
            // ÊØèÊ¨°ÂãïÊÖãÂèñÂæó‰ΩµÁôº‰∏äÈôêÔºàUIÂèØËÉΩÂ∑≤Èö±ËóèÔºâ
            const concurrencyLimit = getConcurrencyLimit();
            const activeTasks = Array.from(tasks.values()).filter(t => !['completed', 'failed', 'finished', 'error'].includes(t.status)).length;
            const effectiveActive = activeTasks + pendingSubmissions; // ÊääÂ∞öÊú™Âä†ÂÖ• Map ÁöÑÊèê‰∫§‰πüÁÆóÈÄ≤Âéª
            const canSubmitCount = concurrencyLimit - effectiveActive;
            
            console.log(`[Queue Manager] Active (in Map): ${activeTasks}, Pending Submissions: ${pendingSubmissions}, Queue: ${imageQueue.length}, Can Submit: ${canSubmitCount}`);
            
            if (canSubmitCount > 0 && imageQueue.length > 0) {
                const itemsToSubmit = imageQueue.splice(0, canSubmitCount);
                console.log(`[Queue Manager] Submitting ${itemsToSubmit.length} new tasks.`);
                
                showSuccess(`Submitting ${itemsToSubmit.length} new tasks...`);

                // Â∏∂Êúâ‰∫§ÈåØÂª∂ÈÅ≤Âú∞Êèê‰∫§‰ªªÂãôÔºå‰ª•ÈÅøÂÖçË´ãÊ±ÇÈ¢®Êö¥
                (async () => {
                    for (const imageFile of itemsToSubmit) {
                        pendingSubmissions++; // Ê®ôË®òÁÇ∫Ê≠£Âú®Êèê‰∫§
                        submitTask(imageFile).finally(() => {
                            pendingSubmissions--; // Êèê‰∫§ÁµêÊùüÔºàÊàêÂäüÊàñÂ§±ÊïóÔºâ
                        });
                        await new Promise(resolve => setTimeout(resolve, 500)); // Â¢ûÂä†Âà∞500ms
                    }
                })();
            }
            
            const submittedCount = totalTasks - imageQueue.length;
            const completedCount = submittedCount - activeTasks;
            updateBatchProgress(completedCount, totalTasks, null, null, `Submitted: ${submittedCount}/${totalTasks} | Active: ${effectiveActive}`);

            // Â¶ÇÊûúÈöäÂàóÁÇ∫Á©∫‰∏îÊ≤íÊúâÊ¥ªÂãï‰ªªÂãôÔºåÂâáÂÅúÊ≠¢
            if (imageQueue.length === 0 && activeTasks === 0) {
                console.log('[Queue Manager] All tasks completed. Stopping manager.');
                clearInterval(processingInterval);
                processingInterval = null;
                setButtonLoading(false);
                
                const finalCompletedCount = Array.from(tasks.values()).filter(t => ['completed', 'finished'].includes(t.status)).length;
                showSuccess(`üéâ All ${finalCompletedCount}/${totalTasks} tasks processed!`);
                updateBatchProgress(finalCompletedCount, totalTasks, null, null, `All tasks processed!`);

                setTimeout(() => {
                    hideBatchProgress();
                }, 5000);
            }
        }

        // Êèê‰∫§ÂñÆÂÄã‰ªªÂãôÔºåÂåÖÂê´ÈáçË©¶ÈÇèËºØ
        async function submitTask(imageFile) {
            // Check if sticking video mode is enabled
            const stickingVideoToggle = document.getElementById('stickingVideoToggle');
            const stickingVideoEnabled = stickingVideoToggle?.checked || false;
            
            // Check if i2i mode is enabled
            const i2iToggle = document.getElementById('i2iToggle');
            const i2iEnabled = i2iToggle?.checked || false;
            
            // Get the unified prompt
            const promptText = (window.benchmarkOverridePrompt ?? document.getElementById('promptText').value) || '';
            
            // Handle Sticking Video Mode
            if (stickingVideoEnabled && !window.benchmarkOverridePrompt) {
                if (!promptText.trim()) {
                    showError('‚ùå Sticking Video mode requires a video prompt!');
                    return;
                }
                
                console.log('üé¨ Sticking Video mode detected - processing...');
                try {
                    await processStickingVideo(imageFile, promptText);
                    return; // processStickingVideo handles everything
                } catch (error) {
                    console.error('‚ùå Sticking Video failed:', error);
                    showError(`‚ùå Sticking Video failed: ${error.message}`);
                    return;
                }
            }
            
            let processedImageFile = imageFile;

            if (i2iEnabled) {
                if (!promptText.trim()) {
                    showError('‚ùå i2i mode is enabled but no prompt provided!');
                    return;
                }

                // Show i2i processing notification
                showSuccess(`üé® Processing i2i for ${imageFile.name}... Please wait.`);
                
                try {
                    // Process image through Seedream first, using the same prompt
                    processedImageFile = await processI2I(imageFile, promptText);
                    console.log(`‚úÖ i2i processing complete. Original: ${imageFile.name}, Processed: ${processedImageFile.name}`);
                    showSuccess(`‚úÖ i2i completed for ${imageFile.name}, now generating video...`);
                } catch (error) {
                    showError(`‚ùå i2i processing failed: ${error.message}`);
                    console.error('i2i processing error:', error);
                    return;
                }
            }

            // Ëã•Êúâ Benchmark Ë¶ÜËìãÔºå‰ΩøÁî®Ë¶ÜËìãÂèÉÊï∏
            const apiKey = (window.benchmarkOverrideApiKey ?? document.getElementById('apiKey').value) || '';
            const apiConfig = window.benchmarkOverrideConfig || getCurrentAPIConfig();
            const MAX_RETRIES = 20; // ÊèêÈ´òÈáçË©¶‰∏äÈôê
            const RETRY_DELAY = 8000; // 8ÁßíÈáçË©¶ÈñìÈöî

            let lastError = 'Unknown error';

            // ÂâµÂª∫‰∏ÄÂÄãËá®ÊôÇ‰ªªÂãôÁî®ÊñºUIÂ±ïÁ§∫
            const tempId = `submitting-${Date.now()}-${Math.random()}`;
            const displayName = i2iEnabled ? `[i2i] ${imageFile.name}` : imageFile.name;
            const task = createTask(tempId, promptText, displayName);
            task.i2iEnabled = i2iEnabled;
            task.i2iPrompt = i2iEnabled ? promptText : '';
            task.status = 'submitting';
            task.submittedAt = Date.now();
            // Â≠òÂÑ≤APIÈÖçÁΩÆ‰ø°ÊÅØÂà∞‰ªªÂãô
            task.apiProvider = apiConfig.provider;
            task.apiVersion = apiConfig.version;
            task.apiEndpointType = apiConfig.endpointType;
            task.apiKey = apiKey;
            tasks.set(tempId, task);
            createTaskCard(task);
            updateTaskCard(task);
            
            // Êõ¥Êñ∞API‰ø°ÊÅØÈ°ØÁ§∫
            const apiInfoElement = document.getElementById(`api-info-${tempId}`);
            if (apiInfoElement) {
                const providerConfig = API_PROVIDERS[apiConfig.provider];
                const baseUrl = providerConfig.baseUrl;
                const keyDisplay = apiKey ? `${apiKey.substring(0, 6)}...${apiKey.substring(apiKey.length - 6)}` : 'Server Default';
                const endpointInfo = apiConfig.endpointType ? ` | üéØ ${apiConfig.endpointType}` : '';
                apiInfoElement.innerHTML = `üìç ${apiConfig.provider} | üåê ${baseUrl} | üîó ${apiConfig.version}${endpointInfo} | üîë ${keyDisplay}`;
            }
            
            showTasksArea();

            // audio-to-video ÈúÄË¶ÅÈü≥È†ªÊñá‰ª∂ÔºåÁÑ°ÂâáÁõ¥Êé•Â§±Êïó‰∏¶ËøîÂõû
            if (apiConfig.endpointType === 'audio-to-video') {
                const audioInputPre = document.getElementById('audioFile');
                const audioFilePre = audioInputPre?.files?.[0];
                if (!audioFilePre) {
                    const errMsg = 'audio-to-video requires an audio file';
                    lastError = errMsg;
                    task.status = 'failed';
                    updateTaskCard(task);
                    showError(errMsg);
                    return;
                }
            }
            
            for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
                task.retryCount = attempt;
                updateTaskCard(task);
                
                try {
                    if (attempt > 0) {
                        console.log(`[Retry] Attempt ${attempt}/${MAX_RETRIES} for ${imageFile.name}...`);
                        await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));
                    }

                    // Ê∫ñÂÇô FormData Âíå headers
                    const formData = new FormData();
                    // Use processed image if i2i was enabled
                    formData.append('image', processedImageFile);
                    formData.append('provider', apiConfig.provider);
                    formData.append('version', apiConfig.version);
                    if (apiConfig.endpointType) formData.append('endpoint_type', apiConfig.endpointType);
                    // Â¶ÇÊûúÈÅ∏ÊìáÁöÑÊòØ audio-to-videoÔºåÈôÑÂ∏∂Èü≥È†ªÊñá‰ª∂
                    if (apiConfig.endpointType === 'audio-to-video') {
                        const audioInput = document.getElementById('audioFile');
                        const audioFile = audioInput?.files?.[0];
                        if (!audioFile) {
                            showError('audio-to-video requires an audio file');
                            throw new Error('Missing audio file');
                        }
                        formData.append('audio', audioFile);
                    }
                    if (promptText.trim()) formData.append('promptText', promptText.trim());
                    const headers = {};
                    if (apiKey) headers['X-API-KEY'] = apiKey; // Â¶ÇÊûúÁî®Êà∑Êèê‰æõ‰∫ÜAPI KeyÂ∞±‰ΩøÁî®ÔºåÂê¶Âàô‰ΩøÁî®ÊúçÂä°Âô®ÈªòËÆ§ÁöÑ
                    
            // Ë®òÈåÑË©≥Á¥∞ÁöÑAPIË™øÁî®‰ø°ÊÅØ
                    const providerConfig = API_PROVIDERS[apiConfig.provider];
                    const baseUrl = providerConfig.baseUrl;
                    const fullUrl = baseUrl + apiConfig.endpoint;
                    
                    console.log('=== Video Generation API Call ===');
                    console.log('üìç Provider:', apiConfig.provider);
                    console.log('üîó Version:', apiConfig.version);
                    if (apiConfig.endpointType) console.log('üéØ Endpoint Type:', apiConfig.endpointType);
                    console.log('üåê Base URL:', baseUrl);
                    console.log('üéØ Endpoint:', apiConfig.endpoint);
                    console.log('üîó Full URL:', fullUrl);
                    console.log('üöÄ Proxy Endpoint:', '/api/generate');
                    console.log('üîë API Key:', apiKey ? `${apiKey.substring(0, 8)}...${apiKey.substring(apiKey.length - 8)}` : 'Using default from server');
                    console.log('üìù Prompt:', promptText.trim() || 'No prompt');
                    console.log('üìé Image:', processedImageFile.name, `(${(processedImageFile.size / 1024).toFixed(2)} KB)${i2iEnabled ? ' [i2i processed]' : ''}`);
                    if (i2iEnabled) {
                        console.log('üé® Original Image:', imageFile.name, `(${(imageFile.size / 1024).toFixed(2)} KB)`);
                    }
                    console.log('üìã Headers:', headers);
                    
                    // Ê†πÊçÆ provider ÂÜ≥ÂÆöËØ∑Ê±Ç URL
                    let requestUrl;
                    if (apiConfig.provider === 'testing') {
                        // Êñ∞Êû∂ÊûÑÈÄöËøá‰ª£ÁêÜËØ∑Ê±ÇÔºàËß£ÂÜ≥ CORS ÈóÆÈ¢òÔºâ
                        // Â∞Ü /api/v1/generate/v0/image-to-video ËΩ¨Êç¢‰∏∫ /testing-proxy/api/v1/generate/v0/image-to-video
                        const apiPath = apiConfig.endpoint.replace(/^\//, ''); // ÂéªÊéâÂºÄÂ§¥ÁöÑ /
                        requestUrl = `/testing-proxy/${apiPath}`;
                    } else {
                        // ÂÖ∂‰ªñ provider ÈÄöËøá‰ª£ÁêÜ
                        requestUrl = '/api/generate';
                    }
                    
                    const response = await fetch(requestUrl, { method: 'POST', headers, body: formData });
                    const result = await response.json().catch(() => ({}));
                    
                    // Ë®òÈåÑÈüøÊáâ‰ø°ÊÅØ
                    console.log('=== API Response ===');
                    console.log('üìä Status:', response.status, response.statusText);
                    console.log('üìù Result:', result);

                    if (response.ok) {
                        // È°ØÁ§∫Ë©≥Á¥∞ÁöÑÊàêÂäü‰ø°ÊÅØ
                    const successDetails = `
‚úÖ Video Generation Started Successfully!

üÜî Video ID: ${result.video_id}
üìç Provider: ${apiConfig.provider}${window.benchmarkLabel ? ` (${window.benchmarkLabel})` : ''}
üîó Version: ${apiConfig.version}
${apiConfig.endpointType ? `üéØ Endpoint Type: ${apiConfig.endpointType}` : ''}
üåê Base URL: ${baseUrl}
üéØ Endpoint: ${apiConfig.endpoint}
üîó Full URL: ${fullUrl}
üîë API Key: ${apiKey ? `${apiKey.substring(0, 8)}...${apiKey.substring(apiKey.length - 8)}` : 'Server Default'}
üìù Prompt: ${(window.benchmarkOverridePrompt ?? promptText).trim() || 'No prompt provided'}
üìé Image: ${processedImageFile.name} (${(processedImageFile.size / 1024).toFixed(2)} KB)${i2iEnabled ? ' [i2i processed from ' + imageFile.name + ']' : ''}
üèóÔ∏è Worker: ${result.worker || 'Not specified'}
üìä Status: ${result.status || 'pending'}
‚è∞ Time: ${new Date().toLocaleTimeString()}
                        `;
                        
                        console.log('=== Video Generation Success ===');
                        console.log(successDetails);
                        console.log(`‚úÖ Task submitted successfully: ${result.video_id} for ${imageFile.name}`);
                        
                        // Êèê‰∫§ÊàêÂäüÔºåÁî®ÁúüÂØ¶IDÊõøÊèõËá®ÊôÇID
                        const realId = result.video_id;
                        const oldApiInfo = document.getElementById(`api-info-${task.id}`);
                        const apiInfoContent = oldApiInfo ? oldApiInfo.innerHTML : '';
                        
                        tasks.delete(task.id); // Âà™Èô§Ëá®ÊôÇ‰ªªÂãô
                        
                        updateCardIds(task.id, realId); // Êõ¥Êñ∞DOM‰∏≠ÊâÄÊúâÁõ∏ÈóúID
                        
                        task.id = realId; // Êõ¥Êñ∞JSÂ∞çË±°ÁöÑID
                        task.status = 'waiting'; // ÈáçÁΩÆÁãÄÊÖã
                        // Â≠òÂÑ≤Ë©≥Á¥∞‰ø°ÊÅØÂà∞‰ªªÂãôÂ∞çË±°
                        task.submissionDetails = {
                            videoId: result.video_id,
                            provider: apiConfig.provider,
                            baseUrl: baseUrl,
                            endpoint: apiConfig.endpoint,
                            fullUrl: fullUrl,
                            apiKey: apiKey ? `${apiKey.substring(0, 8)}...${apiKey.substring(apiKey.length - 8)}` : 'Server Default',
                            prompt: promptText.trim() || 'No prompt provided',
                            imageInfo: `${processedImageFile.name} (${(processedImageFile.size / 1024).toFixed(2)} KB)${i2iEnabled ? ' [i2i]' : ''}`,
                            originalImageInfo: i2iEnabled ? `${imageFile.name} (${(imageFile.size / 1024).toFixed(2)} KB)` : null,
                            worker: result.worker || 'Not specified',
                            submittedAt: new Date().toLocaleTimeString()
                        };
                        tasks.set(realId, task); // Áî®ÁúüÂØ¶IDÂ≠òÂÑ≤
                        
                        // Á¢∫‰øùËº™Ë©¢Â∑≤ÂïüÂãï
                        if (!statusCheckInterval) {
                            try { startStatusCheck(); } catch {}
                        }

                        updateTaskCard(task); // Áî®Êñ∞IDÊõ¥Êñ∞‰∏ÄÊ¨°UI
                        
                        // ÊÅ¢Âæ©API‰ø°ÊÅØÈ°ØÁ§∫‰∏¶Ê∑ªÂä†Ë©≥Á¥∞‰ø°ÊÅØ
                        const newApiInfo = document.getElementById(`api-info-${realId}`);
                        if (newApiInfo) {
                            const enhancedApiInfo = `
üìç ${apiConfig.provider} | üåê ${baseUrl} | üîó ${apiConfig.version} | üîë ${apiKey ? `${apiKey.substring(0, 6)}...${apiKey.substring(apiKey.length - 6)}` : 'Server Default'}
<br><small>üèóÔ∏è Worker: ${result.worker || 'Not specified'} | ‚è∞ ${new Date().toLocaleTimeString()}</small>
                            `;
                            newApiInfo.innerHTML = enhancedApiInfo;
                        }
                        return; // ÊàêÂäüÔºåÈÄÄÂá∫Âæ™Áí∞
                    }
                    
                    lastError = result.detail || result.message || `HTTP ${response.status}`;
                    // Â¢ûÂä†Â∞çÁ∂≤Áµ°ÈåØË™§ÁöÑÂà§Êñ∑
                    if (response.status === 0 || !response.status) {
                        lastError = "Network Error. Is the proxy server running?";
                    }
                    const isRetryable = response.status === 429 || response.status >= 500;

                    if (isRetryable && attempt < MAX_RETRIES) {
                        console.warn(`[Retry] Will retry for ${imageFile.name}. Error: ${lastError}`);
                        task.status = `retrying (${attempt + 1})`;
                        updateTaskCard(task);
                        continue;
                    } else {
                        // ÈùûÂèØÈáçË©¶ÈåØË™§ÔºåÁõ¥Êé•Ê®ôË®òÂ§±Êïó‰∏¶ÁµêÊùü
                        task.status = 'failed';
                        updateTaskCard(task);
                        showError(lastError);
                        return;
                    }

                } catch (error) {
                    lastError = error.message || 'Request error';
                    // ÂÉÖÈáùÂ∞çÁ∂≤Ë∑ØÈ°ûÈåØË™§ÈáçË©¶
                    const isNetwork = lastError.toLowerCase().includes('network');
                    if (isNetwork && attempt < MAX_RETRIES) {
                        task.status = `retrying (${attempt + 1})`;
                        updateTaskCard(task);
                        continue;
                    }
                    // ÈùûÁ∂≤Ë∑ØÈåØË™§Áõ¥Êé•Â§±Êïó
                    task.status = 'failed';
                    updateTaskCard(task);
                    showError(lastError);
                    return;
                }
            }

            // ÊâÄÊúâÈáçË©¶Â§±Êïó
            console.error(`‚ùå Task failed for ${imageFile.name} after ${MAX_RETRIES} retries. Final error: ${lastError}`);
            task.status = 'failed';
            updateTaskCard(task);
        }

        // Ê™¢Êü•Ë¶ñÈ†ªÁãÄÊÖã
        async function checkVideoStatus() {
            const baseUrl = '/';  // ‰ΩøÁî®Êú¨Âú∞‰ª£ÁêÜ
            
            // ÂÖÅË®±Êú™Ëº∏ÂÖ• API Key ÊôÇ‰ªçËº™Ë©¢ÔºåÂæåÁ´ØÊúÉ‰ΩøÁî®È†êË®≠ keyÔºàËã•ÊúâÔºâ
            
            const activeTasks = Array.from(tasks.values()).filter(task => 
                !['finished', 'completed', 'failed', 'error'].includes(task.status)
            );
            
            if (activeTasks.length === 0) {
                stopStatusCheck();
                return;
            }

            // Ê™¢Êü•ÊâÄÊúâÊ¥ªË∫ç‰ªªÂãô
            for (const task of activeTasks) {
                try {
                    // ‰ΩøÁî®‰ªªÂä°Ëá™Â∑±‰øùÂ≠òÁöÑproviderÂíåapiKeyÔºåËÄå‰∏çÊòØÂΩìÂâçUIÈÄâ‰∏≠ÁöÑ
                    const taskProvider = task.apiProvider || 'original';
                    const taskApiKey = task.apiKey || '';
                    
                    // Ê∫ñÂÇô headers
                    const headers = {
                        'Accept': 'application/json'
                    };
                    if (taskApiKey) {
                        headers['X-API-KEY'] = taskApiKey;
                    }
                    
                    // Ê†πÊçÆ provider Á°ÆÂÆöÊü•ËØ¢Ë∑ØÂæÑ
                    let queryUrl;
                    if (taskProvider === 'testing') {
                        // Êñ∞Êû∂ÊûÑÈÄöËøá‰ª£ÁêÜËØ∑Ê±ÇÔºàËß£ÂÜ≥ CORS ÈóÆÈ¢òÔºâ
                        const providerConfig = API_PROVIDERS[taskProvider];
                        const versionConfig = providerConfig?.versions[task.apiVersion || 'v1'];
                        const endpointConfig = versionConfig?.endpoints?.[task.apiEndpointType || 'image-to-video'];
                        const queryPath = endpointConfig?.queryPath || '/api/v1/generate/v0/videos';
                        // Â∞Ü /api/v1/generate/v0/videos ËΩ¨Êç¢‰∏∫ /testing-proxy/api/v1/generate/v0/videos
                        const apiPath = queryPath.replace(/^\//, '');
                        queryUrl = `/testing-proxy/${apiPath}/${task.id}`;
                    } else {
                        // ÂÖ∂‰ªñ provider ‰ΩøÁî®‰ª£ÁêÜ
                        queryUrl = `/videos/${task.id}?provider=${taskProvider}`;
                    }
                    
                    const response = await fetch(queryUrl, {
                        headers: headers
                    });

                    if (response.ok) {
                        const result = await response.json();
                        updateTaskFromAPI(task, result);
                    } else {
                        console.error(`Failed to check task ${task.id}: ${response.status} ${response.statusText}`);
                    }
                } catch (error) {
                    console.error(`Ê™¢Êü•‰ªªÂãô ${task.id} ÁãÄÊÖãÊôÇÂá∫ÈåØ:`, error);
                }
            }
            
            // Êõ¥Êñ∞Áµ±Ë®à
            updateTasksSummary();
        }

        function updateTaskFromAPI(task, result) {
            console.log(`=== Task #${task.taskNumber} Status Update ===`);
            console.log('Full API Response:', result);
            
            // Êõ¥Êñ∞‰ªªÂãôÊï∏Êìö
            const prevStatus = task.status;
            task.status = result.status || task.status;
            task.progress = result.progress || task.progress;
            
            // Â§ÑÁêÜURLÔºöstreamingÁä∂ÊÄÅ‰∏ãurlÊòØm3u8ÔºåfinishedÁä∂ÊÄÅ‰∏ãurlÊòØmp4
            if (result.url) {
                if (task.status === 'streaming') {
                    task.streamUrl = result.url;
                    console.log(`üì° Got HLS stream URL: ${result.url}`);
                } else if (task.status === 'finished' || task.status === 'completed') {
                    task.url = result.url;
                    console.log(`üé¨ Got final MP4 URL: ${result.url}`);
                } else {
                    task.url = result.url;
                }
            }
            
            // Â¶ÇÊûú‰ªéstreamingËΩ¨Âà∞finishedÔºåÊ∏ÖÁêÜHLSÂÆû‰æã
            if (prevStatus === 'streaming' && (task.status === 'finished' || task.status === 'completed')) {
                if (task.hlsInstance) {
                    task.hlsInstance.destroy();
                    task.hlsInstance = null;
                    console.log(`üîÑ Transitioning task #${task.taskNumber} from streaming to finished`);
                }
            }
            
            // Ë®àÊôÇÔºöÁ≠âÂæÖÊôÇÈñìÔºàsubmitted -> startedÔºâËàáÁîüÊàêÊôÇÈñìÔºàstarted -> finishedÔºâ
            if (!task.startedAt && (task.status === 'started' || task.progress > 0)) {
                task.startedAt = Date.now();
                if (task.submittedAt) {
                    task.waitDurationSec = Math.max(0, Math.round((task.startedAt - task.submittedAt) / 1000));
                }
            }
            if (!task.finishedAt && (task.status === 'finished' || task.status === 'completed')) {
                task.finishedAt = Date.now();
                if (task.startedAt) {
                    task.genDurationSec = Math.max(0, Math.round((task.finishedAt - task.startedAt) / 1000));
                }
            }
            
            // ËàäÁöÑÈÄöÁî®Ë®àÊôÇÂÖºÂÆπÔºà‰øùÁïôÁèæÊúâUIÔºâ
            if (task.progress > 0 && !task.startTime) {
                task.startTime = Date.now();
                console.log(`‚è±Ô∏è Task #${task.taskNumber} timer started`);
            }
            
            // Â¶ÇÊûú‰ªªÂãôÂÆåÊàê‰∏îÈÇÑÊ≤íË®òÈåÑÁµêÊùüÊôÇÈñìÔºåË®òÈåÑÁµêÊùüÊôÇÈñì
            const isCompleted = ['completed', 'finished', 'done'].includes(task.status);
            if (isCompleted && !task.endTime) {
                task.endTime = Date.now();
                console.log(`üéâ Task #${task.taskNumber} completed!`);
            }
            
            // Êõ¥Êñ∞UI
            updateTaskCard(task);
            
            // Êõ¥Êñ∞Âà∞ Map ‰∏≠
            tasks.set(task.id, task);

            // Ëã•ÁÇ∫ BenchmarkÔºåÂòóË©¶Âêà‰ΩµÂà∞Â∑¶Âè≥Â∞çÊØî
            try { maybeRenderBenchmarkPair(task); } catch {}
        }

        // ‰∏ãËºâÊó•Ë™åÔºöËº∏Âá∫ CSVÔºåÂåÖÂê´ id, provider, version, endpointType, prompt, submittedAt, startedAt, finishedAt, waitSec, genSec
        function downloadLogs() {
            const header = [
                'taskNumber','id','provider','version','endpointType','prompt','submittedAt','startedAt','finishedAt','waitSec','genSec','status','url'
            ];
            const rows = [header.join(',')];
            for (const task of tasks.values()) {
                const submittedAt = task.submittedAt ? new Date(task.submittedAt).toLocaleString() : '';
                const startedAt = task.startedAt ? new Date(task.startedAt).toLocaleString() : '';
                const finishedAt = task.finishedAt ? new Date(task.finishedAt).toLocaleString() : '';
                const waitSec = task.waitDurationSec != null ? task.waitDurationSec : (task.submittedAt && task.startedAt ? Math.round((task.startedAt - task.submittedAt)/1000) : '');
                const genSec = task.genDurationSec != null ? task.genDurationSec : (task.startedAt && task.finishedAt ? Math.round((task.finishedAt - task.startedAt)/1000) : '');
                const provider = task.apiProvider || '';
                const version = task.apiVersion || '';
                const endpointType = task.apiEndpointType || '';
                const prompt = (task.promptText || '').replaceAll('\n',' ').replaceAll('"','""');
                const line = [
                    task.taskNumber,
                    `"${task.id}"`,
                    provider,
                    version,
                    endpointType,
                    `"${prompt}"`,
                    `"${submittedAt}"`,
                    `"${startedAt}"`,
                    `"${finishedAt}"`,
                    waitSec,
                    genSec,
                    task.status || '',
                    task.url || ''
                ].join(',');
                rows.push(line);
            }
            const csv = rows.join('\n');
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `parrot_logs_${new Date().toISOString().replace(/[:.]/g,'-')}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // ÈñãÂßãÁãÄÊÖãÊ™¢Êü•
        function startStatusCheck() {
            if (statusCheckInterval) {
                clearInterval(statusCheckInterval);
            }
            statusCheckInterval = setInterval(checkVideoStatus, 3000); // ÊØè3ÁßíÊ™¢Êü•‰∏ÄÊ¨°
            checkVideoStatus(); // Á´ãÂç≥Ê™¢Êü•‰∏ÄÊ¨°
        }

        // ÂÅúÊ≠¢ÁãÄÊÖãÊ™¢Êü•
        function stopStatusCheck() {
            if (statusCheckInterval) {
                clearInterval(statusCheckInterval);
                statusCheckInterval = null;
                console.log('‚èπÔ∏è All tasks completed, stopping status check');
            }
        }

        // È°ØÁ§∫ÁãÄÊÖãÂçÄÂüü
        function showStatusArea() {
            document.getElementById('statusArea').style.display = 'block';
        }

        // Ë®≠ÁΩÆÊåâÈàïËºâÂÖ•ÁãÄÊÖã
        function setButtonLoading(loading) {
            const btn = document.getElementById('generateBtn');
            if (!btn) return;
            // ÂßãÁµÇ‰øùÊåÅÂèØÈªûÊìäÔºå‰∏¶Á∂≠ÊåÅÂïüÂãïÊñáÊ°àÔºåÂÖÅË®±ÊåÅÁ∫åÊèê‰∫§
            btn.disabled = false;
            btn.textContent = 'üöÄ Start Generating Video(s)';
        }

        // ÊâπÈáèËôïÁêÜÈÄ≤Â∫¶Ê¢ùÁÆ°ÁêÜ
        function showBatchProgress() {
            document.getElementById('batchProgressArea').style.display = 'block';
        }

        function hideBatchProgress() {
            document.getElementById('batchProgressArea').style.display = 'none';
        }

        function updateBatchProgress(current, total, batchNumber, totalBatches, detail) {
            const progressPercent = total > 0 ? Math.round((current / total) * 100) : 0;
            const progressText = document.getElementById('batchProgressText');
            const progressFill = document.getElementById('batchProgressFill');
            const progressDetail = document.getElementById('batchProgressDetail');
            
            progressText.textContent = `Progress: ${current}/${total} tasks (${progressPercent}%)`;
            progressFill.style.width = `${progressPercent}%`;
            progressDetail.textContent = detail || 'Processing...';
        }

        // È°ØÁ§∫ÈåØË™§Ë®äÊÅØ
        function showError(message) {
            const errorArea = document.getElementById('errorArea');
            if (errorArea) {
                errorArea.innerHTML = `<div class="error-message">‚ùå ${message}</div>`;
            } else {
                console.error('‚ùå', message);
            }
        }

        // Show success message
        function showSuccess(message) {
            const errorArea = document.getElementById('errorArea');
            if (errorArea) {
                errorArea.innerHTML = `<div class="success-message">‚úÖ ${message}</div>`;
            } else {
                console.log('‚úÖ', message);
            }
        }

        // Clear messages
        function clearMessages() {
            const errorArea = document.getElementById('errorArea');
            if (errorArea) {
                errorArea.innerHTML = '';
            }
        }

        // ‰ªªÂãôUIÁÆ°ÁêÜ
        function showTasksArea() {
            document.getElementById('tasksArea').style.display = 'block';
        }

        function createTaskCard(task) {
            const tasksList = document.getElementById('tasksList');
            
            const taskCard = document.createElement('div');
            taskCard.className = 'task-card';
            taskCard.id = `task-${task.id}`;
            
            taskCard.innerHTML = `
                <div class="task-header">
                    <div class="task-title">üìã Task #${task.taskNumber}</div>
                    <div class="task-status processing" id="status-${task.id}">Processing</div>
                </div>
                <div class="task-details">
                    <div class="task-detail-item">
                        <div class="task-detail-label">Video ID</div>
                        <div class="task-detail-value" style="font-size: 11px;">${task.id.substring(0, 12)}...</div>
                    </div>
                    <div class="task-detail-item">
                        <div class="task-detail-label">Progress</div>
                        <div class="task-detail-value" id="progress-${task.id}">0%</div>
                    </div>
                    <div class="task-detail-item">
                        <div class="task-detail-label">Wait</div>
                        <div class="task-detail-value" id="wait-${task.id}">-</div>
                    </div>
                    <div class="task-detail-item">
                        <div class="task-detail-label">Gen</div>
                        <div class="task-detail-value" id="gen-${task.id}">-</div>
                    </div>
                    <div class="task-detail-item">
                        <div class="task-detail-label">‚è±Ô∏è Time</div>
                        <div class="task-detail-value" id="time-${task.id}">Waiting...</div>
                    </div>
                    <div class="task-detail-item">
                        <div class="task-detail-label">üîÅ Retries</div>
                        <div class="task-detail-value" id="retries-${task.id}">${task.retryCount}</div>
                    </div>
                </div>
                <div style="font-size: 13px; color: #666; margin-bottom: 8px;">
                    üñºÔ∏è Image: ${task.imageName} | üí¨ Prompt: ${task.promptText || 'None'}
                    ${task.stickingVideoMode && task.imagePrompt ? `<div style="margin-top:6px; font-size:12px; color:#444; background:#f1f3f5; padding:6px; border-radius:4px;">üñäÔ∏è Image Prompt: ${task.imagePrompt.replaceAll('<','&lt;').replaceAll('>','&gt;')}</div>` : ''}
                </div>
                <div style="font-size: 12px; color: #888; margin-bottom: 10px; padding: 5px; background: #f8f9fa; border-radius: 3px;" id="api-info-${task.id}">
                    üìç API: Loading... | üîó Version: Loading... | üîë Key: Loading...
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill-${task.id}"></div>
                </div>
                <div class="task-video" id="video-${task.id}" style="display: none;"></div>
            `;
            
            // ÊèíÂÖ•Âà∞ÊúÄÂâçÈù¢ÔºàÊúÄÊñ∞ÁöÑ‰ªªÂãôÂú®‰∏äÈù¢Ôºâ
            tasksList.insertBefore(taskCard, tasksList.firstChild);
        }

        function updateTaskCard(task) {
            const statusElement = document.getElementById(`status-${task.id}`);
            const progressElement = document.getElementById(`progress-${task.id}`);
            const timeElement = document.getElementById(`time-${task.id}`);
            const waitElement = document.getElementById(`wait-${task.id}`);
            const genElement = document.getElementById(`gen-${task.id}`);
            const progressFillElement = document.getElementById(`progress-fill-${task.id}`);
            const taskCard = document.getElementById(`task-${task.id}`);
            const retriesElement = document.getElementById(`retries-${task.id}`);
            
            if (!statusElement) return;

            // Êõ¥Êñ∞ÈáçË©¶Ê¨°Êï∏
            if(retriesElement) retriesElement.textContent = task.retryCount;
            
            // Êõ¥Êñ∞ÈÄ≤Â∫¶
            progressElement.textContent = `${task.progress}%`;
            progressFillElement.style.width = `${task.progress}%`;
            
            // Êõ¥Êñ∞ÊôÇÈñì
            if (task.startTime) {
                const elapsed = task.endTime ? 
                    Math.floor((task.endTime - task.startTime) / 1000) :
                    Math.floor((Date.now() - task.startTime) / 1000);
                
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                const timeText = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
                
                timeElement.textContent = task.endTime ? 
                    `‚úÖ ${timeText}` : 
                    `üîÑ ${timeText}`;
                    
                task.duration = elapsed;
            }

            // Êñ∞Â¢ûÔºöÈ°ØÁ§∫Á≠âÂæÖ/ÁîüÊàêÊôÇÈñìÔºàÂç≥ÊôÇÊõ¥Êñ∞ÔºåÂèÉËÄÉ time ÁöÑÂãïÊÖãÈ°ØÁ§∫ÈÇèËºØÔºâ
            if (waitElement) {
                let waitSec = null;
                if (task.submittedAt) {
                    if (task.startedAt) {
                        // Â∑≤ÈñãÂßãÔºåÂõ∫ÂÆöÁÇ∫Êèê‰∫§Âà∞ÈñãÂßãÁöÑËÄóÊôÇ
                        const fixed = task.waitDurationSec ?? Math.round((task.startedAt - task.submittedAt) / 1000);
                        waitSec = Math.max(0, fixed);
                    } else {
                        // Êú™ÈñãÂßãÔºåÂãïÊÖãÁ¥ØÂä†
                        waitSec = Math.max(0, Math.round((Date.now() - task.submittedAt) / 1000));
                    }
                }
                waitElement.textContent = waitSec != null ? `${waitSec}s` : '-';
            }
            if (genElement) {
                let genSec = null;
                if (task.startedAt) {
                    if (task.finishedAt) {
                        // Â∑≤ÂÆåÊàêÔºåÂõ∫ÂÆöÁÇ∫ÈñãÂßãÂà∞ÂÆåÊàêÁöÑËÄóÊôÇ
                        const fixed = task.genDurationSec ?? Math.round((task.finishedAt - task.startedAt) / 1000);
                        genSec = Math.max(0, fixed);
                    } else {
                        // ÁîüÊàê‰∏≠ÔºåÂãïÊÖãÁ¥ØÂä†
                        genSec = Math.max(0, Math.round((Date.now() - task.startedAt) / 1000));
                    }
                }
                genElement.textContent = genSec != null ? `${genSec}s` : '-';
            }
            
            // Êõ¥Êñ∞ÁãÄÊÖã
            statusElement.className = 'task-status';
            if (task.status === 'finished' || task.status === 'completed') {
                statusElement.classList.add('completed');
                statusElement.textContent = '‚úÖ Completed';
                taskCard.classList.add('completed');
                
                if (task.url) {
                    showTaskVideo(task);
                }
            } else if (task.status === 'streaming') {
                statusElement.classList.add('processing');
                statusElement.textContent = 'üì° Streaming';
                
                if (task.streamUrl) {
                    showTaskVideo(task);
                }
            } else if (task.status === 'failed' || task.status === 'error') {
                statusElement.classList.add('failed');
                statusElement.textContent = '‚ùå Failed';
                taskCard.classList.add('failed');
            } else if (task.status.startsWith('retrying')) {
                statusElement.classList.add('processing');
                statusElement.textContent = `‚è≥ Retrying...`;
            } else if (task.status === 'submitting') {
                statusElement.classList.add('processing');
                statusElement.textContent = `üì§ Submitting...`;
            } else {
                statusElement.classList.add('processing');
                statusElement.textContent = 'üîÑ Processing';
            }
        }

        function showTaskVideo(task) {
            const videoContainer = document.getElementById(`video-${task.id}`);
            if (!videoContainer) return;
            
            // Âà§Êñ≠ÊòØstreamingÁä∂ÊÄÅËøòÊòØfinishedÁä∂ÊÄÅ
            const isStreaming = task.status === 'streaming';
            const videoUrl = isStreaming ? task.streamUrl : task.url;
            
            if (!videoUrl) return;
            
            const videoId = `video-player-${task.id}`;
            
            // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÊ∏≤ÊüìËøáÁõ∏ÂêåÁöÑURLÔºåÈÅøÂÖçÈáçÂ§çÊ∏≤Êüì
            if (task._currentVideoUrl === videoUrl && document.getElementById(videoId)) {
                // ËßÜÈ¢ëÂ∑≤ÁªèÂú®Êí≠ÊîæÔºå‰∏çË¶ÅÈáçÊñ∞Ê∏≤Êüì
                return;
            }
            
            // ËÆ∞ÂΩïÂΩìÂâçURLÔºåÈÅøÂÖçÈáçÂ§çÊ∏≤Êüì
            task._currentVideoUrl = videoUrl;
            
            videoContainer.style.display = 'block';
            const label = task.benchmarkLabel ? `<span style="margin-right:8px; padding:2px 6px; border-radius:10px; background:#eef; color:#335; font-size:12px;">${task.benchmarkLabel}</span>` : '';
            const endpointInfo = task.submissionDetails ? `${task.submissionDetails.endpoint}` : '';
            const promptInfo = (task.promptText || '').replaceAll('<','&lt;').replaceAll('>','&gt;');
            
            videoContainer.innerHTML = `
                <div style="display:flex; flex-direction:column; gap:6px; align-items:center;">
                    <div style="font-size:12px; color:#666;">${label}${endpointInfo} ${isStreaming ? 'üì°' : ''}</div>
                    <video id="${videoId}" controls width="60%" ${isStreaming ? 'autoplay muted' : 'preload="metadata"'} style="display: block; margin: 6px auto;">
                        ${isStreaming ? '' : `<source src="${videoUrl}" type="video/mp4">`}
                        Your browser does not support video playback.
                    </video>
                    <div style="font-size:12px; color:#555; max-width:60%; white-space:pre-wrap; word-break:break-word;">üìù ${promptInfo || 'No prompt'}</div>
                    ${!isStreaming && task.url ? `
                    <div style="margin-top: 6px; font-size: 12px; color: #666;">
                        üé¨ <a href="${task.url}" target="_blank" style="color: #4facfe;">Open Video</a> |
                        <a href="javascript:void(0)" onclick="downloadTaskVideo('${task.id}')" style="color: #4facfe;">üíæ Download</a>
                    </div>
                    ` : ''}
                </div>
            `;
            
            // Â¶ÇÊûúÊòØstreamingÔºå‰ΩøÁî®HLS.jsÂä†ËΩΩm3u8
            if (isStreaming && task.streamUrl) {
                const video = document.getElementById(videoId);
                if (video && window.Hls && window.Hls.isSupported()) {
                    // Ê∏ÖÁêÜËàäÁöÑ HLS ÂØ¶‰æãÔºàÂ¶ÇÊûúÂ≠òÂú®Ôºâ
                    if (task.hlsInstance) {
                        task.hlsInstance.destroy();
                        task.hlsInstance = null;
                    }
                    
                    const hls = new window.Hls({
                        enableWorker: true,
                        lowLatencyMode: true,
                        backBufferLength: 90
                    });
                    
                    // üéØ ‰ΩøÁî®ËΩâÁ¢º‰ª£ÁêÜ URLÔºàÂ∞á AC-3 ËΩâÁÇ∫ AACÔºâ
                    const transcodedUrl = `/hls-transcode/${encodeURIComponent(task.streamUrl)}`;
                    console.log(`üîÑ Using transcoded URL: ${transcodedUrl}`);
                    hls.loadSource(transcodedUrl);
                    hls.attachMedia(video);
                    
                    hls.on(window.Hls.Events.MANIFEST_PARSED, function() {
                        console.log(`üì° HLS stream ready for task #${task.taskNumber}`);
                        // üéØ ÂÖ©ÈöéÊÆµÊí≠ÊîæÁ≠ñÁï•ÔºöÂÖàÈùúÈü≥Êí≠ÊîæÔºåÁÑ∂ÂæåÂèñÊ∂àÈùúÈü≥
                        video.muted = true;
                        video.play().then(() => {
                            console.log(`üì° Streaming started (muted) for task #${task.taskNumber}`);
                            setTimeout(() => {
                                video.muted = false;
                                video.volume = 1.0;
                                console.log(`üîä Audio unmuted for task #${task.taskNumber}`);
                                
                                // Ê™¢Ê∏¨ÂØ¶ÈöõÊí≠ÊîæÊôÇÊòØÂê¶ÊúâÈü≥È†ªÔºàÊõ¥ÂèØÈù†ÁöÑÊñπÊ≥ïÔºâ
                                setTimeout(() => {
                                    const hasAudio = !video.muted && video.volume > 0 && 
                                                   (video.mozHasAudio || video.webkitAudioDecodedByteCount > 0 || 
                                                    (video.audioTracks && video.audioTracks.length > 0));
                                    if (hasAudio === false) {
                                        console.warn(`‚ö†Ô∏è Video may not have audio track (task #${task.taskNumber})`);
                                    }
                                }, 500);
                            }, 100);
                        }).catch(e => console.log('Autoplay prevented:', e));
                    });
                    
                    // HLS ÈåØË™§ËôïÁêÜ
                    hls.on(window.Hls.Events.ERROR, function(event, data) {
                        if (data.fatal) {
                            switch(data.type) {
                                case window.Hls.ErrorTypes.NETWORK_ERROR:
                                    console.error('‚ùå Network error, recovering...');
                                    hls.startLoad();
                                    break;
                                case window.Hls.ErrorTypes.MEDIA_ERROR:
                                    console.error('‚ùå Media error, recovering...');
                                    hls.recoverMediaError();
                                    break;
                                default:
                                    console.error('‚ùå Fatal error, cannot recover');
                                    hls.destroy();
                                    break;
                            }
                        }
                    });
                    
                    task.hlsInstance = hls;
                } else if (video && video.canPlayType('application/vnd.apple.mpegurl')) {
                    // ÂéüÁîüÊîØÊåÅHLS (Safari) - ‰πü‰ΩøÁî®ËΩâÁ¢º‰ª£ÁêÜ
                    const transcodedUrl = `/hls-transcode/${encodeURIComponent(task.streamUrl)}`;
                    console.log(`üîÑ Safari using transcoded URL: ${transcodedUrl}`);
                    video.src = transcodedUrl;
                    video.muted = true;
                    video.play().then(() => {
                        console.log(`üì° Native HLS streaming started (muted) for task #${task.taskNumber}`);
                        setTimeout(() => {
                            video.muted = false;
                            video.volume = 1.0;
                            console.log(`üîä Audio unmuted for task #${task.taskNumber}`);
                        }, 100);
                    }).catch(e => console.log('Autoplay prevented:', e));
                    console.log(`üì° Native HLS for task #${task.taskNumber}`);
                }
            }
        }

        // ==== Benchmark Â∞çÊØîÊ∏≤Êüì ====
        function getPairKey(task) {
            // ‰ª•ÂúñÁâáÂêç‰ΩúÁÇ∫ÈÖçÂ∞çÈçµ
            return (task.imageName || '').toLowerCase();
        }

        function maybeRenderBenchmarkPair(task) {
            if (!task.benchmarkLabel) return; // Èùû Benchmark Ë∑≥ÈÅé
            const pairKey = getPairKey(task);
            if (!pairKey) return;
            // ÊâæÂêåÂúñÂè¶‰∏ÄÂçä
            const other = Array.from(tasks.values()).find(t => t !== task && t.imageName === task.imageName && t.benchmarkLabel && t.url);
            if (!other || !task.url) return;

            // ÊßãÂª∫Â∑¶Âè≥Â∞çÊØîÂç°
            const container = document.getElementById('benchmarkResults');
            const pairs = document.getElementById('benchmarkPairs');
            if (!container || !pairs) return;
            container.style.display = 'block';

            const promptA = task.benchmarkLabel === 'A' ? (task.promptText || '') : (other.promptText || '');
            const promptB = task.benchmarkLabel === 'B' ? (task.promptText || '') : (other.promptText || '');
            const endpointA = task.benchmarkLabel === 'A' ? (task.submissionDetails?.endpoint || '') : (other.submissionDetails?.endpoint || '');
            const endpointB = task.benchmarkLabel === 'B' ? (task.submissionDetails?.endpoint || '') : (other.submissionDetails?.endpoint || '');

            const safe = s => (s || '').replaceAll('<','&lt;').replaceAll('>','&gt;');

            const pairDiv = document.createElement('div');
            pairDiv.style.cssText = 'display:flex; gap:12px; align-items:flex-start; justify-content:center;';
            pairDiv.innerHTML = `
                <div style="flex:1; text-align:center; background:#fff; border:1px solid #e1e5e9; border-radius:6px; padding:8px;">
                    <div style="font-size:12px; color:#666; margin-bottom:4px;">A ‚Ä¢ ${safe(endpointA)}</div>
                    <video controls width="100%" preload="metadata" style="max-width:420px;">
                        <source src="${task.benchmarkLabel === 'A' ? task.url : other.url}" type="video/mp4">
                    </video>
                    <div style="font-size:12px; color:#555; white-space:pre-wrap; word-break:break-word; margin-top:4px;">üìù ${safe(promptA)}</div>
                </div>
                <div style="flex:1; text-align:center; background:#fff; border:1px solid #e1e5e9; border-radius:6px; padding:8px;">
                    <div style="font-size:12px; color:#666; margin-bottom:4px;">B ‚Ä¢ ${safe(endpointB)}</div>
                    <video controls width="100%" preload="metadata" style="max-width:420px;">
                        <source src="${task.benchmarkLabel === 'B' ? task.url : other.url}" type="video/mp4">
                    </video>
                    <div style="font-size:12px; color:#555; white-space:pre-wrap; word-break:break-word; margin-top:4px;">üìù ${safe(promptB)}</div>
                </div>
            `;
            // ‰øùÂ≠ò URL ÊñºÁØÄÈªûÂ±¨ÊÄßÔºå‰æøÊñº‰∏ÄÈçµ‰∏ãËºâÂêà‰Ωµ
            pairDiv.dataset.leftUrl = task.benchmarkLabel === 'A' ? task.url : other.url;
            pairDiv.dataset.rightUrl = task.benchmarkLabel === 'B' ? task.url : other.url;
            pairs.prepend(pairDiv);
        }

        async function downloadMergedBenchmark() {
            try {
                const pairs = document.getElementById('benchmarkPairs');
                if (!pairs || !pairs.firstElementChild) { showError('No benchmark pairs to download'); return; }
                const first = pairs.firstElementChild;
                const leftUrl = first.dataset.leftUrl;
                const rightUrl = first.dataset.rightUrl;
                if (!leftUrl || !rightUrl) { showError('Pair URLs missing'); return; }
                const form = new FormData();
                form.append('left_url', leftUrl);
                form.append('right_url', rightUrl);
                form.append('filename', 'benchmark_merged.mp4');
                // ÂÑ™ÂÖà‰ΩøÁî®Êú¨Âú∞Âêà‰ΩµÊúçÂãô (ÊúâFFmpeg)
                const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                let resp;
                
                // Â¶ÇÊûú‰∏çÂú®Êú¨Âú∞Áí∞Â¢ÉÔºåÂòóË©¶ÈÄ£Êé•Êú¨Âú∞ÊúçÂãô
                if (!isLocalhost) {
                    try {
                        console.log('üîÑ Trying local merge service for single pair...');
                        resp = await fetch('http://localhost:8000/benchmark/merge', { method: 'POST', body: form, mode: 'cors' });
                        if (resp && resp.ok) {
                            console.log('‚úÖ Using local merge service');
                        } else {
                            resp = null;
                        }
                    } catch (e) { 
                        console.log('‚ö†Ô∏è Local service not available');
                        resp = null; 
                    }
                }
                
                // FallbackÂà∞Áï∂ÂâçÊúçÂãôÂô®
                if (!resp || !resp.ok) {
                    resp = await fetch('/benchmark/merge', { method: 'POST', body: form });
                }
                if (!resp.ok) { const t = await resp.text(); throw new Error(t || 'merge failed'); }
                const blob = await resp.blob();
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = 'benchmark_merged.mp4';
                document.body.appendChild(a); a.click(); document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showSuccess('‚úÖ Merged video downloaded');
            } catch (e) {
                showError('Merge download failed: ' + (e.message || e));
            }
        }

        async function downloadMergedAll() {
            try {
                const pairs = document.getElementById('benchmarkPairs');
                const list = [];
                Array.from(pairs.children).forEach((node, idx) => {
                    const leftUrl = node.dataset.leftUrl;
                    const rightUrl = node.dataset.rightUrl;
                    if (leftUrl && rightUrl) {
                        const baseName = (node.querySelector('video source')?.src || '').split('/').pop().replace(/\.mp4$/i,'') || `pair_${idx+1}`;
                        list.push({ left_url: leftUrl, right_url: rightUrl, filename: `${baseName}_merged.mp4` });
                    }
                });
                if (list.length === 0) { showError('No pairs available'); return; }
                let resp = null;
                
                // ÂÑ™ÂÖàÂòóË©¶Êú¨Âú∞Âêà‰ΩµÊúçÂãô (ÊúâFFmpeg) - Ê™¢Ê∏¨ÊòØÂê¶Âú®Êú¨Âú∞Áí∞Â¢É
                const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
                console.log('üé¨ Requesting batch merge for', list.length, 'pairs');
                console.log(`üìç Running on: ${isLocalhost ? 'Local (FFmpeg available)' : 'Online (No FFmpeg)'}`);
                
                // Â¶ÇÊûú‰∏çÂú®Êú¨Âú∞ÔºåÂòóË©¶ÈÄ£Êé•Êú¨Âú∞mergeÊúçÂãô
                if (!isLocalhost) {
                    try {
                        console.log('üîÑ Trying to connect to local merge service...');
                        resp = await fetch('http://localhost:8000/benchmark/merge_batch', { 
                            method: 'POST', 
                            headers: { 'Content-Type': 'application/json' }, 
                            body: JSON.stringify({ pairs: list }),
                            mode: 'cors'
                        });
                        if (resp && resp.ok) {
                            console.log('‚úÖ Using local merge service (localhost:8000)');
                        } else {
                            resp = null;
                        }
                    } catch (e) {
                        console.log('‚ö†Ô∏è Local merge service not available:', e.message);
                        resp = null;
                    }
                }
                
                // Â¶ÇÊûúÊú¨Âú∞ÊúçÂãô‰∏çÂèØÁî®Ôºå‰ΩøÁî®Áï∂ÂâçÊúçÂãôÂô®
                if (!resp) {
                    console.log('üé¨ Requesting batch merge from current server');
                    resp = await fetch('/benchmark/merge_batch', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ pairs: list }) });
                    if (!resp.ok) {
                        console.error('‚ùå Merge batch failed:', resp.status, resp.statusText);
                        const errorText = await resp.text();
                        console.error('Error details:', errorText);
                        // Á∑ö‰∏äÁí∞Â¢ÉÁÑ° ffmpeg ÊôÇÈÄÄÂåñÁÇ∫ÊâìÂåÖÂéüË¶ñÈ†ª
                        console.log('üîÑ Falling back to zip_pairs...');
                        resp = await fetch('/benchmark/zip_pairs', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ pairs: list }) });
                        if (!resp.ok) { const t = await resp.text(); throw new Error(t || 'merge batch/zip fallback failed'); }
                        console.log('‚úÖ Using fallback zip (original videos without merge)');
                    }
                }
                const blob = await resp.blob();
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = 'benchmark_merged_all.zip';
                document.body.appendChild(a); a.click(); document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showSuccess('‚úÖ All merged videos downloaded as ZIP');
            } catch (e) {
                showError('Merge batch download failed: ' + (e.message || e));
            }
        }

        async function downloadTaskVideo(taskId) {
            const task = tasks.get(taskId);
            if (!task || !task.url) {
                showError('Ë¶ñÈ†ªË≥áË®ä‰∏çÂÆåÊï¥ÔºåÁÑ°Ê≥ï‰∏ãËºâ');
                return;
            }
            
            try {
                // ÁîüÊàêÂü∫ÊñºÂúñÁâáÂêçÁ®±ÁöÑÊñá‰ª∂ÂêçÔºåÊ∑ªÂä†‰ªªÂãôIDÁ¢∫‰øùÂîØ‰∏ÄÊÄß
                const imageName = (task.imageName || '').replace(/\.[^/.]+$/, '') || 'video';
                const shortTaskId = task.id.substring(0, 8); // ‰ΩøÁî®‰ªªÂãôIDÂâç8‰Ωç
                const defaultFileName = `${imageName}.mp4`;
                
                console.log('üîÑ Downloading single video:', {
                    taskId: task.id,
                    imageName: task.imageName,
                    url: task.url,
                    defaultFileName: defaultFileName,
                    fullTask: task
                });
                
                // Ê™¢Êü•ÊòØÂê¶ÊîØÊè¥ File System Access API (Chrome 86+) ‰∏îÂú® HTTPS Áí∞Â¢É
                const isSecureContext = window.isSecureContext || location.protocol === 'https:';
                const hasFileSystemAPI = 'showSaveFilePicker' in window;
                
                console.log('File System API availability:', {
                    hasFileSystemAPI,
                    isSecureContext,
                    protocol: location.protocol
                });
                
                if (hasFileSystemAPI && isSecureContext) {
                    try {
                        // ‰ΩøÁî®Êñ∞ÁöÑ File System Access API ËÆìÁî®Êà∂ÈÅ∏ÊìáÂ≠òÂÑ≤‰ΩçÁΩÆ
                        const fileHandle = await window.showSaveFilePicker({
                            suggestedName: defaultFileName,
                            types: [{
                                description: 'Video files',
                                accept: {
                                    'video/mp4': ['.mp4']
                                }
                            }]
                        });
                        
                        showSuccess('ÈñãÂßã‰∏ãËºâË¶ñÈ†ª...');
                        
                        const response = await fetch(task.url, {
                            method: 'GET',
                            headers: {
                                'Accept': 'video/mp4,video/*,*/*'
                            }
                        });
                        
                        if (!response.ok) {
                            throw new Error(`‰∏ãËºâÂ§±Êïó: ${response.status} ${response.statusText}`);
                        }
                        
                        const writableStream = await fileHandle.createWritable();
                        await response.body.pipeTo(writableStream);
                        
                        showSuccess('‚úÖ Ë¶ñÈ†ª‰∏ãËºâÊàêÂäüÔºÅ');
                        return;
                    } catch (filePickerError) {
                        if (filePickerError.name === 'AbortError') {
                            showError('‰∏ãËºâÂ∑≤ÂèñÊ∂à');
                            return;
                        }
                        console.log('üìù File picker failed, falling back to regular download:', filePickerError.message);
                    }
                }
                
                // ÈôçÁ¥öÂà∞ÂÇ≥Áµ±‰∏ãËºâÊñπÂºè
                showSuccess('ÈñãÂßã‰∏ãËºâË¶ñÈ†ª...');
                
                const response = await fetch(task.url, {
                    method: 'GET',
                    headers: {
                        'Accept': 'video/mp4,video/*,*/*'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`‰∏ãËºâÂ§±Êïó: ${response.status} ${response.statusText}`);
                }
                
                const blob = await response.blob();
                
                // ÂâµÂª∫‰∏ãËºâÈÄ£Áµê
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = defaultFileName;
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                // Ê∏ÖÁêÜ blob URL
                window.URL.revokeObjectURL(url);
                
                showSuccess(`‚úÖ Ë¶ñÈ†ª‰∏ãËºâÊàêÂäüÔºÅÊ™îÂêçÔºö${defaultFileName}`);
                
            } catch (error) {
                console.error('‚ùå Download failed:', error);
                showError(`‰∏ãËºâÂ§±Êïó: ${error.message}`);
                
                // Â¶ÇÊûú fetch Â§±ÊïóÔºåÂòóË©¶Áõ¥Êé•ÊâìÈñãÈÄ£Áµê
                console.log('üîÑ Fallback: Opening video URL directly');
                window.open(task.url, '_blank');
            }
        }

        function updateTasksSummary() {
            const totalTasksElement = document.getElementById('totalTasks');
            const averageTimeElement = document.getElementById('averageTime');
            
            const completedTasks = Array.from(tasks.values()).filter(task => 
                task.endTime && (task.status === 'finished' || task.status === 'completed')
            );
            
            totalTasksElement.textContent = tasks.size;
            
            if (completedTasks.length > 0) {
                const totalTime = completedTasks.reduce((sum, task) => sum + task.duration, 0);
                const avgTime = Math.round(totalTime / completedTasks.length);
                const minutes = Math.floor(avgTime / 60);
                const seconds = avgTime % 60;
                
                const avgText = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
                averageTimeElement.textContent = `${avgText} (${completedTasks.length}/${tasks.size})`;
            } else {
                averageTimeElement.textContent = '-';
            }
            
            // È°ØÁ§∫/Èö±Ëóè‰∏ãËºâÊåâÈàï
            const downloadBtn = document.getElementById('downloadAllBtn');
            const downloadCard = document.getElementById('downloadAllCard');
            const completedVideos = Array.from(tasks.values()).filter(task => 
                (task.status === 'finished' || task.status === 'completed') && task.url
            );
            
            if (downloadBtn && downloadCard) {
                if (completedVideos.length > 0) {
                    downloadCard.style.display = 'block';
                    downloadBtn.textContent = `üì¶ Download All Completed Videos (${completedVideos.length})`;
                } else {
                    downloadCard.style.display = 'none';
                }
            }
            
            // È°ØÁ§∫/Èö±Ëóè Sticking Video Âêà‰Ωµ‰∏ãËºâÊåâÈàï
            const downloadStickingCard = document.getElementById('downloadStickingCard');
            const completedStickingVideos = Array.from(tasks.values()).filter(task => 
                task.stickingVideoMode && 
                (task.status === 'finished' || task.status === 'completed') && 
                task.url
            );
            
            if (downloadStickingCard) {
                if (completedStickingVideos.length >= 3) {
                    downloadStickingCard.style.display = 'block';
                } else {
                    downloadStickingCard.style.display = 'none';
                }
            }
        }

        // ‰∏ãËºâÂêà‰ΩµÁöÑ Sticking Videos
        async function downloadMergedStickingVideos() {
            console.log('üé¨ Starting sticking videos merge...');
            
            // Áç≤ÂèñÊâÄÊúâÂÆåÊàêÁöÑ sticking video ‰ªªÂãô
            const completedStickingVideos = Array.from(tasks.values()).filter(task => 
                task.stickingVideoMode && 
                (task.status === 'finished' || task.status === 'completed') && 
                task.url
            ).sort((a, b) => a.stickingVideoVariant - b.stickingVideoVariant); // ÊåâËÆäÈ´îÁ∑®ËôüÊéíÂ∫è
            
            console.log(`üìã Found ${completedStickingVideos.length} completed sticking videos:`, 
                completedStickingVideos.map(t => ({ variant: t.stickingVideoVariant, url: t.url })));
            
            if (completedStickingVideos.length !== 3) {
                showError(`‚ùå Need exactly 3 completed sticking videos, but found ${completedStickingVideos.length}`);
                return;
            }
            
            const downloadBtn = document.getElementById('downloadStickingBtn');
            const originalText = downloadBtn.textContent;
            downloadBtn.disabled = true;
            downloadBtn.textContent = '‚è≥ Merging videos...';
            
            try {
                // ‰ΩøÁî® fade ËΩâÂ†¥ÊïàÊûú
                const transition = 'fade';
                console.log(`üí´ Using fade transition`);
                
                // ÊèêÂèñË¶ñÈ†ª URLs
                const videoUrls = completedStickingVideos.map(task => task.url);
                
                showSuccess('üí´ Downloading and merging videos with fade effect...');
                
                // Ë™øÁî®ÂæåÁ´ØÂêà‰Ωµ API
                const response = await fetch('/merge-sticking-videos', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        video_urls: videoUrls,
                        transition: transition
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.error || `HTTP ${response.status}`);
                }
                
                // Áç≤ÂèñÂêà‰ΩµÂæåÁöÑË¶ñÈ†ª blob
                const blob = await response.blob();
                
                // ÂâµÂª∫‰∏ãËºâÈÄ£Áµê
                const url = window.URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `sticking_videos_merged_fade.mp4`;
                link.style.display = 'none';
                
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                // Ê∏ÖÁêÜ blob URL
                window.URL.revokeObjectURL(url);
                
                showSuccess(`‚úÖ Sticking videos merged successfully with fade effect!`);
                
            } catch (error) {
                console.error('‚ùå Merge failed:', error);
                showError(`‚ùå Merge failed: ${error.message}`);
            } finally {
                downloadBtn.disabled = false;
                downloadBtn.textContent = originalText;
            }
        }

        // ‰∏ãËºâÊâÄÊúâÂÆåÊàêÁöÑË¶ñÈ†ª
        async function downloadAllVideos() {
            console.log('üîÑ Starting batch download...');
            
            const completedVideos = Array.from(tasks.values()).filter(task => 
                (task.status === 'finished' || task.status === 'completed') && task.url
            );
            
            console.log(`üìã Found ${completedVideos.length} completed videos:`, completedVideos.map(t => ({
                id: t.id,
                imageName: t.imageName,
                promptText: t.promptText,
                url: t.url
            })));
            
            if (completedVideos.length === 0) {
                showError('No completed videos to download');
                return;
            }
            
            const downloadBtn = document.getElementById('downloadAllBtn');
            const originalText = downloadBtn.textContent;
            downloadBtn.disabled = true;
            downloadBtn.textContent = 'üì• Downloading...';
            
            try {
                let successCount = 0;
                let failCount = 0;
                
                for (let i = 0; i < completedVideos.length; i++) {
                    const task = completedVideos[i];
                    
                    try {
                        console.log(`üì• Downloading video ${i + 1}/${completedVideos.length}:`, {
                            taskId: task.id,
                            imageName: task.imageName,
                            url: task.url
                        });
                        
                        // ‰ΩøÁî® fetch ‰∏ãËºâË¶ñÈ†ªÊñá‰ª∂
                        const response = await fetch(task.url, {
                            method: 'GET',
                            headers: {
                                'Accept': 'video/mp4,video/*,*/*'
                            }
                        });
                        
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        
                        const blob = await response.blob();
                        
                        // ÂâµÂª∫‰∏ãËºâÈÄ£Áµê
                        const url = window.URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        
                        // ‰ΩøÁî®ÂúñÁâáÂêçÁ®±‰ΩúÁÇ∫Ë¶ñÈ†ªÊ™îÂêçÔºåÊ∑ªÂä†‰ªªÂãôIDÁ¢∫‰øùÂîØ‰∏ÄÊÄß
                        const imageName = (task.imageName || '').replace(/\.[^/.]+$/, '') || `video_${task.taskNumber}`;
                        const fileName = `${imageName}.mp4`;
                        link.download = fileName;
                        link.style.display = 'none';
                        
                        console.log(`üíæ Download filename: ${fileName}`);
                        
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        
                        // Ê∏ÖÁêÜ blob URL
                        window.URL.revokeObjectURL(url);
                        
                        successCount++;
                        
                        // Êõ¥Êñ∞ÊåâÈàïÊñáÂ≠óÈ°ØÁ§∫ÈÄ≤Â∫¶
                        downloadBtn.textContent = `üì• Downloading... (${i + 1}/${completedVideos.length})`;
                        
                        // Áü≠Êö´Âª∂ÈÅ≤ÈÅøÂÖçÁÄèË¶ΩÂô®ÈòªÊ≠¢Â§öÂÄã‰∏ãËºâ
                        if (i < completedVideos.length - 1) {
                            await new Promise(resolve => setTimeout(resolve, 800));
                        }
                        
                    } catch (error) {
                        console.error(`‚ùå Failed to download video ${task.taskNumber}:`, error);
                        failCount++;
                    }
                }
                
                // È°ØÁ§∫ÁµêÊûú
                if (successCount === completedVideos.length) {
                    showSuccess(`‚úÖ Successfully started download for all ${successCount} video(s)!`);
                } else if (successCount > 0) {
                    showSuccess(`‚ö†Ô∏è Downloaded ${successCount}/${completedVideos.length} video(s). ${failCount} failed.`);
                } else {
                    showError(`‚ùå Failed to download any videos. Please try downloading individually.`);
                }
                
                // Á¢∫‰øù‰ªªÂãôÁãÄÊÖã‰øùÊåÅ‰∏çËÆä
                console.log(`üìä Tasks status after download:`, Array.from(tasks.values()).length, 'tasks remaining');
                
            } catch (error) {
                console.error('‚ùå Batch download error:', error);
                showError(`Download failed: ${error.message}`);
            } finally {
                downloadBtn.disabled = false;
                downloadBtn.textContent = originalText;
                
                // Âº∑Âà∂Êõ¥Êñ∞‰ªªÂãôÊëòË¶Å‰ª•Á¢∫‰øùUIÊ≠£Á¢∫
                updateTasksSummary();
            }
        }

        // Ë™øË©¶‰ªªÂãôÊï∏Êìö
        function debugTasks() {
            console.log('=== Debug Tasks Info ===');
            console.log('Total tasks:', tasks.size);
            console.log('Tasks Map:', tasks);
            
            Array.from(tasks.values()).forEach((task, index) => {
                console.log(`Task ${index + 1}:`, {
                    id: task.id,
                    taskNumber: task.taskNumber,
                    imageName: task.imageName,
                    promptText: task.promptText,
                    status: task.status,
                    url: task.url
                });
            });
            
            showSuccess('Ë™øË©¶‰ø°ÊÅØÂ∑≤Ëº∏Âá∫Âà∞ÊéßÂà∂Âè∞ÔºåË´ãÊåâF12Êü•Áúã');
        }

        // Ê∏¨Ë©¶ÈÄ£Êé•ÂäüËÉΩ
        async function testConnection() {
            console.log('testConnection function called');
            
            const apiKey = document.getElementById('apiKey').value;
            const apiConfig = getCurrentAPIConfig();
            const apiUrl = apiConfig.endpoint;

            if (!apiKey) {
                showError('Please enter API Key first');
                return;
            }

            clearMessages();
            
            // Áç≤ÂèñÂÆåÊï¥URL‰ø°ÊÅØ
            const providerConfig = API_PROVIDERS[apiConfig.provider];
            const baseUrl = providerConfig.baseUrl;
            const fullUrl = baseUrl + apiConfig.endpoint;
            
            // ‰ΩøÁî®Ê≠£Á¢∫ÁöÑ API KeyÔºàÂ¶ÇÊûúÁî®Êà∂Ê≤íÊúâËº∏ÂÖ•Ôºå‰ΩøÁî®ÈÖçÁΩÆ‰∏≠ÁöÑÈªòË™çÂÄºÔºâ
            const effectiveApiKey = apiKey || providerConfig.apiKey;
            
            // È°ØÁ§∫Ë™øË©¶‰ø°ÊÅØ
            const debugInfo = `
üîç <strong>Test Connection Debug Info:</strong><br>
üìç <strong>Provider:</strong> ${apiConfig.provider}<br>
üîó <strong>API Version:</strong> ${apiConfig.version}<br>
üåê <strong>Base URL:</strong> ${baseUrl}<br>
üéØ <strong>Endpoint:</strong> ${apiConfig.endpoint}<br>
üîó <strong>Full URL:</strong> ${fullUrl}<br>
üîë <strong>API Key:</strong> ${effectiveApiKey.substring(0, 8)}...${effectiveApiKey.substring(effectiveApiKey.length - 8)}<br>
‚è≥ Sending test request...
            `;
            showSuccess(debugInfo);

            try {
                console.log('=== Test Connection Debug Info ===');
                console.log('Provider:', apiConfig.provider);
                console.log('API Version:', apiConfig.version);
                console.log('Base URL:', baseUrl);
                console.log('Endpoint:', apiConfig.endpoint);
                console.log('Full URL:', fullUrl);
                console.log('Proxy Endpoint:', apiUrl);
                console.log('API Key:', `${apiKey.substring(0, 8)}...${apiKey.substring(apiKey.length - 8)}`);

                // ÂâµÂª∫‰∏ÄÂÄãÊúÄÂ∞èÁöÑÊ∏¨Ë©¶Ë´ãÊ±ÇÈ´î
                const formData = new FormData();
                formData.append('prompt', 'test connection');
                formData.append('provider', getCurrentAPIConfig().provider);
                formData.append('version', getCurrentAPIConfig().version);
                
                // ÂâµÂª∫‰∏ÄÂÄã1x1ÂÉèÁ¥†ÁöÑÊ∏¨Ë©¶ÂúñÁâá
                const canvas = document.createElement('canvas');
                canvas.width = 1;
                canvas.height = 1;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, 1, 1);
                
                // Â∞ácanvasËΩâÊèõÁÇ∫blob
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                formData.append('image', blob, 'test.png');

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'X-API-KEY': effectiveApiKey
                    },
                    body: formData
                });

                console.log('=== Response Info ===');
                console.log('Status:', response.status, response.statusText);
                console.log('Headers:', [...response.headers.entries()]);

                // ËÆÄÂèñÈüøÊáâÂÖßÂÆπ
                let responseText = '';
                try {
                    responseText = await response.text();
                    console.log('Response content:', responseText);
                } catch (e) {
                    console.log('Could not read response content:', e);
                    responseText = 'Could not read response content';
                }

                // È°ØÁ§∫ÂÆåÊï¥ÁöÑÊ∏¨Ë©¶ÁµêÊûú
                const resultInfo = `
üîç <strong>Test Connection Results:</strong><br>
üìç <strong>Provider:</strong> ${apiConfig.provider}<br>
üîó <strong>API Version:</strong> ${apiConfig.version}<br>
üåê <strong>Base URL:</strong> ${baseUrl}<br>
üéØ <strong>Endpoint:</strong> ${apiConfig.endpoint}<br>
üîó <strong>Full URL:</strong> ${fullUrl}<br>
üîë <strong>API Key:</strong> ${effectiveApiKey.substring(0, 8)}...${effectiveApiKey.substring(effectiveApiKey.length - 8)}<br>
üìä <strong>Response Status:</strong> ${response.status} ${response.statusText}<br>
üìù <strong>Response Content:</strong><br>
<pre style="background: #f5f5f5; padding: 10px; border-radius: 5px; max-height: 200px; overflow-y: auto; font-size: 12px; white-space: pre-wrap;">${responseText}</pre>
                `;

                if (response.status === 200 || response.status === 201 || response.status === 202) {
                    showSuccess(resultInfo + '<br>‚úÖ <strong>Connection test successful!</strong>');
                } else if (response.status === 401) {
                    showError(resultInfo + '<br>‚ùå <strong>Authentication failed: API Key might be invalid</strong>');
                } else if (response.status === 403) {
                    showError(resultInfo + '<br>‚ùå <strong>Forbidden: API Key might not have access</strong>');
                } else if (response.status === 404) {
                    showError(resultInfo + '<br>‚ùå <strong>API endpoint not found: Please check the URL</strong>');
                } else if (response.status === 400) {
                    showError(resultInfo + '<br>‚ö†Ô∏è <strong>Bad Request: API Key or request format may be incorrect</strong>');
                } else if (response.status === 500) {
                    showError(resultInfo + '<br>‚ö†Ô∏è <strong>Server Error: API service may be temporarily unavailable</strong>');
                } else {
                    showError(resultInfo + `<br>‚ö†Ô∏è <strong>Received response status: ${response.status} ${response.statusText}</strong>`);
                }

            } catch (error) {
                console.error('Connection test error:', error);
                
                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    showError('‚ùå Network Error: Could not connect to server. Check URL and network connection.');
                } else if (error.message.includes('CORS')) {
                    showError('‚ùå CORS Error: Cross-origin request blocked by browser.');
                } else {
                    showError(`‚ùå Connection failed: ${error.message}`);
                }
            }
        }

        // Ê∑ªÂä†Ë™øË©¶Ê™¢Êü•ÂäüËÉΩ
        async function debugCheck() {
            console.log('debugCheck function called');
            const apiKey = document.getElementById('apiKey').value;
            const apiConfig = getCurrentAPIConfig();
            const apiUrl = apiConfig.endpoint;

            if (!apiKey) {
                showError('Please enter API Key first');
                return;
            }

            clearMessages();
            showSuccess('Performing debug check...');

            try {
                // ÂòóË©¶‰∏ÄÂÄãÁ∞°ÂñÆÁöÑË´ãÊ±Ç‰æÜÈÄ≤Ë°åË™øË©¶Ê™¢Êü•
                const response = await fetch(apiUrl, {
                    method: 'OPTIONS',
                    headers: {
                        'X-API-KEY': apiKey,
                    }
                });

                console.log('Debug check response:', response.status, response.statusText);

                if (response.status === 405) {
                    showSuccess('‚úÖ Debug check successful!');
                } else if (response.status === 200 || response.status === 204) {
                    showError('‚ùå Debug check failed: Received non-405 status code');
                } else {
                    showError(`‚ö†Ô∏è Received response status: ${response.status} ${response.statusText}`);
                }

            } catch (error) {
                console.error('Debug check error:', error);
                if (error.message.includes('CORS')) {
                    showError('‚ùå CORS Error: May need to run in a CORS-enabled environment.');
                } else if (error.message.includes('network')) {
                    showError('‚ùå Network Error: Check network connection and URL.');
                } else {
                    showError(`‚ùå Debug check failed: ${error.message}`);
                }
            }
        }


        
        function getCurrentApiUrl() {
            return getCurrentAPIConfig().endpoint;
        }

        // È†ÅÈù¢ËºâÂÖ•ÊôÇÁöÑÂàùÂßãÂåñ
        window.addEventListener('load', () => {
            console.log('üöÄ Parrot API Multi-Task Frontend Loaded');
            
            // APIÈÖçÁΩÆÂ∑≤Âõ∫ÂÆöÁÇ∫stagingÁí∞Â¢É
            updateProviderVersions(); // ÂàùÂßãÂåñÊèê‰æõÂïÜÂíåÁâàÊú¨ÈÅ∏Êìá
            // ÂàùÂßãÂåñ Benchmark ÂçÄÂüü
            try {
                document.getElementById('benchmarkToggle')?.addEventListener('change', (e) => {
                    const on = e.target.checked;
                    document.getElementById('benchmarkConfig')?.classList.toggle('hidden', !on);
                    if (on) updateProviderVersionsB();
                });
            } catch {}
        });

        // È†ÅÈù¢Âç∏ËºâÊôÇÊ∏ÖÁêÜ
        window.addEventListener('beforeunload', () => {
            stopStatusCheck();
        });

        async function minimaxTTS() {
            try {
                const text = document.getElementById('minimaxText').value.trim();
                const voiceId = document.getElementById('minimaxVoiceId').value.trim();
                const groupId = document.getElementById('minimaxGroupId').value.trim();
                const apiKey = document.getElementById('minimaxApiKey').value.trim();

                if (!text) {
                    showError('Ë´ãÂÖàËº∏ÂÖ•ÊñáÊú¨');
                    return;
                }
                if (!groupId && !apiKey) {
                    showError('Ë´ãÂ°´ÂØ´ MINIMAX_GROUPID Ëàá MINIMAX_API_KEYÔºåÊàñÂú®ÊúçÂãôÂô®Ë®≠ÁΩÆÁí∞Â¢ÉËÆäÈáè');
                    return;
                }

                clearMessages();
                showSuccess('‚è≥ Ê≠£Âú®ÁîüÊàêÈü≥È†ªÔºåË´ãÁ®çÂÄô...');

                const body = { text };
                if (window.minimaxCurrentVoiceId) body.voice_id = window.minimaxCurrentVoiceId;

                const response = await fetch('/minimax/t2a', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(body)
                });

                if (!response.ok) {
                    let errJson = {}, errText = '';
                    try { errText = await response.text(); errJson = JSON.parse(errText); } catch { errJson = {}; }
                    const code = errJson.provider_status_code ?? errJson.status ?? errJson.base_resp?.status_code;
                    const msg = errJson.provider_status_msg ?? errJson.base_resp?.status_msg ?? (errJson.provider_response?.base_resp?.status_msg);
                    const base = errJson.error || errJson.message || 'Request failed';
                    const details = `${base}${code ? ` [${code}]` : ''}${msg ? `: ${msg}` : ''}`;
                    console.error('Minimax TTS failed:', { status: response.status, bodyText: errText, parsed: errJson });
                    throw new Error(details || `HTTP ${response.status}`);
                }

                const blob = await response.blob();
                const url = URL.createObjectURL(blob);
                const player = document.getElementById('minimaxAudioPlayer');
                const link = document.getElementById('minimaxAudioLink');

                player.src = url;
                player.style.display = 'block';
                link.href = url;
                link.download = `minimax-${Date.now()}.mp3`;
                link.style.display = 'inline-block';

                showSuccess('‚úÖ ÁîüÊàêÊàêÂäüÔºåÂèØÊí≠ÊîæÊàñ‰∏ãËºâ');
            } catch (e) {
                showError(`‚ùå ÁîüÊàêÂ§±Êïó: ${e.message}`);
            }
        }

        async function onStartButtonClick() {
            const isBenchmark = document.getElementById('benchmarkToggle')?.checked;
            const provider = document.getElementById('apiProvider')?.value;
            if (!isBenchmark) {
                if (provider === 'minimax') {
                    await minimaxTTS();
                } else {
                    await generateVideo();
                }
                return;
            }

            // Benchmark Ê®°ÂºèÔºöÂêå‰∏ÄÊâπÂúñÁâáÔºåÂàÜÂà•Áî® A/B ÂÖ©ÁµÑÈÖçÁΩÆÊèê‰∫§Ôºà‰ΩøÁî® Benchmark ÂçÄÂüüÁöÑ PromptÔºâ
            const images = Array.from(document.getElementById('imageFile').files || []);
            if (images.length === 0) { showError('Please select at least one image file'); return; }

            const aKey = document.getElementById('apiKey')?.value || '';
            const bKey = document.getElementById('apiKeyB')?.value || '';
            const aCfg = getCurrentAPIConfig();
            const bCfg = getCurrentAPIConfigB();
            const promptA = document.getElementById('promptTextA')?.value || '';
            const promptB = document.getElementById('promptTextB')?.value || '';

            for (const img of images) {
                // AÔºöË¶ÜÂØ´ÂèÉÊï∏ÂæåÂæ©Áî®ÂéüÊúâ submitTaskÔºà‰øùÁïô‰ªªÂãô/Ëº™Ë©¢/ÈåØË™§ËôïÁêÜÔºâ
                window.benchmarkOverrideConfig = aCfg;
                window.benchmarkOverrideApiKey = aKey;
                window.benchmarkOverridePrompt = promptA;
                window.benchmarkLabel = 'A';
                window.benchmarkImageName = img.name || '';
                await submitTask(img);
                // BÔºö
                window.benchmarkOverrideConfig = bCfg;
                window.benchmarkOverrideApiKey = bKey;
                window.benchmarkOverridePrompt = promptB;
                window.benchmarkLabel = 'B';
                window.benchmarkImageName = img.name || '';
                await submitTask(img);
                // Ê∏ÖÁêÜ
                window.benchmarkOverrideConfig = null;
                window.benchmarkOverrideApiKey = null;
                window.benchmarkOverridePrompt = null;
                window.benchmarkLabel = null;
                window.benchmarkImageName = null;
            }
        }

        // Minimax Clone ÂâçÁ´Ø‰∫§‰∫íÔºàËá™ÂãïÂÖãÈöÜÔºâ
        let minimaxCurrentVoiceId = '';
        (function initMinimaxCloneUI(){
            const upload = document.getElementById('minimaxCloneUpload');
            const input = document.getElementById('minimaxCloneFile');
            const nameEl = document.getElementById('minimaxCloneFileName');
            const statusEl = document.getElementById('minimaxCloneStatus');
            if (!upload || !input) return;
            upload.addEventListener('click', () => input.click());
            upload.addEventListener('dragover', e => { e.preventDefault(); upload.classList.add('drag-over'); });
            upload.addEventListener('dragleave', () => upload.classList.remove('drag-over'));
            upload.addEventListener('drop', e => {
                e.preventDefault(); upload.classList.remove('drag-over');
                if (e.dataTransfer?.files?.length){ input.files = e.dataTransfer.files; if (nameEl) nameEl.textContent = `Selected: ${e.dataTransfer.files[0].name}`; autoClone(); }
            });
            input.addEventListener('change', () => { const f = input.files?.[0]; if (nameEl) nameEl.textContent = f ? `Selected: ${f.name}` : ''; if (f) autoClone(); });

            async function autoClone() {
                try {
                    console.log('üöÄ AUTO CLONE STARTED!!!');
                    const f = input.files?.[0];
                    if (!f) return;
                    
                    // Ê™¢Êü•Êñá‰ª∂È°ûÂûãÔºàÊîØÊåÅÈü≥È†ªÂíåË¶ñÈ†ªÊñá‰ª∂Ôºâ
                    const isAudio = f.type.startsWith('audio/') || f.name.match(/\.(mp3|wav|m4a|aac|ogg|flac)$/i);
                    const isVideo = f.type.startsWith('video/') || f.name.match(/\.(mp4|mov|avi|mkv)$/i);
                    if (!isAudio && !isVideo) {
                        if (statusEl) statusEl.textContent = '‚ùå Ë´ã‰∏äÂÇ≥Èü≥È†ªÊàñË¶ñÈ†ªÊñá‰ª∂';
                        showError('Ë´ã‰∏äÂÇ≥Èü≥È†ªÊñá‰ª∂ÔºàMP3/WAV/M4AÁ≠âÔºâÊàñË¶ñÈ†ªÊñá‰ª∂ÔºàMP4Á≠âÔºåÂ∞áËá™ÂãïÊèêÂèñÈü≥È†ªÔºâ');
                        return;
                    }
                    
                    clearMessages();
                    if (statusEl) statusEl.textContent = '‚è≥ Ê≠£Âú®‰∏äÂÇ≥‰∏¶ÂÖãÈöÜ...';
                    console.log('üîÑ About to send request to /minimax/clone');
                    const fd = new FormData();
                    fd.append('audio', f);
                    const resp = await fetch('/minimax/clone', { method: 'POST', body: fd });
                    console.log('üì° Got response, status:', resp.status);
                    let text = '', data = {};
                    try { text = await resp.text(); console.log('üìÑ Raw response text:', text); data = JSON.parse(text); } catch { data = {}; }
                    console.log('üîç Minimax /clone response:', { status: resp.status, raw: text, parsed: data });
                    if (!resp.ok) { 
                        const code = data.provider_status_code ?? data.status ?? data.base_resp?.status_code;
                        const msg = data.provider_status_msg ?? data.base_resp?.status_msg ?? (data.provider_response?.base_resp?.status_msg);
                        const base = data.error || data.message || 'Request failed';
                        const details = `${base}${code ? ` [${code}]` : ''}${msg ? `: ${msg}` : ''}`;
                        console.error('‚ùå Minimax clone failed:', { status: resp.status, raw: text, parsed: data });
                        throw new Error(details || `HTTP ${resp.status}`); 
                    }
                    if (data.voice_id) {
                        minimaxCurrentVoiceId = data.voice_id;
                        if (statusEl) statusEl.textContent = `‚úÖ ÂÖãÈöÜÊàêÂäü voice_id: ${data.voice_id}`;
                        showSuccess(`‚úÖ Ë™ûÈü≥ÂÖãÈöÜÊàêÂäüÔºåvoice_id: ${data.voice_id}`);
                    }
                    if (data.preview_audio) {
                        const p = document.getElementById('minimaxClonePreview');
                        p.src = data.preview_audio; p.style.display = 'block';
                    }
                } catch (e) {
                    if (statusEl) statusEl.textContent = `‚ùå ÂÖãÈöÜÂ§±Êïó: ${e.message}`;
                    showError(`‚ùå ÂÖãÈöÜÂ§±Êïó: ${e.message}`);
                }
            }
        })();
    </script>
</body>
</html> 