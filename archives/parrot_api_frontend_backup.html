<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parrot API - Image to Video Generator</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üé¨</text></svg>">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 16px;
        }

        .content {
            padding: 40px;
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #333;
        }

        .hidden { display: none !important; }

        .file-upload-area {
            border: 2px dashed #ddd;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
            background: #fafafa;
        }

        .file-upload-area:hover {
            border-color: #4facfe;
            background: #f0f9ff;
        }

        .file-upload-area.drag-over {
            border-color: #4facfe;
            background: #e6f3ff;
        }

        .upload-icon {
            font-size: 48px;
            color: #ddd;
            margin-bottom: 15px;
        }

        .file-upload-area.has-file {
            border-color: #4caf50;
            background: #f1f8e9;
        }

        .file-upload-area.has-file .upload-icon {
            color: #4caf50;
        }

        input[type="file"] {
            display: none;
        }

        .form-control {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            font-size: 16px;
            transition: border-color 0.3s ease;
        }

        .form-control:focus {
            outline: none;
            border-color: #4facfe;
        }

        textarea.form-control {
            resize: vertical;
            min-height: 100px;
        }

        .api-config {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 25px;
        }

        .api-config h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .btn {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            margin-bottom: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(79, 172, 254, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .status-area {
            margin-top: 30px;
            padding: 20px;
            border-radius: 10px;
            background: #f8f9fa;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #e1e5e9;
        }

        .status-item:last-child {
            border-bottom: none;
        }

        .status-label {
            font-weight: 600;
            color: #333;
        }

        .status-value {
            color: #666;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e1e5e9;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4facfe, #00f2fe);
            transition: width 0.3s ease;
            width: 0%;
        }

        .result-area {
            margin-top: 30px;
            text-align: center;
        }

        .video-container {
            margin: 20px 0;
        }

        .video-container video {
            max-width: 100%;
            border-radius: 10px;
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }

        .error-message {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .success-message {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
        }

        .preview-image {
            max-width: 300px;
            max-height: 200px;
            border-radius: 8px;
            margin-top: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .task-card {
            background: white;
            border: 1px solid #e1e5e9;
            border-radius: 10px;
            margin-bottom: 20px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .task-card.completed {
            border-color: #4caf50;
            background: #f8fff8;
        }

        .task-card.failed {
            border-color: #f44336;
            background: #fff8f8;
        }

        .task-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #e1e5e9;
        }

        .task-title {
            font-weight: 600;
            color: #333;
        }

        .task-status {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
        }

        .task-status.processing {
            background: #fff3cd;
            color: #856404;
        }

        .task-status.completed {
            background: #d4edda;
            color: #155724;
        }

        .task-status.failed {
            background: #f8d7da;
            color: #721c24;
        }

        .task-details {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 15px;
        }

        .task-detail-item {
            text-align: center;
        }

        .task-detail-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }

        .task-detail-value {
            font-weight: 600;
            color: #333;
        }

        .task-video {
            text-align: center;
            margin-top: 15px;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
            }
            
            .content {
                padding: 20px;
            }
            
            .header {
                padding: 20px;
            }

            .task-details {
                grid-template-columns: 1fr;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé¨ Parrot API Image to Video</h1>
            <p>Upload an image, add a prompt, and generate beautiful videos</p>
        </div>

        <div class="content">


            <!-- API Configuration Area -->
            <div class="api-config">
                <h3>üîß API Configuration</h3>
                <div class="form-group" style="margin-top: 10px;">
                    <label style="display:flex;align-items:center;gap:8px;">
                        <input type="checkbox" id="benchmarkToggle" /> Benchmark Mode (Dual-path comparison, same image data)
                    </label>
                </div>
                
                <!-- API Provider Selection -->
                <div class="form-group">
                    <label for="apiProvider">API Provider:</label>
                    <select id="apiProvider" class="form-control" onchange="updateProviderVersions()">
                        <option value="staging" selected>Staging - Parrot Labs API Server</option>
                        <option value="original">Original - Original Parrot API Server</option>
                        <option value="minimax">Minimax text to audio</option>
                    </select>
                </div>

                <!-- API Version Selection -->
                <div class="form-group">
                    <label for="apiVersion">API Version:</label>
                    <select id="apiVersion" class="form-control" onchange="updateAPIDescription()">
                        <!-- Version options will be dynamically populated by JavaScript -->
                    </select>
                </div>

                <!-- Endpoint Type Selection (Original API v0 only) -->
                <div class="form-group" id="endpointTypeGroup" style="display: none;">
                    <label for="endpointType">Endpoint Type:</label>
                    <select id="endpointType" class="form-control" onchange="updateAPIDescription()">
                        <option value="image-to-video">image-to-video (default)</option>
                        <option value="image-to-video-new">image-to-video-new</option>
                        <option value="image-to-video-inner">image-to-video-inner</option>
                        <option value="image-to-video-nmd">image-to-video-nmd</option>
                        <option value="audio-to-video">audio-to-video</option>
                    </select>
                </div>

                <!-- Benchmark Configuration Area -->
                <div id="benchmarkConfig" class="section hidden" style="margin-top:12px;padding-top:12px;border-top:1px dashed #ddd;">
                    <h4 style="margin-bottom:12px;">Benchmark</h4>
                    <div class="form-group">
                        <label for="promptTextA">Prompt (A)</label>
                        <textarea id="promptTextA" class="form-control" placeholder="Prompt for A..." rows="2"></textarea>
                    </div>
                    <div style="margin-top:16px; padding-top:12px; border-top:1px dashed #e5e5e5;">
                        <div class="form-group">
                            <label for="apiProviderB">API Provider (B):</label>
                            <select id="apiProviderB" class="form-control" onchange="updateProviderVersionsB()">
                                <option value="staging">Staging - Parrot Labs API Server</option>
                                <option value="original" selected>Original - Original Parrot API Server</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="apiVersionB">API Version (B):</label>
                            <select id="apiVersionB" class="form-control" onchange="updateAPIDescriptionB()"></select>
                        </div>
                        <div class="form-group" id="endpointTypeGroupB" style="display:none;">
                            <label for="endpointTypeB">Endpoint Type (B):</label>
                            <select id="endpointTypeB" class="form-control" onchange="updateAPIDescriptionB()">
                                <option value="image-to-video">image-to-video (default)</option>
                                <option value="image-to-video-new">image-to-video-new</option>
                                <option value="image-to-video-inner">image-to-video-inner</option>
                                <option value="image-to-video-nmd">image-to-video-nmd</option>
                                <option value="audio-to-video">audio-to-video</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <div id="apiDescriptionB" style="background:#f8f9fa;padding:10px;border-radius:5px;border:1px solid #e9ecef;font-size:14px;color:#666;">Please select API provider and version</div>
                        </div>
                        <div class="form-group">
                            <label for="apiKeyB">API Key (B):</label>
                            <input type="password" id="apiKeyB" class="form-control" value="" placeholder="Enter API Key for B">
                        </div>
                        <div class="form-group">
                            <label for="promptTextB">Prompt (B)</label>
                            <textarea id="promptTextB" class="form-control" placeholder="Prompt for B..." rows="2"></textarea>
                        </div>
                    </div>
                </div>

                <!-- API Description Display -->
                <div class="form-group">
                    <div id="apiDescription" style="background: #f8f9fa; padding: 10px; border-radius: 5px; border: 1px solid #e9ecef; font-size: 14px; color: #666;">
                        Please select API provider and version
                    </div>
                </div>
                <div class="form-group">
                    <label for="apiKey">API Key:</label>
                    <input type="password" id="apiKey" class="form-control" value="" placeholder="Enter your API Key">
                    <small style="color: #666; margin-top: 5px; display: block;">
                        üí° Tip: API Keys usually start with "pk-" or a similar prefix
                    </small>
                </div>
                <div class="form-group">
                    <button type="button" class="btn" onclick="testConnection()" style="background: #28a745; margin-bottom: 10px;">
                        üîç Test Connection
                    </button>
                    <button type="button" class="btn" onclick="debugCheck()" style="background: #6c757d; margin-bottom: 10px;">
                        üêõ Debug Check
                    </button>
                    <button type="button" class="btn" onclick="debugTasks()" style="background: #e83e8c; margin-bottom: 10px;">
                        üìä Debug Tasks
                    </button>
                </div>

                <!-- Text to Audio (MiniMax) -->
                <div id="minimaxSection" class="section hidden" style="margin-top: 16px; padding: 12px; border-top: 1px solid #eee; background:#fafafa; border-radius:8px;">
                    <h3 style="margin-bottom: 8px; font-size:18px;">Text to Audio (MiniMax)</h3>
                    <div class="form-group">
                        <label for="minimaxText">Text:</label>
                        <textarea id="minimaxText" class="form-control" rows="3" placeholder="Enter text to synthesize"></textarea>
                    </div>
                    <div class="form-group" style="margin-top:8px; padding-top: 8px; border-top: 1px dashed #e5e5e5;">
                        <h4 style="margin-bottom: 6px; font-size: 14px;">Voice Clone</h4>
                        <div class="file-upload-area" id="minimaxCloneUpload" style="cursor:pointer;">
                            <div class="upload-icon">üéµ</div>
                            <div class="upload-text">
                                <strong>Click to select or drag and drop audio/video</strong><br>
                                <small>Supports MP3/WAV/M4A/MP4; Recommended 10-30 seconds of clear voice (auto clone)</small>
                            </div>
                            <input type="file" id="minimaxCloneFile" accept="audio/*,video/*" style="display:none;">
                            <div id="minimaxCloneFileName" style="margin-top: 8px; font-size: 12px; color: #666;"></div>
                        </div>
                        <div id="minimaxCloneStatus" style="margin-top:8px; font-size:12px; color:#666;"></div>
                        <audio id="minimaxClonePreview" controls style="display:none; margin-top:8px; width:100%;"></audio>
                    </div>
                    <div class="form-group">
                        <button type="button" class="btn" style="background:#007bff;" onclick="minimaxTTS()">üîà Generate Audio</button>
                        <a id="minimaxAudioLink" style="display:none;margin-left:8px;" download>Download Audio</a>
                        <audio id="minimaxAudioPlayer" controls style="display:none;margin-top:8px;width:100%;"></audio>
                    </div>
                </div>
            </div>

            <!-- Image Upload Area -->
            <div class="form-group">
                <label>üì∏ Select Image(s) - Multi-select supported (Max 50)</label>
                <div class="file-upload-area" id="uploadArea">
                    <div class="upload-icon">üìÅ</div>
                    <div class="upload-text">
                        <strong>Click to select image(s)</strong> or drag and drop them here<br>
                        <small>Supports JPG, PNG, GIF formats ‚Ä¢ Multi-select enabled ‚Ä¢ Max 50 images</small>
                    </div>
                    <input type="file" id="imageFile" accept="image/*" multiple>
                    <div id="imagePreview"></div>
                </div>
            </div>

            <!-- Audio Upload (Required for audio-to-video endpoint) -->
            <div class="form-group" id="audioGroup" style="display: none;">
                <label>üéµ Select Audio (Required for audio-to-video)</label>
                <div class="file-upload-area" id="audioUploadArea">
                    <div class="upload-icon">üéµ</div>
                    <div class="upload-text">
                        <strong>Click to select audio</strong> or drag and drop here<br>
                        <small>Supports MP3, WAV, M4A, etc.</small>
                    </div>
                    <input type="file" id="audioFile" accept="audio/*">
                    <div id="audioFileName" style="margin-top: 8px; font-size: 12px; color: #666;"></div>
                </div>
            </div>

            <!-- Processing Settings (Hidden) -->

            <!-- Prompt Input -->
            <div class="form-group">
                <label for="promptText">‚ú® Prompt (Optional)</label>
                <textarea id="promptText" class="form-control" placeholder="Describe the video effect you want to generate...&#10;e.g., a beautiful sunset scene with gentle waves"></textarea>
            </div>

            <!-- Image Management Buttons -->
            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                <button class="btn" style="background: #6c757d; width: auto; flex: none; padding: 12px 20px;" onclick="clearAllImages()">
                    üóëÔ∏è Clear All Images
                </button>
                <button class="btn" style="background: #17a2b8; width: auto; flex: none; padding: 12px 20px;" onclick="downloadLogs()">
                    üì• Download Logs
                </button>
                <div style="flex: 1;"></div>
                <div id="imageCount" style="align-self: center; color: #666; font-size: 14px;"></div>
            </div>

            <!-- Generate Button -->
            <button class="btn" id="generateBtn" onclick="onStartButtonClick()">
                üöÄ Start Generating Video(s)
            </button>

            <!-- Processing Progress Bar -->
            <div id="batchProgressArea" style="display: none; margin: 20px 0; padding: 20px; background: #f8f9fa; border-radius: 10px;">
                <h4 style="margin-bottom: 15px;">üìä Processing Progress</h4>
                <div style="margin-bottom: 10px;">
                    <span id="batchProgressText">Processing...</span>
                </div>
                <div class="progress-bar" style="margin-bottom: 10px;">
                    <div class="progress-fill" id="batchProgressFill"></div>
                </div>
                <div style="font-size: 12px; color: #666;">
                    <span id="batchProgressDetail">Starting processing...</span>
                </div>
            </div>

            <!-- Batch Download Button -->
            <div style="margin: 20px 0; text-align: center;">
                <button class="btn" id="downloadAllBtn" onclick="downloadAllVideos()" style="background: #28a745; display: none;">
                    üì¶ Download All Completed Videos
                </button>
                <div style="margin-top: 10px; font-size: 12px; color: #666;">
                    üí° Videos will be named after corresponding images. Supported browsers can choose storage location
                </div>
            </div>

            <!-- Multi-task Management Area -->
            <div class="tasks-area" id="tasksArea" style="display: none;">
                <h3>üìä Task Management</h3>
                <div class="task-summary" id="taskSummary" style="margin-bottom: 20px; padding: 15px; background: #f0f9ff; border-radius: 8px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span>üìà Task Stats: <span id="totalTasks">0</span> total tasks</span>
                        <span>‚è±Ô∏è Average Time: <span id="averageTime">-</span></span>
                    </div>
                </div>
                <div id="tasksList"></div>
            </div>

            <!-- Benchmark Results Comparison Area -->
            <div id="benchmarkResults" class="section" style="display:none; margin-top:16px; padding:12px; background:#f8f9ff; border:1px solid #e1e5e9; border-radius:8px;">
                <div style="display:flex; justify-content:space-between; align-items:center; gap:12px;">
                    <h3 style="margin-bottom:8px;">üß™ Benchmark Results (A vs B)</h3>
                    <div style="display:flex; gap:8px;">
                        <button class="btn" id="downloadMergedBtn" style="width:auto; padding:10px 16px; background:#28a745;" onclick="downloadMergedBenchmark()">‚¨áÔ∏è Download Merged (Top Pair)</button>
                        <button class="btn" id="downloadMergedAllBtn" style="width:auto; padding:10px 16px; background:#17a2b8;" onclick="downloadMergedAll()">‚¨áÔ∏è Download All Merged (ZIP)</button>
                    </div>
                </div>
                <div id="benchmarkPairs" style="display:flex; flex-direction:column; gap:16px;"></div>
            </div>

            <!-- Error Message Area -->
            <div id="errorArea"></div>
        </div>
    </div>

    <script>
        // Multi-task management
        let tasks = new Map(); // Use Map to store task information
        let imageQueue = []; // Queue of images waiting to be processed
        let processingInterval = null; // Timer for queue manager
        let globalTaskCounter = 0;
        let statusCheckInterval = null;
        let pendingSubmissions = 0; // Number of submissions not yet formally added to tasks Map, for more precise concurrency control
        
        // API providers and version configuration
        const API_PROVIDERS = {
            'original': {
                name: 'Original',
                description: 'Original Parrot API Server',
                baseUrl: 'https://qazwsxedcrf3g5h.pika.art',
                apiKey: 'pk_GW7ITxUVnC271AoJaasgdATrmzjl4OnQKTmD2j6tLZM',
                versions: {
                    'v0': {
                        endpoints: {
                            'image-to-video': {
                                path: '/generate/v0/image-to-video',
                                description: 'Image to Video - v0 version (default)',
                                name: 'Original v0 (default)'
                            },
                            'image-to-video-new': {
                                path: '/generate/v0/image-to-video-new',
                                description: 'Image to Video - v0 version (New Endpoint)',
                                name: 'Original v0 (New Endpoint)'
                            },
                            'image-to-video-inner': {
                                path: '/generate/v0/image-to-video-inner',
                                description: 'Image to Video - v0 version (Internal Endpoint)',
                                name: 'Original v0 (Internal Endpoint)'
                            },
                            'image-to-video-nmd': {
                                path: '/generate/v0/image-to-video-nmd',
                                description: 'Image to Video - v0 version (NMD Endpoint)',
                                name: 'Original v0 (nmd)'
                            },
                            'audio-to-video': {
                                path: '/generate/v0/audio-to-video',
                                description: 'Image+Audio to Video - v0 version',
                                name: 'Original v0 (audio-to-video)'
                            }
                        },
                        defaultEndpoint: 'image-to-video',
                        description: 'Image to Video - v0 version',
                        name: 'Original v0'
                    }
                }
            },
            'staging': {
                name: 'Staging',
                description: 'Parrot Labs API Server',
                baseUrl: 'https://089e99349ace.pikalabs.app',
                apiKey: 'pk_fnOLPQFrhk96QscYG9hIUSw-Jn5ygl_ehSUWa9PvwZM',
                versions: {
                    'v2.2': {
                        endpoint: '/generate/2.2/i2v',
                        description: 'Image to Video - v2.2 version',
                        name: 'Staging v2.2'
                    }
                }
            },
            'minimax': {
                name: 'Minimax text to audio',
                description: 'MiniMax Text to Speech',
                baseUrl: '',
                versions: {
                    'v1': {
                        endpoint: '/minimax/t2a',
                        description: 'Text to Speech - v1',
                        name: 'Text to Audio'
                    }
                }
            }
        };

        // Get current API configuration - now supports dynamic selection
        function getCurrentAPIConfig() {
            const provider = document.getElementById('apiProvider')?.value || 'staging';
            const apiVersion = document.getElementById('apiVersion')?.value || 'v2.2';
            const endpointType = document.getElementById('endpointType')?.value;
            const versionConfig = API_PROVIDERS[provider]?.versions[apiVersion];
            
            let endpoint = '/generate/2.2/i2v'; // default
            
            if (versionConfig) {
                if (versionConfig.endpoints) {
                    // Original API v0 supports multiple endpoints
                    const selectedEndpoint = endpointType && versionConfig.endpoints[endpointType] 
                        ? versionConfig.endpoints[endpointType] 
                        : versionConfig.endpoints[versionConfig.defaultEndpoint];
                    endpoint = selectedEndpoint.path;
                } else {
                    // single endpoint (Staging or Minimax)
                    endpoint = versionConfig.endpoint;
                }
            }
            
            return {
                provider: provider,
                version: apiVersion,
                endpoint: endpoint,
                endpointType: endpointType
            };
        }

        // Update provider version options
        function updateProviderVersions() {
            const providerSelect = document.getElementById('apiProvider');
            const versionSelect = document.getElementById('apiVersion');
            const endpointTypeGroup = document.getElementById('endpointTypeGroup');
            
            if (!providerSelect || !versionSelect) return;
            
            const selectedProvider = providerSelect.value;
            const providerConfig = API_PROVIDERS[selectedProvider];
            
            // Clear version options
            versionSelect.innerHTML = '';
            
            // Add version options
            if (providerConfig && providerConfig.versions) {
                Object.keys(providerConfig.versions).forEach(versionKey => {
                    const version = providerConfig.versions[versionKey];
                    const option = document.createElement('option');
                    option.value = versionKey;
                    option.textContent = version.name || versionKey;
                    versionSelect.appendChild(option);
                });
            }
            
            // Check if endpoint type selector needs to be displayed
            if (endpointTypeGroup) {
                const selectedVersion = versionSelect.value;
                const versionConfig = providerConfig?.versions[selectedVersion];
                
                if (versionConfig && versionConfig.endpoints) {
                    // Original API v0 supports multiple endpoints
                    endpointTypeGroup.style.display = 'block';
                } else {
                    // Staging API or other versions use single endpoint
                    endpointTypeGroup.style.display = 'none';
                }
            }
            
            // Toggle UI: Hide image/generate video related elements under Minimax, show T2A block
            const isMinimax = selectedProvider === 'minimax';
            document.getElementById('uploadArea')?.closest('.form-group')?.classList.toggle('hidden', isMinimax);
            document.getElementById('audioGroup')?.classList.toggle('hidden', isMinimax);
            document.getElementById('promptText')?.closest('.form-group')?.classList.toggle('hidden', isMinimax);
            document.getElementById('generateBtn')?.classList.toggle('hidden', isMinimax);
            // Show/hide minimax block
            document.getElementById('minimaxSection')?.classList.toggle('hidden', !isMinimax);

            // Auto-fill Minimax credentials (only when empty)
            if (isMinimax) {
                try {
                    fetch('/minimax/env?full=1').then(r => r.json()).then(env => {
                        const gidEl = document.getElementById('minimaxGroupId');
                        const keyEl = document.getElementById('minimaxApiKey');
                        if (gidEl && !gidEl.value && env.group_id) gidEl.value = env.group_id;
                        if (keyEl && !keyEl.value && env.api_key) keyEl.value = env.api_key;
                    }).catch(() => {});
                } catch {}
            }

            // Sync current provider's default API Key to input field (avoid using wrong provider's key)
            try {
                const keyInput = document.getElementById('apiKey');
                if (keyInput) {
                    keyInput.value = providerConfig?.apiKey || '';
                }
            } catch {}

            updateAPIDescription();
        }

        // Benchmark: Update B path provider/version/endpoint display
        function updateProviderVersionsB() {
            const providerSelect = document.getElementById('apiProviderB');
            const versionSelect = document.getElementById('apiVersionB');
            const endpointTypeGroup = document.getElementById('endpointTypeGroupB');
            if (!providerSelect || !versionSelect) return;
            const selectedProvider = providerSelect.value;
            const providerConfig = API_PROVIDERS[selectedProvider];
            versionSelect.innerHTML = '';
            if (providerConfig && providerConfig.versions) {
                Object.keys(providerConfig.versions).forEach(versionKey => {
                    const version = providerConfig.versions[versionKey];
                    const option = document.createElement('option');
                    option.value = versionKey;
                    option.textContent = version.name || versionKey;
                    versionSelect.appendChild(option);
                });
            }
            if (endpointTypeGroup) {
                const selectedVersion = versionSelect.value;
                const versionConfig = providerConfig?.versions[selectedVersion];
                if (versionConfig && versionConfig.endpoints) {
                    endpointTypeGroup.style.display = 'block';
                } else {
                    endpointTypeGroup.style.display = 'none';
                }
            }
            // Auto-fill B's default key
            try {
                const keyInput = document.getElementById('apiKeyB');
                if (keyInput) keyInput.value = providerConfig?.apiKey || '';
            } catch {}
            updateAPIDescriptionB();
        }

        function getCurrentAPIConfigB() {
            const provider = document.getElementById('apiProviderB')?.value || 'staging';
            const apiVersion = document.getElementById('apiVersionB')?.value || 'v2.2';
            const endpointType = document.getElementById('endpointTypeB')?.value;
            const versionConfig = API_PROVIDERS[provider]?.versions[apiVersion];
            let endpoint = '/generate/2.2/i2v';
            if (versionConfig) {
                if (versionConfig.endpoints) {
                    const selectedEndpoint = endpointType && versionConfig.endpoints[endpointType]
                        ? versionConfig.endpoints[endpointType]
                        : versionConfig.endpoints[versionConfig.defaultEndpoint];
                    endpoint = selectedEndpoint.path;
                } else {
                    endpoint = versionConfig.endpoint;
                }
            }
            return { provider, version: apiVersion, endpoint, endpointType };
        }

        function updateAPIDescriptionB() {
            const provider = document.getElementById('apiProviderB')?.value;
            const version = document.getElementById('apiVersionB')?.value;
            const endpointType = document.getElementById('endpointTypeB')?.value;
            const descElement = document.getElementById('apiDescriptionB');
            if (!descElement || !provider || !version) return;
            const providerConfig = API_PROVIDERS[provider];
            const versionConfig = providerConfig?.versions[version];
            if (providerConfig && versionConfig) {
                let description = `${providerConfig.description} - ${versionConfig.description}`;
                if (versionConfig.endpoints && endpointType) {
                    const endpointConfig = versionConfig.endpoints[endpointType];
                    if (endpointConfig) description += ` (${endpointConfig.description})`;
                }
                descElement.textContent = description;
            }
        }

        // Show/hide audio upload based on endpoint type
        function refreshAudioVisibility() {
            const endpointType = document.getElementById('endpointType')?.value;
            const audioGroup = document.getElementById('audioGroup');
            if (!audioGroup) return;
            if (endpointType === 'audio-to-video') {
                audioGroup.style.display = 'block';
            } else {
                audioGroup.style.display = 'none';
            }
        }
        document.getElementById('endpointType')?.addEventListener('change', refreshAudioVisibility);
        // Also refresh once during initial render
        window.addEventListener('load', refreshAudioVisibility);

        // Update API description
        function updateAPIDescription() {
            const provider = document.getElementById('apiProvider')?.value;
            const version = document.getElementById('apiVersion')?.value;
            const endpointType = document.getElementById('endpointType')?.value;
            const descElement = document.getElementById('apiDescription');
            
            if (!descElement || !provider || !version) return;
            
            const providerConfig = API_PROVIDERS[provider];
            const versionConfig = providerConfig?.versions[version];
            
            if (providerConfig && versionConfig) {
                let description = `${providerConfig.description} - ${versionConfig.description}`;
                
                // If it's Original API v0, add endpoint type information
                if (versionConfig.endpoints && endpointType) {
                    const endpointConfig = versionConfig.endpoints[endpointType];
                    if (endpointConfig) {
                        description += ` (${endpointConfig.description})`;
                    }
                }
                
                descElement.textContent = description;
            }
        }
        
        // Task data structure
        function createTask(videoId, promptText, imageName) {
            return {
                id: videoId,
                taskNumber: ++globalTaskCounter,
                status: 'waiting',
                progress: 0,
                promptText: promptText || '',
                imageName: imageName || '',
                startTime: null,
                endTime: null,
                duration: 0,
                // New timing fields
                submittedAt: null,
                startedAt: null,
                finishedAt: null,
                waitDurationSec: null,
                genDurationSec: null,
                url: null,
                created: new Date(),
                retryCount: 0,
                benchmarkLabel: window.benchmarkLabel || ''
            };
        }

        // File upload handling
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('imageFile');
        const imagePreview = document.getElementById('imagePreview');

            // Click upload area (if audio-to-video is selected, clicking audio area can also trigger)
            uploadArea.addEventListener('click', () => {
                fileInput.click();
            });

            // Audio area click/drag
            const audioGroup = document.getElementById('audioGroup');
            const audioInput = document.getElementById('audioFile');
            const audioUploadArea = document.getElementById('audioUploadArea');
            const audioFileName = document.getElementById('audioFileName');
            
            audioUploadArea?.addEventListener('click', () => audioInput?.click());
            audioUploadArea?.addEventListener('dragover', (e) => {
                e.preventDefault();
                audioUploadArea.classList.add('drag-over');
            });
            audioUploadArea?.addEventListener('dragleave', () => audioUploadArea.classList.remove('drag-over'));
            audioUploadArea?.addEventListener('drop', (e) => {
                e.preventDefault();
                audioUploadArea.classList.remove('drag-over');
                if (e.dataTransfer?.files?.length) {
                    const f = e.dataTransfer.files[0];
                    audioInput.files = e.dataTransfer.files;
                    audioUploadArea.classList.add('has-file');
                    if (audioFileName) audioFileName.textContent = `Selected: ${f.name}`;
                }
            });
            audioInput?.addEventListener('change', () => {
                const f = audioInput.files?.[0];
                if (f) {
                    audioUploadArea?.classList.add('has-file');
                    if (audioFileName) audioFileName.textContent = `Selected: ${f.name}`;
                } else {
                    audioUploadArea?.classList.remove('has-file');
                    if (audioFileName) audioFileName.textContent = '';
                }
            });

        // Drag and drop upload
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('drag-over');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('drag-over');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('drag-over');
            const files = Array.from(e.dataTransfer.files);
            if (files.length > 0) {
                handleMultipleFileSelect(files);
            }
        });

        // File selection handling
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleMultipleFileSelect(Array.from(e.target.files));
            }
        });

        let selectedImages = []; // ÂÖ®Â±ÄËÆäÈáèÂ≠òÂÑ≤ÈÅ∏‰∏≠ÁöÑÂúñÁâá

        async function handleMultipleFileSelect(files) {
            // ÈÅéÊøæÂá∫ÂúñÁâáÊñá‰ª∂
            const imageFiles = files.filter(file => file.type.startsWith('image/'));
            
            if (imageFiles.length === 0) {
                showError('Please select image files');
                return;
            }

            // Ê™¢Êü•ÊòØÂê¶ÊúÉË∂ÖÈÅé50ÂºµÈôêÂà∂
            const totalAfterAdd = selectedImages.length + imageFiles.length;
            if (totalAfterAdd > 50) {
                const canAdd = 50 - selectedImages.length;
                if (canAdd <= 0) {
                    showError('Maximum 50 images allowed. Please remove some images first.');
                    return;
                } else {
                    showError(`Only ${canAdd} more image(s) can be added (max 50 total). Only first ${canAdd} will be added.`);
                    imageFiles.splice(canAdd); // Âè™‰øùÁïôÂâçcanAddÂÄãÊñá‰ª∂
                }
            }

            // Èò≤Ê≠¢ÈáçË§áÂúñÁâáÔºàÊ†πÊìöÊñá‰ª∂ÂêçÂíåÂ§ßÂ∞èÔºâ
            const newUniqueImages = [];
            imageFiles.forEach(newFile => {
                const isDuplicate = selectedImages.some(existingFile => 
                    existingFile.name === newFile.name && existingFile.size === newFile.size
                );
                if (!isDuplicate) {
                    newUniqueImages.push(newFile);
                }
            });

            // Ëá™ÂãïÂ∞á AVIF ËΩâÁÇ∫ JPG
            const finalFiles = [];
            for (const f of newUniqueImages) {
                if (isAvifFile(f)) {
                    try {
                        const converted = await convertAvifToJpeg(f);
                        finalFiles.push(converted);
                    } catch (e) {
                        // ËΩâÊèõÂ§±ÊïóÂâáÂõûÈÄÄ‰ΩøÁî®ÂéüÊñá‰ª∂
                        console.warn('AVIF to JPEG conversion failed, using original file:', e);
                        finalFiles.push(f);
                    }
                } else {
                    finalFiles.push(f);
                }
            }

            if (newUniqueImages.length === 0) {
                showError('All selected images are already added');
                return;
            }

            if (newUniqueImages.length < imageFiles.length) {
                const duplicateCount = imageFiles.length - newUniqueImages.length;
                showSuccess(`${newUniqueImages.length} image(s) added. ${duplicateCount} duplicate(s) skipped.`);
            }

            // Â∞áÊñ∞ÁöÑÂîØ‰∏ÄÂúñÁâáÔºàÂê´ËΩâÊèõÂæå JPGÔºâÊ∑ªÂä†Âà∞ÈÅ∏‰∏≠ÂàóË°®
            selectedImages = [...selectedImages, ...finalFiles];
            
            // Êõ¥Êñ∞ file input ÁöÑ files Â±¨ÊÄß
            updateFileInput();
            
            // È°ØÁ§∫È†êË¶Ω
            displayImagePreviews();
            
            // Êõ¥Êñ∞‰∏äÂÇ≥ÂçÄÂüüÁãÄÊÖã
            uploadArea.classList.add('has-file');
            updateUploadAreaText();
        }

        function isAvifFile(file) {
            return file && (file.type === 'image/avif' || /\.avif$/i.test(file.name || ''));
        }

        async function convertAvifToJpeg(file) {
            const url = URL.createObjectURL(file);
            try {
                // ÂÑ™ÂÖà‰ΩøÁî® createImageBitmap
                try {
                    const bitmap = await createImageBitmap(file);
                    const canvas = document.createElement('canvas');
                    canvas.width = bitmap.width;
                    canvas.height = bitmap.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(bitmap, 0, 0);
                    const jpegBlob = await new Promise((resolve, reject) => {
                        canvas.toBlob(b => b ? resolve(b) : reject(new Error('toBlob failed')), 'image/jpeg', 0.92);
                    });
                    const newName = (file.name || 'image').replace(/\.avif$/i, '.jpg');
                    return new File([jpegBlob], newName, { type: 'image/jpeg' });
                } catch (_) {
                    // ÂõûÈÄÄ‰ΩøÁî® HTMLImageElement
                    const image = await new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => resolve(img);
                        img.onerror = reject;
                        img.src = url;
                    });
                    const canvas = document.createElement('canvas');
                    canvas.width = image.width;
                    canvas.height = image.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(image, 0, 0);
                    const jpegBlob = await new Promise((resolve, reject) => {
                        canvas.toBlob(b => b ? resolve(b) : reject(new Error('toBlob failed')), 'image/jpeg', 0.92);
                    });
                    const newName = (file.name || 'image').replace(/\.avif$/i, '.jpg');
                    return new File([jpegBlob], newName, { type: 'image/jpeg' });
                }
            } finally {
                URL.revokeObjectURL(url);
            }
        }

        function updateFileInput() {
            // ÂâµÂª∫Êñ∞ÁöÑ DataTransfer Â∞çË±°‰æÜÊõ¥Êñ∞ file input
            const dt = new DataTransfer();
            selectedImages.forEach(file => {
                dt.items.add(file);
            });
            fileInput.files = dt.files;
        }

        function displayImagePreviews() {
            if (selectedImages.length === 0) {
                imagePreview.innerHTML = '';
                uploadArea.classList.remove('has-file');
                updateUploadAreaText();
                return;
            }

            let previewHTML = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px; margin-top: 15px;">';
            
            selectedImages.forEach((file, index) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const previewItem = document.createElement('div');
                    previewItem.style.cssText = 'position: relative; text-align: center; background: #f8f9fa; border-radius: 8px; padding: 8px;';
                    previewItem.innerHTML = `
                        <img src="${e.target.result}" style="width: 100%; height: 80px; object-fit: cover; border-radius: 6px;" alt="Preview ${index + 1}">
                        <div style="font-size: 11px; color: #666; margin-top: 4px; word-break: break-all;">${file.name}</div>
                        <div style="font-size: 10px; color: #999;">${(file.size / 1024 / 1024).toFixed(2)} MB</div>
                        <button onclick="removeImage(${index})" style="position: absolute; top: 2px; right: 2px; background: #ff4757; color: white; border: none; border-radius: 50%; width: 20px; height: 20px; font-size: 12px; cursor: pointer; display: flex; align-items: center; justify-content: center;">√ó</button>
                    `;
                    
                    // Êõ¥Êñ∞È†êË¶ΩÂÆπÂô®
                    const container = document.getElementById('imagePreview');
                    if (!container.querySelector('.preview-grid')) {
                        container.innerHTML = '<div class="preview-grid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 10px; margin-top: 15px;"></div>';
                    }
                    const grid = container.querySelector('.preview-grid');
                    grid.appendChild(previewItem);
                };
                reader.readAsDataURL(file);
            });
        }

        function removeImage(index) {
            selectedImages.splice(index, 1);
            updateFileInput();
            
            // ÈáçÊñ∞È°ØÁ§∫ÊâÄÊúâÈ†êË¶Ω
            imagePreview.innerHTML = '';
            if (selectedImages.length > 0) {
                displayImagePreviews();
            } else {
                uploadArea.classList.remove('has-file');
            }
            updateUploadAreaText();
        }

        function updateUploadAreaText() {
            const uploadText = document.querySelector('.upload-text');
            const imageCountDiv = document.getElementById('imageCount');
            
            if (selectedImages.length === 0) {
                uploadText.innerHTML = '<strong>Click to select image(s)</strong> or drag and drop them here<br><small>Supports JPG, PNG, GIF formats ‚Ä¢ Multi-select enabled ‚Ä¢ Max 50 images</small>';
                imageCountDiv.textContent = '';
            } else {
                const remaining = 50 - selectedImages.length;
                if (remaining > 0) {
                    uploadText.innerHTML = `<strong>${selectedImages.length}/50 image(s) selected</strong><br><small>Click to add ${remaining} more images or drag and drop</small>`;
                    imageCountDiv.textContent = `${selectedImages.length}/50 images selected`;
                } else {
                    uploadText.innerHTML = `<strong>50/50 images selected (Maximum reached)</strong><br><small>Remove some images to add different ones</small>`;
                    imageCountDiv.textContent = `50/50 images selected (Max reached)`;
                }
            }
        }

        function clearAllImages() {
            if (selectedImages.length === 0) {
                showError('No images to clear');
                return;
            }
            
            if (confirm(`Are you sure you want to remove all ${selectedImages.length} selected image(s)?`)) {
                selectedImages = [];
                updateFileInput();
                imagePreview.innerHTML = '';
                uploadArea.classList.remove('has-file');
                updateUploadAreaText();
                showSuccess('All images cleared');
            }
        }

        // ÂèñÂæó‰ΩµÁôº‰∏äÈôêÔºàËã•UIÂ∑≤ÁßªÈô§ÔºåÊèê‰æõÂÆâÂÖ®defaultÂÄºÔºâ
        function getConcurrencyLimit() {
            const el = document.getElementById('concurrencyLimit');
            const n = parseInt(el?.value || '10', 10);
            if (Number.isNaN(n) || n <= 0) return 10;
            return Math.min(n, 20);
        }

        // ÁîüÊàêË¶ñÈ†ª - ‰ΩøÁî®Êô∫ËÉΩÈöäÂàóÂíå‰ΩµÁôºÊéßÂà∂
        async function generateVideo() {
            const apiKey = document.getElementById('apiKey').value;
            const concurrencyLimit = getConcurrencyLimit();
            const imageFiles = Array.from(document.getElementById('imageFile').files);

            // È©óË≠âËº∏ÂÖ•
            if (!apiKey) {
                showError('Please enter your API Key');
                return;
            }
            if (imageFiles.length === 0) {
                showError('Please select at least one image file');
                return;
            }

            // ÂàùÂßãÂåñ
            clearMessages();
            setButtonLoading(true);
            showBatchProgress();
            
            // Â∞áÊâÄÊúâÂúñÁâáÊîæÂÖ•ÈöäÂàó
            imageQueue = [...imageFiles];
            const totalTasks = imageQueue.length;
            
            console.log('=== New Concurrent Task Submission ===');
            console.log('Selected images:', totalTasks);
            console.log('Concurrency Limit:', concurrencyLimit);
            console.log('====================================');
            
            showSuccess(`üöÄ Queued ${totalTasks} image(s) for generation...`);
            
            // ÂïüÂãïÈöäÂàóÁÆ°ÁêÜÂô®
            if (processingInterval) clearInterval(processingInterval);
            processingInterval = setInterval(() => queueManager(concurrencyLimit, totalTasks), 2000); // ÊØè2ÁßíÊ™¢Êü•‰∏ÄÊ¨°
            
            // Á´ãÂç≥Ëß∏Áôº‰∏ÄÊ¨°‰ª•Âø´ÈÄüÂïüÂãï
            queueManager(concurrencyLimit, totalTasks);

            // ÂïüÂãïÁãÄÊÖãËº™Ë©¢
            if (!statusCheckInterval) {
                startStatusCheck();
            }
        }
        
        // ËºîÂä©ÂáΩÊï∏ÔºöÊõ¥Êñ∞‰ªªÂãôÂç°ÁâáÂèäÂÖ∂ÊâÄÊúâÂ≠êÂÖÉÁ¥†ÁöÑID
        function updateCardIds(oldId, newId) {
            const card = document.getElementById(`task-${oldId}`);
            if (!card) return;

            // ÈÅ∏ÊìáÊâÄÊúâÂ∏∂ÊúâËàäIDÁöÑÂÖÉÁ¥†
            const elementsToUpdate = card.querySelectorAll(`[id$="-${oldId}"]`);
            
            elementsToUpdate.forEach(el => {
                el.id = el.id.replace(oldId, newId);
            });
            
            // Êõ¥Êñ∞‰∏ªÂç°ÁâáÁöÑID
            card.id = `task-${newId}`;
            
            // ÁâπÂà•ËôïÁêÜonclick‰∫ã‰ª∂
            const downloadLink = card.querySelector(`a[onclick*="'${oldId}'"]`);
            if (downloadLink) {
                downloadLink.setAttribute('onclick', `downloadTaskVideo('${newId}')`);
            }
        }

        // ÈöäÂàóÁÆ°ÁêÜÂô®
        function queueManager(_limit, totalTasks) {
            // ÊØèÊ¨°ÂãïÊÖãÂèñÂæó‰ΩµÁôº‰∏äÈôêÔºàUIÂèØËÉΩÂ∑≤Èö±ËóèÔºâ
            const concurrencyLimit = getConcurrencyLimit();
            const activeTasks = Array.from(tasks.values()).filter(t => !['completed', 'failed', 'finished', 'error'].includes(t.status)).length;
            const effectiveActive = activeTasks + pendingSubmissions; // ÊääÂ∞öÊú™Âä†ÂÖ• Map ÁöÑÊèê‰∫§‰πüÁÆóÈÄ≤Âéª
            const canSubmitCount = concurrencyLimit - effectiveActive;
            
            console.log(`[Queue Manager] Active (in Map): ${activeTasks}, Pending Submissions: ${pendingSubmissions}, Queue: ${imageQueue.length}, Can Submit: ${canSubmitCount}`);
            
            if (canSubmitCount > 0 && imageQueue.length > 0) {
                const itemsToSubmit = imageQueue.splice(0, canSubmitCount);
                console.log(`[Queue Manager] Submitting ${itemsToSubmit.length} new tasks.`);
                
                showSuccess(`Submitting ${itemsToSubmit.length} new tasks...`);

                // Â∏∂Êúâ‰∫§ÈåØÂª∂ÈÅ≤Âú∞Êèê‰∫§‰ªªÂãôÔºå‰ª•ÈÅøÂÖçË´ãÊ±ÇÈ¢®Êö¥
                (async () => {
                    for (const imageFile of itemsToSubmit) {
                        pendingSubmissions++; // Ê®ôË®òÁÇ∫Ê≠£Âú®Êèê‰∫§
                        submitTask(imageFile).finally(() => {
                            pendingSubmissions--; // Êèê‰∫§ÁµêÊùüÔºàÊàêÂäüÊàñÂ§±ÊïóÔºâ
                        });
                        await new Promise(resolve => setTimeout(resolve, 500)); // Â¢ûÂä†Âà∞500ms
                    }
                })();
            }
            
            const submittedCount = totalTasks - imageQueue.length;
            const completedCount = submittedCount - activeTasks;
            updateBatchProgress(completedCount, totalTasks, null, null, `Submitted: ${submittedCount}/${totalTasks} | Active: ${effectiveActive}`);

            // Â¶ÇÊûúÈöäÂàóÁÇ∫Á©∫‰∏îÊ≤íÊúâÊ¥ªÂãï‰ªªÂãôÔºåÂâáÂÅúÊ≠¢
            if (imageQueue.length === 0 && activeTasks === 0) {
                console.log('[Queue Manager] All tasks completed. Stopping manager.');
                clearInterval(processingInterval);
                processingInterval = null;
                setButtonLoading(false);
                
                const finalCompletedCount = Array.from(tasks.values()).filter(t => ['completed', 'finished'].includes(t.status)).length;
                showSuccess(`üéâ All ${finalCompletedCount}/${totalTasks} tasks processed!`);
                updateBatchProgress(finalCompletedCount, totalTasks, null, null, `All tasks processed!`);

                setTimeout(() => {
                    hideBatchProgress();
                }, 5000);
            }
        }

        // Êèê‰∫§ÂñÆÂÄã‰ªªÂãôÔºåÂåÖÂê´ÈáçË©¶ÈÇèËºØ
        async function submitTask(imageFile) {
            // Ëã•Êúâ Benchmark Ë¶ÜËìãÔºå‰ΩøÁî®Ë¶ÜËìãÂèÉÊï∏
            const apiKey = (window.benchmarkOverrideApiKey ?? document.getElementById('apiKey').value) || '';
            const apiConfig = window.benchmarkOverrideConfig || getCurrentAPIConfig();
            const promptText = (window.benchmarkOverridePrompt ?? document.getElementById('promptText').value) || '';
            const MAX_RETRIES = 20; // ÊèêÈ´òÈáçË©¶‰∏äÈôê
            const RETRY_DELAY = 8000; // 8ÁßíÈáçË©¶ÈñìÈöî

            let lastError = 'Unknown error';

            // ÂâµÂª∫‰∏ÄÂÄãËá®ÊôÇ‰ªªÂãôÁî®ÊñºUIÂ±ïÁ§∫
            const tempId = `submitting-${Date.now()}-${Math.random()}`;
            const task = createTask(tempId, promptText, imageFile.name);
            task.status = 'submitting';
            task.submittedAt = Date.now();
            // Â≠òÂÑ≤APIÈÖçÁΩÆ‰ø°ÊÅØÂà∞‰ªªÂãô
            task.apiProvider = apiConfig.provider;
            task.apiVersion = apiConfig.version;
            task.apiEndpointType = apiConfig.endpointType;
            task.apiKey = apiKey;
            tasks.set(tempId, task);
            createTaskCard(task);
            updateTaskCard(task);
            
            // Êõ¥Êñ∞API‰ø°ÊÅØÈ°ØÁ§∫
            const apiInfoElement = document.getElementById(`api-info-${tempId}`);
            if (apiInfoElement) {
                const providerConfig = API_PROVIDERS[apiConfig.provider];
                const baseUrl = providerConfig.baseUrl;
                const keyDisplay = apiKey ? `${apiKey.substring(0, 6)}...${apiKey.substring(apiKey.length - 6)}` : 'Server Default';
                const endpointInfo = apiConfig.endpointType ? ` | üéØ ${apiConfig.endpointType}` : '';
                apiInfoElement.innerHTML = `üìç ${apiConfig.provider} | üåê ${baseUrl} | üîó ${apiConfig.version}${endpointInfo} | üîë ${keyDisplay}`;
            }
            
            showTasksArea();

            // audio-to-video ÈúÄË¶ÅÈü≥È†ªÊñá‰ª∂ÔºåÁÑ°ÂâáÁõ¥Êé•Â§±Êïó‰∏¶ËøîÂõû
            if (apiConfig.endpointType === 'audio-to-video') {
                const audioInputPre = document.getElementById('audioFile');
                const audioFilePre = audioInputPre?.files?.[0];
                if (!audioFilePre) {
                    const errMsg = 'audio-to-video requires an audio file';
                    lastError = errMsg;
                    task.status = 'failed';
                    updateTaskCard(task);
                    showError(errMsg);
                    return;
                }
            }
            
            for (let attempt = 0; attempt <= MAX_RETRIES; attempt++) {
                task.retryCount = attempt;
                updateTaskCard(task);
                
                try {
                    if (attempt > 0) {
                        console.log(`[Retry] Attempt ${attempt}/${MAX_RETRIES} for ${imageFile.name}...`);
                        await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));
                    }

                    // Ê∫ñÂÇô FormData Âíå headers
                    const formData = new FormData();
                    formData.append('image', imageFile);
                    formData.append('provider', apiConfig.provider);
                    formData.append('version', apiConfig.version);
                    if (apiConfig.endpointType) formData.append('endpoint_type', apiConfig.endpointType);
                    // Â¶ÇÊûúÈÅ∏ÊìáÁöÑÊòØ audio-to-videoÔºåÈôÑÂ∏∂Èü≥È†ªÊñá‰ª∂
                    if (apiConfig.endpointType === 'audio-to-video') {
                        const audioInput = document.getElementById('audioFile');
                        const audioFile = audioInput?.files?.[0];
                        if (!audioFile) {
                            showError('audio-to-video requires an audio file');
                            throw new Error('Missing audio file');
                        }
                        formData.append('audio', audioFile);
                    }
                    if (promptText.trim()) formData.append('promptText', promptText.trim());
                    const headers = {};
                    if (apiKey) headers['X-API-KEY'] = apiKey; // Â¶ÇÊûúÁî®Êà∑Êèê‰æõ‰∫ÜAPI KeyÂ∞±‰ΩøÁî®ÔºåÂê¶Âàô‰ΩøÁî®ÊúçÂä°Âô®ÈªòËÆ§ÁöÑ
                    
            // Ë®òÈåÑË©≥Á¥∞ÁöÑAPIË™øÁî®‰ø°ÊÅØ
                    const providerConfig = API_PROVIDERS[apiConfig.provider];
                    const baseUrl = providerConfig.baseUrl;
                    const fullUrl = baseUrl + apiConfig.endpoint;
                    
                    console.log('=== Video Generation API Call ===');
                    console.log('üìç Provider:', apiConfig.provider);
                    console.log('üîó Version:', apiConfig.version);
                    if (apiConfig.endpointType) console.log('üéØ Endpoint Type:', apiConfig.endpointType);
                    console.log('üåê Base URL:', baseUrl);
                    console.log('üéØ Endpoint:', apiConfig.endpoint);
                    console.log('üîó Full URL:', fullUrl);
                    console.log('üöÄ Proxy Endpoint:', '/api/generate');
                    console.log('üîë API Key:', apiKey ? `${apiKey.substring(0, 8)}...${apiKey.substring(apiKey.length - 8)}` : 'Using default from server');
                    console.log('üìù Prompt:', promptText.trim() || 'No prompt');
                    console.log('üìé Image:', imageFile.name, `(${(imageFile.size / 1024).toFixed(2)} KB)`);
                    console.log('üìã Headers:', headers);
                    
                    const response = await fetch('/api/generate', { method: 'POST', headers, body: formData });
                    const result = await response.json().catch(() => ({}));
                    
                    // Ë®òÈåÑÈüøÊáâ‰ø°ÊÅØ
                    console.log('=== API Response ===');
                    console.log('üìä Status:', response.status, response.statusText);
                    console.log('üìù Result:', result);

                    if (response.ok) {
                        // È°ØÁ§∫Ë©≥Á¥∞ÁöÑÊàêÂäü‰ø°ÊÅØ
                    const successDetails = `
‚úÖ Video Generation Started Successfully!

üÜî Video ID: ${result.video_id}
üìç Provider: ${apiConfig.provider}${window.benchmarkLabel ? ` (${window.benchmarkLabel})` : ''}
üîó Version: ${apiConfig.version}
${apiConfig.endpointType ? `üéØ Endpoint Type: ${apiConfig.endpointType}` : ''}
üåê Base URL: ${baseUrl}
üéØ Endpoint: ${apiConfig.endpoint}
üîó Full URL: ${fullUrl}
üîë API Key: ${apiKey ? `${apiKey.substring(0, 8)}...${apiKey.substring(apiKey.length - 8)}` : 'Server Default'}
üìù Prompt: ${(window.benchmarkOverridePrompt ?? promptText).trim() || 'No prompt provided'}
üìé Image: ${imageFile.name} (${(imageFile.size / 1024).toFixed(2)} KB)
üèóÔ∏è Worker: ${result.worker || 'Not specified'}
üìä Status: ${result.status || 'pending'}
‚è∞ Time: ${new Date().toLocaleTimeString()}
                        `;
                        
                        console.log('=== Video Generation Success ===');
                        console.log(successDetails);
                        console.log(`‚úÖ Task submitted successfully: ${result.video_id} for ${imageFile.name}`);
                        
                        // Êèê‰∫§ÊàêÂäüÔºåÁî®ÁúüÂØ¶IDÊõøÊèõËá®ÊôÇID
                        const realId = result.video_id;
                        const oldApiInfo = document.getElementById(`api-info-${task.id}`);
                        const apiInfoContent = oldApiInfo ? oldApiInfo.innerHTML : '';
                        
                        tasks.delete(task.id); // Âà™Èô§Ëá®ÊôÇ‰ªªÂãô
                        
                        updateCardIds(task.id, realId); // Êõ¥Êñ∞DOM‰∏≠ÊâÄÊúâÁõ∏ÈóúID
                        
                        task.id = realId; // Êõ¥Êñ∞JSÂ∞çË±°ÁöÑID
                        task.status = 'waiting'; // ÈáçÁΩÆÁãÄÊÖã
                        // Â≠òÂÑ≤Ë©≥Á¥∞‰ø°ÊÅØÂà∞‰ªªÂãôÂ∞çË±°
                        task.submissionDetails = {
                            videoId: result.video_id,
                            provider: apiConfig.provider,
                            baseUrl: baseUrl,
                            endpoint: apiConfig.endpoint,
                            fullUrl: fullUrl,
                            apiKey: apiKey ? `${apiKey.substring(0, 8)}...${apiKey.substring(apiKey.length - 8)}` : 'Server Default',
                            prompt: promptText.trim() || 'No prompt provided',
                            imageInfo: `${imageFile.name} (${(imageFile.size / 1024).toFixed(2)} KB)`,
                            worker: result.worker || 'Not specified',
                            submittedAt: new Date().toLocaleTimeString()
                        };
                        tasks.set(realId, task); // Áî®ÁúüÂØ¶IDÂ≠òÂÑ≤
                        
                        // Á¢∫‰øùËº™Ë©¢Â∑≤ÂïüÂãï
                        if (!statusCheckInterval) {
                            try { startStatusCheck(); } catch {}
                        }

                        updateTaskCard(task); // Áî®Êñ∞IDÊõ¥Êñ∞‰∏ÄÊ¨°UI
                        
                        // ÊÅ¢Âæ©API‰ø°ÊÅØÈ°ØÁ§∫‰∏¶Ê∑ªÂä†Ë©≥Á¥∞‰ø°ÊÅØ
                        const newApiInfo = document.getElementById(`api-info-${realId}`);
                        if (newApiInfo) {
                            const enhancedApiInfo = `
üìç ${apiConfig.provider} | üåê ${baseUrl} | üîó ${apiConfig.version} | üîë ${apiKey ? `${apiKey.substring(0, 6)}...${apiKey.substring(apiKey.length - 6)}` : 'Server Default'}
<br><small>üèóÔ∏è Worker: ${result.worker || 'Not specified'} | ‚è∞ ${new Date().toLocaleTimeString()}</small>
                            `;
                            newApiInfo.innerHTML = enhancedApiInfo;
                        }
                        return; // ÊàêÂäüÔºåÈÄÄÂá∫Âæ™Áí∞
                    }
                    
                    lastError = result.detail || result.message || `HTTP ${response.status}`;
                    // Â¢ûÂä†Â∞çÁ∂≤Áµ°ÈåØË™§ÁöÑÂà§Êñ∑
                    if (response.status === 0 || !response.status) {
                        lastError = "Network Error. Is the proxy server running?";
                    }
                    const isRetryable = response.status === 429 || response.status >= 500;

                    if (isRetryable && attempt < MAX_RETRIES) {
                        console.warn(`[Retry] Will retry for ${imageFile.name}. Error: ${lastError}`);
                        task.status = `retrying (${attempt + 1})`;
                        updateTaskCard(task);
                        continue;
                    } else {
                        // ÈùûÂèØÈáçË©¶ÈåØË™§ÔºåÁõ¥Êé•Ê®ôË®òÂ§±Êïó‰∏¶ÁµêÊùü
                        task.status = 'failed';
                        updateTaskCard(task);
                        showError(lastError);
                        return;
                    }

                } catch (error) {
                    lastError = error.message || 'Request error';
                    // ÂÉÖÈáùÂ∞çÁ∂≤Ë∑ØÈ°ûÈåØË™§ÈáçË©¶
                    const isNetwork = lastError.toLowerCase().includes('network');
                    if (isNetwork && attempt < MAX_RETRIES) {
                        task.status = `retrying (${attempt + 1})`;
                        updateTaskCard(task);
                        continue;
                    }
                    // ÈùûÁ∂≤Ë∑ØÈåØË™§Áõ¥Êé•Â§±Êïó
                    task.status = 'failed';
                    updateTaskCard(task);
                    showError(lastError);
                    return;
                }
            }

            // ÊâÄÊúâÈáçË©¶Â§±Êïó
            console.error(`‚ùå Task failed for ${imageFile.name} after ${MAX_RETRIES} retries. Final error: ${lastError}`);
            task.status = 'failed';
            updateTaskCard(task);
        }

        // Ê™¢Êü•Ë¶ñÈ†ªÁãÄÊÖã
        async function checkVideoStatus() {
            const apiKey = document.getElementById('apiKey').value;
            const apiConfig = getCurrentAPIConfig();
            const baseUrl = '/';  // ‰ΩøÁî®Êú¨Âú∞‰ª£ÁêÜ
            
            // ÂÖÅË®±Êú™Ëº∏ÂÖ• API Key ÊôÇ‰ªçËº™Ë©¢ÔºåÂæåÁ´ØÊúÉ‰ΩøÁî®È†êË®≠ keyÔºàËã•ÊúâÔºâ
            
            const activeTasks = Array.from(tasks.values()).filter(task => 
                !['finished', 'completed', 'failed', 'error'].includes(task.status)
            );
            
            if (activeTasks.length === 0) {
                stopStatusCheck();
                return;
            }

            // Ê™¢Êü•ÊâÄÊúâÊ¥ªË∫ç‰ªªÂãô
            for (const task of activeTasks) {
                try {
                    // Ê∫ñÂÇô headersÔºàstaging ‰ΩøÁî®ÂæåÁ´ØÈÖçÁΩÆÁöÑ API KeyÔºâ
                    const headers = {
                        'Accept': 'application/json'
                    };
                    if (apiKey) {
                        headers['X-API-KEY'] = apiKey;
                    }
                    
                    const response = await fetch(`/videos/${task.id}?provider=${apiConfig.provider}`, {
                        headers: headers
                    });

                    if (response.ok) {
                        const result = await response.json();
                        updateTaskFromAPI(task, result);
                    }
                } catch (error) {
                    console.error(`Ê™¢Êü•‰ªªÂãô ${task.id} ÁãÄÊÖãÊôÇÂá∫ÈåØ:`, error);
                }
            }
            
            // Êõ¥Êñ∞Áµ±Ë®à
            updateTasksSummary();
        }

        function updateTaskFromAPI(task, result) {
            console.log(`=== Task #${task.taskNumber} Status Update ===`);
            console.log('Full API Response:', result);
            
            // Êõ¥Êñ∞‰ªªÂãôÊï∏Êìö
            const prevStatus = task.status;
            task.status = result.status || task.status;
            task.progress = result.progress || task.progress;
            task.url = result.url || task.url;
            
            // Ë®àÊôÇÔºöÁ≠âÂæÖÊôÇÈñìÔºàsubmitted -> startedÔºâËàáÁîüÊàêÊôÇÈñìÔºàstarted -> finishedÔºâ
            if (!task.startedAt && (task.status === 'started' || task.progress > 0)) {
                task.startedAt = Date.now();
                if (task.submittedAt) {
                    task.waitDurationSec = Math.max(0, Math.round((task.startedAt - task.submittedAt) / 1000));
                }
            }
            if (!task.finishedAt && (task.status === 'finished' || task.status === 'completed')) {
                task.finishedAt = Date.now();
                if (task.startedAt) {
                    task.genDurationSec = Math.max(0, Math.round((task.finishedAt - task.startedAt) / 1000));
                }
            }
            
            // ËàäÁöÑÈÄöÁî®Ë®àÊôÇÂÖºÂÆπÔºà‰øùÁïôÁèæÊúâUIÔºâ
            if (task.progress > 0 && !task.startTime) {
                task.startTime = Date.now();
                console.log(`‚è±Ô∏è Task #${task.taskNumber} timer started`);
            }
            
            // Â¶ÇÊûú‰ªªÂãôÂÆåÊàê‰∏îÈÇÑÊ≤íË®òÈåÑÁµêÊùüÊôÇÈñìÔºåË®òÈåÑÁµêÊùüÊôÇÈñì
            const isCompleted = ['completed', 'finished', 'done'].includes(task.status);
            if (isCompleted && !task.endTime) {
                task.endTime = Date.now();
                console.log(`üéâ Task #${task.taskNumber} completed!`);
            }
            
            // Êõ¥Êñ∞UI
            updateTaskCard(task);
            
            // Êõ¥Êñ∞Âà∞ Map ‰∏≠
            tasks.set(task.id, task);

            // Ëã•ÁÇ∫ BenchmarkÔºåÂòóË©¶Âêà‰ΩµÂà∞Â∑¶Âè≥Â∞çÊØî
            try { maybeRenderBenchmarkPair(task); } catch {}
        }

        // ‰∏ãËºâÊó•Ë™åÔºöËº∏Âá∫ CSVÔºåÂåÖÂê´ id, provider, version, endpointType, prompt, submittedAt, startedAt, finishedAt, waitSec, genSec
        function downloadLogs() {
            const header = [
                'taskNumber','id','provider','version','endpointType','prompt','submittedAt','startedAt','finishedAt','waitSec','genSec','status','url'
            ];
            const rows = [header.join(',')];
            for (const task of tasks.values()) {
                const submittedAt = task.submittedAt ? new Date(task.submittedAt).toLocaleString() : '';
                const startedAt = task.startedAt ? new Date(task.startedAt).toLocaleString() : '';
                const finishedAt = task.finishedAt ? new Date(task.finishedAt).toLocaleString() : '';
                const waitSec = task.waitDurationSec != null ? task.waitDurationSec : (task.submittedAt && task.startedAt ? Math.round((task.startedAt - task.submittedAt)/1000) : '');
                const genSec = task.genDurationSec != null ? task.genDurationSec : (task.startedAt && task.finishedAt ? Math.round((task.finishedAt - task.startedAt)/1000) : '');
                const provider = task.apiProvider || '';
                const version = task.apiVersion || '';
                const endpointType = task.apiEndpointType || '';
                const prompt = (task.promptText || '').replaceAll('\n',' ').replaceAll('"','""');
                const line = [
                    task.taskNumber,
                    `"${task.id}"`,
                    provider,
                    version,
                    endpointType,
                    `"${prompt}"`,
                    `"${submittedAt}"`,
                    `"${startedAt}"`,
                    `"${finishedAt}"`,
                    waitSec,
                    genSec,
                    task.status || '',
                    task.url || ''
                ].join(',');
                rows.push(line);
            }
            const csv = rows.join('\n');
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `parrot_logs_${new Date().toISOString().replace(/[:.]/g,'-')}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // ÈñãÂßãÁãÄÊÖãÊ™¢Êü•
        function startStatusCheck() {
            if (statusCheckInterval) {
                clearInterval(statusCheckInterval);
            }
            statusCheckInterval = setInterval(checkVideoStatus, 3000); // ÊØè3ÁßíÊ™¢Êü•‰∏ÄÊ¨°
            checkVideoStatus(); // Á´ãÂç≥Ê™¢Êü•‰∏ÄÊ¨°
        }

        // ÂÅúÊ≠¢ÁãÄÊÖãÊ™¢Êü•
        function stopStatusCheck() {
            if (statusCheckInterval) {
                clearInterval(statusCheckInterval);
                statusCheckInterval = null;
                console.log('‚èπÔ∏è All tasks completed, stopping status check');
            }
        }

        // È°ØÁ§∫ÁãÄÊÖãÂçÄÂüü
        function showStatusArea() {
            document.getElementById('statusArea').style.display = 'block';
        }

        // Ë®≠ÁΩÆÊåâÈàïËºâÂÖ•ÁãÄÊÖã
        function setButtonLoading(loading) {
            const btn = document.getElementById('generateBtn');
            if (!btn) return;
            // ÂßãÁµÇ‰øùÊåÅÂèØÈªûÊìäÔºå‰∏¶Á∂≠ÊåÅÂïüÂãïÊñáÊ°àÔºåÂÖÅË®±ÊåÅÁ∫åÊèê‰∫§
            btn.disabled = false;
            btn.textContent = 'üöÄ Start Generating Video(s)';
        }

        // ÊâπÈáèËôïÁêÜÈÄ≤Â∫¶Ê¢ùÁÆ°ÁêÜ
        function showBatchProgress() {
            document.getElementById('batchProgressArea').style.display = 'block';
        }

        function hideBatchProgress() {
            document.getElementById('batchProgressArea').style.display = 'none';
        }

        function updateBatchProgress(current, total, batchNumber, totalBatches, detail) {
            const progressPercent = total > 0 ? Math.round((current / total) * 100) : 0;
            const progressText = document.getElementById('batchProgressText');
            const progressFill = document.getElementById('batchProgressFill');
            const progressDetail = document.getElementById('batchProgressDetail');
            
            progressText.textContent = `Progress: ${current}/${total} tasks (${progressPercent}%)`;
            progressFill.style.width = `${progressPercent}%`;
            progressDetail.textContent = detail || 'Processing...';
        }

        // È°ØÁ§∫ÈåØË™§Ë®äÊÅØ
        function showError(message) {
            const errorArea = document.getElementById('errorArea');
            errorArea.innerHTML = `<div class="error-message">‚ùå ${message}</div>`;
        }

        // È°ØÁ§∫ÊàêÂäüË®äÊÅØ
        function showSuccess(message) {
            const errorArea = document.getElementById('errorArea');
            errorArea.innerHTML = `<div class="success-message">‚úÖ ${message}</div>`;
        }

        // Ê∏ÖÈô§Ë®äÊÅØ
        function clearMessages() {
            document.getElementById('errorArea').innerHTML = '';
        }

        // ‰ªªÂãôUIÁÆ°ÁêÜ
        function showTasksArea() {
            document.getElementById('tasksArea').style.display = 'block';
        }

        function createTaskCard(task) {
            const tasksList = document.getElementById('tasksList');
            
            const taskCard = document.createElement('div');
            taskCard.className = 'task-card';
            taskCard.id = `task-${task.id}`;
            
            taskCard.innerHTML = `
                <div class="task-header">
                    <div class="task-title">üìã Task #${task.taskNumber}</div>
                    <div class="task-status processing" id="status-${task.id}">Processing</div>
                </div>
                <div class="task-details">
                    <div class="task-detail-item">
                        <div class="task-detail-label">Video ID</div>
                        <div class="task-detail-value" style="font-size: 11px;">${task.id.substring(0, 12)}...</div>
                    </div>
                    <div class="task-detail-item">
                        <div class="task-detail-label">Progress</div>
                        <div class="task-detail-value" id="progress-${task.id}">0%</div>
                    </div>
                    <div class="task-detail-item">
                        <div class="task-detail-label">Wait</div>
                        <div class="task-detail-value" id="wait-${task.id}">-</div>
                    </div>
                    <div class="task-detail-item">
                        <div class="task-detail-label">Gen</div>
                        <div class="task-detail-value" id="gen-${task.id}">-</div>
                    </div>
                    <div class="task-detail-item">
                        <div class="task-detail-label">‚è±Ô∏è Time</div>
                        <div class="task-detail-value" id="time-${task.id}">Waiting...</div>
                    </div>
                    <div class="task-detail-item">
                        <div class="task-detail-label">üîÅ Retries</div>
                        <div class="task-detail-value" id="retries-${task.id}">${task.retryCount}</div>
                    </div>
                </div>
                <div style="font-size: 13px; color: #666; margin-bottom: 8px;">
                    üñºÔ∏è Image: ${task.imageName} | üí¨ Prompt: ${task.promptText || 'None'}
                </div>
                <div style="font-size: 12px; color: #888; margin-bottom: 10px; padding: 5px; background: #f8f9fa; border-radius: 3px;" id="api-info-${task.id}">
                    üìç API: Loading... | üîó Version: Loading... | üîë Key: Loading...
                </div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill-${task.id}"></div>
                </div>
                <div class="task-video" id="video-${task.id}" style="display: none;"></div>
            `;
            
            // ÊèíÂÖ•Âà∞ÊúÄÂâçÈù¢ÔºàÊúÄÊñ∞ÁöÑ‰ªªÂãôÂú®‰∏äÈù¢Ôºâ
            tasksList.insertBefore(taskCard, tasksList.firstChild);
        }

        function updateTaskCard(task) {
            const statusElement = document.getElementById(`status-${task.id}`);
            const progressElement = document.getElementById(`progress-${task.id}`);
            const timeElement = document.getElementById(`time-${task.id}`);
            const waitElement = document.getElementById(`wait-${task.id}`);
            const genElement = document.getElementById(`gen-${task.id}`);
            const progressFillElement = document.getElementById(`progress-fill-${task.id}`);
            const taskCard = document.getElementById(`task-${task.id}`);
            const retriesElement = document.getElementById(`retries-${task.id}`);
            
            if (!statusElement) return;

            // Êõ¥Êñ∞ÈáçË©¶Ê¨°Êï∏
            if(retriesElement) retriesElement.textContent = task.retryCount;
            
            // Êõ¥Êñ∞ÈÄ≤Â∫¶
            progressElement.textContent = `${task.progress}%`;
            progressFillElement.style.width = `${task.progress}%`;
            
            // Êõ¥Êñ∞ÊôÇÈñì
            if (task.startTime) {
                const elapsed = task.endTime ? 
                    Math.floor((task.endTime - task.startTime) / 1000) :
                    Math.floor((Date.now() - task.startTime) / 1000);
                
                const minutes = Math.floor(elapsed / 60);
                const seconds = elapsed % 60;
                const timeText = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
                
                timeElement.textContent = task.endTime ? 
                    `‚úÖ ${timeText}` : 
                    `üîÑ ${timeText}`;
                    
                task.duration = elapsed;
            }

            // Êñ∞Â¢ûÔºöÈ°ØÁ§∫Á≠âÂæÖ/ÁîüÊàêÊôÇÈñìÔºàÂç≥ÊôÇÊõ¥Êñ∞ÔºåÂèÉËÄÉ time ÁöÑÂãïÊÖãÈ°ØÁ§∫ÈÇèËºØÔºâ
            if (waitElement) {
                let waitSec = null;
                if (task.submittedAt) {
                    if (task.startedAt) {
                        // Â∑≤ÈñãÂßãÔºåÂõ∫ÂÆöÁÇ∫Êèê‰∫§Âà∞ÈñãÂßãÁöÑËÄóÊôÇ
                        const fixed = task.waitDurationSec ?? Math.round((task.startedAt - task.submittedAt) / 1000);
                        waitSec = Math.max(0, fixed);
                    } else {
                        // Êú™ÈñãÂßãÔºåÂãïÊÖãÁ¥ØÂä†
                        waitSec = Math.max(0, Math.round((Date.now() - task.submittedAt) / 1000));
                    }
                }
                waitElement.textContent = waitSec != null ? `${waitSec}s` : '-';
            }
            if (genElement) {
                let genSec = null;
                if (task.startedAt) {
                    if (task.finishedAt) {
                        // Â∑≤ÂÆåÊàêÔºåÂõ∫ÂÆöÁÇ∫ÈñãÂßãÂà∞ÂÆåÊàêÁöÑËÄóÊôÇ
                        const fixed = task.genDurationSec ?? Math.round((task.finishedAt - task.startedAt) / 1000);
                        genSec = Math.max(0, fixed);
                    } else {
                        // ÁîüÊàê‰∏≠ÔºåÂãïÊÖãÁ¥ØÂä†
                        genSec = Math.max(0, Math.round((Date.now() - task.startedAt) / 1000));
                    }
                }
                genElement.textContent = genSec != null ? `${genSec}s` : '-';
            }
            
            // Êõ¥Êñ∞ÁãÄÊÖã
            statusElement.className = 'task-status';
            if (task.status === 'finished' || task.status === 'completed') {
                statusElement.classList.add('completed');
                statusElement.textContent = '‚úÖ Completed';
                taskCard.classList.add('completed');
                
                if (task.url) {
                    showTaskVideo(task);
                }
            } else if (task.status === 'failed' || task.status === 'error') {
                statusElement.classList.add('failed');
                statusElement.textContent = '‚ùå Failed';
                taskCard.classList.add('failed');
            } else if (task.status.startsWith('retrying')) {
                statusElement.classList.add('processing');
                statusElement.textContent = `‚è≥ Retrying...`;
            } else if (task.status === 'submitting') {
                statusElement.classList.add('processing');
                statusElement.textContent = `üì§ Submitting...`;
            } else {
                statusElement.classList.add('processing');
                statusElement.textContent = 'üîÑ Processing';
            }
        }

        function showTaskVideo(task) {
            const videoContainer = document.getElementById(`video-${task.id}`);
            if (!videoContainer || !task.url) return;
            
            videoContainer.style.display = 'block';
            const label = task.benchmarkLabel ? `<span style="margin-right:8px; padding:2px 6px; border-radius:10px; background:#eef; color:#335; font-size:12px;">${task.benchmarkLabel}</span>` : '';
            const endpointInfo = task.submissionDetails ? `${task.submissionDetails.endpoint}` : '';
            const promptInfo = (task.promptText || '').replaceAll('<','&lt;').replaceAll('>','&gt;');
            videoContainer.innerHTML = `
                <div style="display:flex; flex-direction:column; gap:6px; align-items:center;">
                    <div style="font-size:12px; color:#666;">${label}${endpointInfo}</div>
                    <video controls width="60%" preload="metadata" style="display: block; margin: 6px auto;">
                        <source src="${task.url}" type="video/mp4">
                        Your browser does not support video playback.
                    </video>
                    <div style="font-size:12px; color:#555; max-width:60%; white-space:pre-wrap; word-break:break-word;">üìù ${promptInfo || 'No prompt'}</div>
                    <div style="margin-top: 6px; font-size: 12px; color: #666;">
                        üé¨ <a href="${task.url}" target="_blank" style="color: #4facfe;">Open Video</a> |
                        <a href="javascript:void(0)" onclick="downloadTaskVideo('${task.id}')" style="color: #4facfe;">üíæ Download</a>
                    </div>
                </div>
            `;
        }

        // ==== Benchmark Â∞çÊØîÊ∏≤Êüì ====
        function getPairKey(task) {
            // ‰ª•ÂúñÁâáÂêç‰ΩúÁÇ∫ÈÖçÂ∞çÈçµ
            return (task.imageName || '').toLowerCase();
        }

        function maybeRenderBenchmarkPair(task) {
            if (!task.benchmarkLabel) return; // Èùû Benchmark Ë∑≥ÈÅé
            const pairKey = getPairKey(task);
            if (!pairKey) return;
            // ÊâæÂêåÂúñÂè¶‰∏ÄÂçä
            const other = Array.from(tasks.values()).find(t => t !== task && t.imageName === task.imageName && t.benchmarkLabel && t.url);
            if (!other || !task.url) return;

            // ÊßãÂª∫Â∑¶Âè≥Â∞çÊØîÂç°
            const container = document.getElementById('benchmarkResults');
            const pairs = document.getElementById('benchmarkPairs');
            if (!container || !pairs) return;
            container.style.display = 'block';

            const promptA = task.benchmarkLabel === 'A' ? (task.promptText || '') : (other.promptText || '');
            const promptB = task.benchmarkLabel === 'B' ? (task.promptText || '') : (other.promptText || '');
            const endpointA = task.benchmarkLabel === 'A' ? (task.submissionDetails?.endpoint || '') : (other.submissionDetails?.endpoint || '');
            const endpointB = task.benchmarkLabel === 'B' ? (task.submissionDetails?.endpoint || '') : (other.submissionDetails?.endpoint || '');

            const safe = s => (s || '').replaceAll('<','&lt;').replaceAll('>','&gt;');

            const pairDiv = document.createElement('div');
            pairDiv.style.cssText = 'display:flex; gap:12px; align-items:flex-start; justify-content:center;';
            pairDiv.innerHTML = `
                <div style="flex:1; text-align:center; background:#fff; border:1px solid #e1e5e9; border-radius:6px; padding:8px;">
                    <div style="font-size:12px; color:#666; margin-bottom:4px;">A ‚Ä¢ ${safe(endpointA)}</div>
                    <video controls width="100%" preload="metadata" style="max-width:420px;">
                        <source src="${task.benchmarkLabel === 'A' ? task.url : other.url}" type="video/mp4">
                    </video>
                    <div style="font-size:12px; color:#555; white-space:pre-wrap; word-break:break-word; margin-top:4px;">üìù ${safe(promptA)}</div>
                </div>
                <div style="flex:1; text-align:center; background:#fff; border:1px solid #e1e5e9; border-radius:6px; padding:8px;">
                    <div style="font-size:12px; color:#666; margin-bottom:4px;">B ‚Ä¢ ${safe(endpointB)}</div>
                    <video controls width="100%" preload="metadata" style="max-width:420px;">
                        <source src="${task.benchmarkLabel === 'B' ? task.url : other.url}" type="video/mp4">
                    </video>
                    <div style="font-size:12px; color:#555; white-space:pre-wrap; word-break:break-word; margin-top:4px;">üìù ${safe(promptB)}</div>
                </div>
            `;
            // ‰øùÂ≠ò URL ÊñºÁØÄÈªûÂ±¨ÊÄßÔºå‰æøÊñº‰∏ÄÈçµ‰∏ãËºâÂêà‰Ωµ
            pairDiv.dataset.leftUrl = task.benchmarkLabel === 'A' ? task.url : other.url;
            pairDiv.dataset.rightUrl = task.benchmarkLabel === 'B' ? task.url : other.url;
            pairs.prepend(pairDiv);
        }

        async function downloadMergedBenchmark() {
            try {
                const pairs = document.getElementById('benchmarkPairs');
                if (!pairs || !pairs.firstElementChild) { showError('No benchmark pairs to download'); return; }
                const first = pairs.firstElementChild;
                const leftUrl = first.dataset.leftUrl;
                const rightUrl = first.dataset.rightUrl;
                if (!leftUrl || !rightUrl) { showError('Pair URLs missing'); return; }
                const form = new FormData();
                form.append('left_url', leftUrl);
                form.append('right_url', rightUrl);
                form.append('filename', 'benchmark_merged.mp4');
                // ÂÑ™ÂÖà‰ΩøÁî®Êú¨Âú∞Âêà‰ΩµÊúçÂãô
                let resp;
                try {
                    resp = await fetch('http://localhost:55003/benchmark/merge', { method: 'POST', body: form, mode: 'cors' });
                } catch (e) { resp = null; }
                if (!resp || !resp.ok) {
                    resp = await fetch('/benchmark/merge', { method: 'POST', body: form });
                }
                if (!resp.ok) { const t = await resp.text(); throw new Error(t || 'merge failed'); }
                const blob = await resp.blob();
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url; a.download = 'benchmark_merged.mp4';
                document.body.appendChild(a); a.click(); document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showSuccess('‚úÖ Merged video downloaded');
            } catch (e) {
                showError('Merge download failed: ' + (e.message || e));
            }
        }

        async function downloadMergedAll() {
            try {
                const pairs = document.getElementById('benchmarkPairs');
                const list = [];
                Array.from(pairs.children).forEach((node, idx) => {
                    const leftUrl = node.dataset.leftUrl;
                    const rightUrl = node.dataset.rightUrl;
                    if (leftUrl && rightUrl) {
                        const baseName = (node.querySelector('video source')?.src || '').split('/').pop().replace(/\.mp4$/i,'') || `pair_${idx+1}`;
                        list.push({ left_url: leftUrl, right_url: rightUrl, filename: `${baseName}_merged.mp4` });
                    }
                });
                if (list.length === 0) { showError('No pairs available'); return; }
                let resp = null;
                // ÂÑ™ÂÖàÂòóË©¶Êú¨Âú∞Âêà‰ΩµÊúçÂãô
                try {
                    resp = await fetch('http://localhost:55003/benchmark/merge_batch', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ pairs: list }), mode: 'cors' });
                } catch (e) { resp = null; }
                if (!resp || !resp.ok) {
                    resp = await fetch('/benchmark/merge_batch', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ pairs: list }) });
                }
                if (!resp.ok) {
                    // Á∑ö‰∏äÁí∞Â¢ÉÁÑ° ffmpeg ÊôÇÈÄÄÂåñÁÇ∫ÊâìÂåÖÂéüË¶ñÈ†ª
                    resp = await fetch('/benchmark/zip_pairs', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ pairs: list }) });
                    if (!resp.ok) { const t = await resp.text(); throw new Error(t || 'merge batch/zip fallback failed'); }
                }
                const blob = await resp.blob();
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a'); a.href = url; a.download = 'benchmark_merged_all.zip';
                document.body.appendChild(a); a.click(); document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showSuccess('‚úÖ All merged videos downloaded as ZIP');
            } catch (e) {
                showError('Merge batch download failed: ' + (e.message || e));
            }
        }

        async function downloadTaskVideo(taskId) {
            const task = tasks.get(taskId);
            if (!task || !task.url) {
                showError('Ë¶ñÈ†ªË≥áË®ä‰∏çÂÆåÊï¥ÔºåÁÑ°Ê≥ï‰∏ãËºâ');
                return;
            }
            
            try {
                // ÁîüÊàêÂü∫ÊñºÂúñÁâáÂêçÁ®±ÁöÑÊñá‰ª∂ÂêçÔºåÊ∑ªÂä†‰ªªÂãôIDÁ¢∫‰øùÂîØ‰∏ÄÊÄß
                const imageName = (task.imageName || '').replace(/\.[^/.]+$/, '') || 'video';
                const shortTaskId = task.id.substring(0, 8); // ‰ΩøÁî®‰ªªÂãôIDÂâç8‰Ωç
                const defaultFileName = `${imageName}.mp4`;
                
                console.log('üîÑ Downloading single video:', {
                    taskId: task.id,
                    imageName: task.imageName,
                    url: task.url,
                    defaultFileName: defaultFileName,
                    fullTask: task
                });
                
                // Ê™¢Êü•ÊòØÂê¶ÊîØÊè¥ File System Access API (Chrome 86+) ‰∏îÂú® HTTPS Áí∞Â¢É
                const isSecureContext = window.isSecureContext || location.protocol === 'https:';
                const hasFileSystemAPI = 'showSaveFilePicker' in window;
                
                console.log('File System API availability:', {
                    hasFileSystemAPI,
                    isSecureContext,
                    protocol: location.protocol
                });
                
                if (hasFileSystemAPI && isSecureContext) {
                    try {
                        // ‰ΩøÁî®Êñ∞ÁöÑ File System Access API ËÆìÁî®Êà∂ÈÅ∏ÊìáÂ≠òÂÑ≤‰ΩçÁΩÆ
                        const fileHandle = await window.showSaveFilePicker({
                            suggestedName: defaultFileName,
                            types: [{
                                description: 'Video files',
                                accept: {
                                    'video/mp4': ['.mp4']
                                }
                            }]
                        });
                        
                        showSuccess('ÈñãÂßã‰∏ãËºâË¶ñÈ†ª...');
                        
                        const response = await fetch(task.url, {
                            method: 'GET',
                            headers: {
                                'Accept': 'video/mp4,video/*,*/*'
                            }
                        });
                        
                        if (!response.ok) {
                            throw new Error(`‰∏ãËºâÂ§±Êïó: ${response.status} ${response.statusText}`);
                        }
                        
                        const writableStream = await fileHandle.createWritable();
                        await response.body.pipeTo(writableStream);
                        
                        showSuccess('‚úÖ Ë¶ñÈ†ª‰∏ãËºâÊàêÂäüÔºÅ');
                        return;
                    } catch (filePickerError) {
                        if (filePickerError.name === 'AbortError') {
                            showError('‰∏ãËºâÂ∑≤ÂèñÊ∂à');
                            return;
                        }
                        console.log('üìù File picker failed, falling back to regular download:', filePickerError.message);
                    }
                }
                
                // ÈôçÁ¥öÂà∞ÂÇ≥Áµ±‰∏ãËºâÊñπÂºè
                showSuccess('ÈñãÂßã‰∏ãËºâË¶ñÈ†ª...');
                
                const response = await fetch(task.url, {
                    method: 'GET',
                    headers: {
                        'Accept': 'video/mp4,video/*,*/*'
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`‰∏ãËºâÂ§±Êïó: ${response.status} ${response.statusText}`);
                }
                
                const blob = await response.blob();
                
                // ÂâµÂª∫‰∏ãËºâÈÄ£Áµê
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = defaultFileName;
                
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                // Ê∏ÖÁêÜ blob URL
                window.URL.revokeObjectURL(url);
                
                showSuccess(`‚úÖ Ë¶ñÈ†ª‰∏ãËºâÊàêÂäüÔºÅÊ™îÂêçÔºö${defaultFileName}`);
                
            } catch (error) {
                console.error('‚ùå Download failed:', error);
                showError(`‰∏ãËºâÂ§±Êïó: ${error.message}`);
                
                // Â¶ÇÊûú fetch Â§±ÊïóÔºåÂòóË©¶Áõ¥Êé•ÊâìÈñãÈÄ£Áµê
                console.log('üîÑ Fallback: Opening video URL directly');
                window.open(task.url, '_blank');
            }
        }

        function updateTasksSummary() {
            const totalTasksElement = document.getElementById('totalTasks');
            const averageTimeElement = document.getElementById('averageTime');
            
            const completedTasks = Array.from(tasks.values()).filter(task => 
                task.endTime && (task.status === 'finished' || task.status === 'completed')
            );
            
            totalTasksElement.textContent = tasks.size;
            
            if (completedTasks.length > 0) {
                const totalTime = completedTasks.reduce((sum, task) => sum + task.duration, 0);
                const avgTime = Math.round(totalTime / completedTasks.length);
                const minutes = Math.floor(avgTime / 60);
                const seconds = avgTime % 60;
                
                const avgText = minutes > 0 ? `${minutes}m ${seconds}s` : `${seconds}s`;
                averageTimeElement.textContent = `${avgText} (${completedTasks.length}/${tasks.size})`;
            } else {
                averageTimeElement.textContent = '-';
            }
            
            // È°ØÁ§∫/Èö±Ëóè‰∏ãËºâÊåâÈàï
            const downloadBtn = document.getElementById('downloadAllBtn');
            const completedVideos = Array.from(tasks.values()).filter(task => 
                (task.status === 'finished' || task.status === 'completed') && task.url
            );
            
            if (downloadBtn) {
                if (completedVideos.length > 0) {
                    downloadBtn.style.display = 'block';
                    downloadBtn.textContent = `üì¶ Download All Completed Videos (${completedVideos.length})`;
                } else {
                    downloadBtn.style.display = 'none';
                }
            }
        }

        // ‰∏ãËºâÊâÄÊúâÂÆåÊàêÁöÑË¶ñÈ†ª
        async function downloadAllVideos() {
            console.log('üîÑ Starting batch download...');
            
            const completedVideos = Array.from(tasks.values()).filter(task => 
                (task.status === 'finished' || task.status === 'completed') && task.url
            );
            
            console.log(`üìã Found ${completedVideos.length} completed videos:`, completedVideos.map(t => ({
                id: t.id,
                imageName: t.imageName,
                promptText: t.promptText,
                url: t.url
            })));
            
            if (completedVideos.length === 0) {
                showError('No completed videos to download');
                return;
            }
            
            const downloadBtn = document.getElementById('downloadAllBtn');
            const originalText = downloadBtn.textContent;
            downloadBtn.disabled = true;
            downloadBtn.textContent = 'üì• Downloading...';
            
            try {
                let successCount = 0;
                let failCount = 0;
                
                for (let i = 0; i < completedVideos.length; i++) {
                    const task = completedVideos[i];
                    
                    try {
                        console.log(`üì• Downloading video ${i + 1}/${completedVideos.length}:`, {
                            taskId: task.id,
                            imageName: task.imageName,
                            url: task.url
                        });
                        
                        // ‰ΩøÁî® fetch ‰∏ãËºâË¶ñÈ†ªÊñá‰ª∂
                        const response = await fetch(task.url, {
                            method: 'GET',
                            headers: {
                                'Accept': 'video/mp4,video/*,*/*'
                            }
                        });
                        
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        
                        const blob = await response.blob();
                        
                        // ÂâµÂª∫‰∏ãËºâÈÄ£Áµê
                        const url = window.URL.createObjectURL(blob);
                        const link = document.createElement('a');
                        link.href = url;
                        
                        // ‰ΩøÁî®ÂúñÁâáÂêçÁ®±‰ΩúÁÇ∫Ë¶ñÈ†ªÊ™îÂêçÔºåÊ∑ªÂä†‰ªªÂãôIDÁ¢∫‰øùÂîØ‰∏ÄÊÄß
                        const imageName = (task.imageName || '').replace(/\.[^/.]+$/, '') || `video_${task.taskNumber}`;
                        const fileName = `${imageName}.mp4`;
                        link.download = fileName;
                        link.style.display = 'none';
                        
                        console.log(`üíæ Download filename: ${fileName}`);
                        
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        
                        // Ê∏ÖÁêÜ blob URL
                        window.URL.revokeObjectURL(url);
                        
                        successCount++;
                        
                        // Êõ¥Êñ∞ÊåâÈàïÊñáÂ≠óÈ°ØÁ§∫ÈÄ≤Â∫¶
                        downloadBtn.textContent = `üì• Downloading... (${i + 1}/${completedVideos.length})`;
                        
                        // Áü≠Êö´Âª∂ÈÅ≤ÈÅøÂÖçÁÄèË¶ΩÂô®ÈòªÊ≠¢Â§öÂÄã‰∏ãËºâ
                        if (i < completedVideos.length - 1) {
                            await new Promise(resolve => setTimeout(resolve, 800));
                        }
                        
                    } catch (error) {
                        console.error(`‚ùå Failed to download video ${task.taskNumber}:`, error);
                        failCount++;
                    }
                }
                
                // È°ØÁ§∫ÁµêÊûú
                if (successCount === completedVideos.length) {
                    showSuccess(`‚úÖ Successfully started download for all ${successCount} video(s)!`);
                } else if (successCount > 0) {
                    showSuccess(`‚ö†Ô∏è Downloaded ${successCount}/${completedVideos.length} video(s). ${failCount} failed.`);
                } else {
                    showError(`‚ùå Failed to download any videos. Please try downloading individually.`);
                }
                
                // Á¢∫‰øù‰ªªÂãôÁãÄÊÖã‰øùÊåÅ‰∏çËÆä
                console.log(`üìä Tasks status after download:`, Array.from(tasks.values()).length, 'tasks remaining');
                
            } catch (error) {
                console.error('‚ùå Batch download error:', error);
                showError(`Download failed: ${error.message}`);
            } finally {
                downloadBtn.disabled = false;
                downloadBtn.textContent = originalText;
                
                // Âº∑Âà∂Êõ¥Êñ∞‰ªªÂãôÊëòË¶Å‰ª•Á¢∫‰øùUIÊ≠£Á¢∫
                updateTasksSummary();
            }
        }

        // Ë™øË©¶‰ªªÂãôÊï∏Êìö
        function debugTasks() {
            console.log('=== Debug Tasks Info ===');
            console.log('Total tasks:', tasks.size);
            console.log('Tasks Map:', tasks);
            
            Array.from(tasks.values()).forEach((task, index) => {
                console.log(`Task ${index + 1}:`, {
                    id: task.id,
                    taskNumber: task.taskNumber,
                    imageName: task.imageName,
                    promptText: task.promptText,
                    status: task.status,
                    url: task.url
                });
            });
            
            showSuccess('Ë™øË©¶‰ø°ÊÅØÂ∑≤Ëº∏Âá∫Âà∞ÊéßÂà∂Âè∞ÔºåË´ãÊåâF12Êü•Áúã');
        }

        // Ê∏¨Ë©¶ÈÄ£Êé•ÂäüËÉΩ
        async function testConnection() {
            console.log('testConnection function called');
            
            const apiKey = document.getElementById('apiKey').value;
            const apiConfig = getCurrentAPIConfig();
            const apiUrl = apiConfig.endpoint;

            if (!apiKey) {
                showError('Please enter API Key first');
                return;
            }

            clearMessages();
            
            // Áç≤ÂèñÂÆåÊï¥URL‰ø°ÊÅØ
            const providerConfig = API_PROVIDERS[apiConfig.provider];
            const baseUrl = providerConfig.baseUrl;
            const fullUrl = baseUrl + apiConfig.endpoint;
            
            // ‰ΩøÁî®Ê≠£Á¢∫ÁöÑ API KeyÔºàÂ¶ÇÊûúÁî®Êà∂Ê≤íÊúâËº∏ÂÖ•Ôºå‰ΩøÁî®ÈÖçÁΩÆ‰∏≠ÁöÑdefaultÂÄºÔºâ
            const effectiveApiKey = apiKey || providerConfig.apiKey;
            
            // È°ØÁ§∫Ë™øË©¶‰ø°ÊÅØ
            const debugInfo = `
üîç <strong>Test Connection Debug Info:</strong><br>
üìç <strong>Provider:</strong> ${apiConfig.provider}<br>
üîó <strong>API Version:</strong> ${apiConfig.version}<br>
üåê <strong>Base URL:</strong> ${baseUrl}<br>
üéØ <strong>Endpoint:</strong> ${apiConfig.endpoint}<br>
üîó <strong>Full URL:</strong> ${fullUrl}<br>
üîë <strong>API Key:</strong> ${effectiveApiKey.substring(0, 8)}...${effectiveApiKey.substring(effectiveApiKey.length - 8)}<br>
‚è≥ Sending test request...
            `;
            showSuccess(debugInfo);

            try {
                console.log('=== Test Connection Debug Info ===');
                console.log('Provider:', apiConfig.provider);
                console.log('API Version:', apiConfig.version);
                console.log('Base URL:', baseUrl);
                console.log('Endpoint:', apiConfig.endpoint);
                console.log('Full URL:', fullUrl);
                console.log('Proxy Endpoint:', apiUrl);
                console.log('API Key:', `${apiKey.substring(0, 8)}...${apiKey.substring(apiKey.length - 8)}`);

                // ÂâµÂª∫‰∏ÄÂÄãÊúÄÂ∞èÁöÑÊ∏¨Ë©¶Ë´ãÊ±ÇÈ´î
                const formData = new FormData();
                formData.append('prompt', 'test connection');
                formData.append('provider', getCurrentAPIConfig().provider);
                formData.append('version', getCurrentAPIConfig().version);
                
                // ÂâµÂª∫‰∏ÄÂÄã1x1ÂÉèÁ¥†ÁöÑÊ∏¨Ë©¶ÂúñÁâá
                const canvas = document.createElement('canvas');
                canvas.width = 1;
                canvas.height = 1;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = '#000000';
                ctx.fillRect(0, 0, 1, 1);
                
                // Â∞ácanvasËΩâÊèõÁÇ∫blob
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
                formData.append('image', blob, 'test.png');

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'X-API-KEY': effectiveApiKey
                    },
                    body: formData
                });

                console.log('=== Response Info ===');
                console.log('Status:', response.status, response.statusText);
                console.log('Headers:', [...response.headers.entries()]);

                // ËÆÄÂèñÈüøÊáâÂÖßÂÆπ
                let responseText = '';
                try {
                    responseText = await response.text();
                    console.log('Response content:', responseText);
                } catch (e) {
                    console.log('Could not read response content:', e);
                    responseText = 'Could not read response content';
                }

                // È°ØÁ§∫ÂÆåÊï¥ÁöÑÊ∏¨Ë©¶ÁµêÊûú
                const resultInfo = `
üîç <strong>Test Connection Results:</strong><br>
üìç <strong>Provider:</strong> ${apiConfig.provider}<br>
üîó <strong>API Version:</strong> ${apiConfig.version}<br>
üåê <strong>Base URL:</strong> ${baseUrl}<br>
üéØ <strong>Endpoint:</strong> ${apiConfig.endpoint}<br>
üîó <strong>Full URL:</strong> ${fullUrl}<br>
üîë <strong>API Key:</strong> ${effectiveApiKey.substring(0, 8)}...${effectiveApiKey.substring(effectiveApiKey.length - 8)}<br>
üìä <strong>Response Status:</strong> ${response.status} ${response.statusText}<br>
üìù <strong>Response Content:</strong><br>
<pre style="background: #f5f5f5; padding: 10px; border-radius: 5px; max-height: 200px; overflow-y: auto; font-size: 12px; white-space: pre-wrap;">${responseText}</pre>
                `;

                if (response.status === 200 || response.status === 201 || response.status === 202) {
                    showSuccess(resultInfo + '<br>‚úÖ <strong>Connection test successful!</strong>');
                } else if (response.status === 401) {
                    showError(resultInfo + '<br>‚ùå <strong>Authentication failed: API Key might be invalid</strong>');
                } else if (response.status === 403) {
                    showError(resultInfo + '<br>‚ùå <strong>Forbidden: API Key might not have access</strong>');
                } else if (response.status === 404) {
                    showError(resultInfo + '<br>‚ùå <strong>API endpoint not found: Please check the URL</strong>');
                } else if (response.status === 400) {
                    showError(resultInfo + '<br>‚ö†Ô∏è <strong>Bad Request: API Key or request format may be incorrect</strong>');
                } else if (response.status === 500) {
                    showError(resultInfo + '<br>‚ö†Ô∏è <strong>Server Error: API service may be temporarily unavailable</strong>');
                } else {
                    showError(resultInfo + `<br>‚ö†Ô∏è <strong>Received response status: ${response.status} ${response.statusText}</strong>`);
                }

            } catch (error) {
                console.error('Connection test error:', error);
                
                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    showError('‚ùå Network Error: Could not connect to server. Check URL and network connection.');
                } else if (error.message.includes('CORS')) {
                    showError('‚ùå CORS Error: Cross-origin request blocked by browser.');
                } else {
                    showError(`‚ùå Connection failed: ${error.message}`);
                }
            }
        }

        // Ê∑ªÂä†Ë™øË©¶Ê™¢Êü•ÂäüËÉΩ
        async function debugCheck() {
            console.log('debugCheck function called');
            const apiKey = document.getElementById('apiKey').value;
            const apiConfig = getCurrentAPIConfig();
            const apiUrl = apiConfig.endpoint;

            if (!apiKey) {
                showError('Please enter API Key first');
                return;
            }

            clearMessages();
            showSuccess('Performing debug check...');

            try {
                // ÂòóË©¶‰∏ÄÂÄãÁ∞°ÂñÆÁöÑË´ãÊ±Ç‰æÜÈÄ≤Ë°åË™øË©¶Ê™¢Êü•
                const response = await fetch(apiUrl, {
                    method: 'OPTIONS',
                    headers: {
                        'X-API-KEY': apiKey,
                    }
                });

                console.log('Debug check response:', response.status, response.statusText);

                if (response.status === 405) {
                    showSuccess('‚úÖ Debug check successful!');
                } else if (response.status === 200 || response.status === 204) {
                    showError('‚ùå Debug check failed: Received non-405 status code');
                } else {
                    showError(`‚ö†Ô∏è Received response status: ${response.status} ${response.statusText}`);
                }

            } catch (error) {
                console.error('Debug check error:', error);
                if (error.message.includes('CORS')) {
                    showError('‚ùå CORS Error: May need to run in a CORS-enabled environment.');
                } else if (error.message.includes('network')) {
                    showError('‚ùå Network Error: Check network connection and URL.');
                } else {
                    showError(`‚ùå Debug check failed: ${error.message}`);
                }
            }
        }


        
        function getCurrentApiUrl() {
            return getCurrentAPIConfig().endpoint;
        }

        // È†ÅÈù¢ËºâÂÖ•ÊôÇÁöÑÂàùÂßãÂåñ
        window.addEventListener('load', () => {
            console.log('üöÄ Parrot API Multi-Task Frontend Loaded');
            
            // APIÈÖçÁΩÆÂ∑≤Âõ∫ÂÆöÁÇ∫stagingÁí∞Â¢É
            updateProviderVersions(); // ÂàùÂßãÂåñÊèê‰æõÂïÜÂíåversionÈÅ∏Êìá
            // ÂàùÂßãÂåñ Benchmark ÂçÄÂüü
            try {
                document.getElementById('benchmarkToggle')?.addEventListener('change', (e) => {
                    const on = e.target.checked;
                    document.getElementById('benchmarkConfig')?.classList.toggle('hidden', !on);
                    if (on) updateProviderVersionsB();
                });
            } catch {}
        });

        // È†ÅÈù¢Âç∏ËºâÊôÇÊ∏ÖÁêÜ
        window.addEventListener('beforeunload', () => {
            stopStatusCheck();
        });

        async function minimaxTTS() {
            try {
                const text = document.getElementById('minimaxText').value.trim();
                const voiceId = document.getElementById('minimaxVoiceId').value.trim();
                const groupId = document.getElementById('minimaxGroupId').value.trim();
                const apiKey = document.getElementById('minimaxApiKey').value.trim();

                if (!text) {
                    showError('Ë´ãÂÖàËº∏ÂÖ•ÊñáÊú¨');
                    return;
                }
                if (!groupId && !apiKey) {
                    showError('Ë´ãÂ°´ÂØ´ MINIMAX_GROUPID Ëàá MINIMAX_API_KEYÔºåÊàñÂú®ServerË®≠ÁΩÆÁí∞Â¢ÉËÆäÈáè');
                    return;
                }

                clearMessages();
                showSuccess('‚è≥ Ê≠£Âú®ÁîüÊàêÈü≥È†ªÔºåË´ãÁ®çÂÄô...');

                const body = { text };
                if (window.minimaxCurrentVoiceId) body.voice_id = window.minimaxCurrentVoiceId;

                const response = await fetch('/minimax/t2a', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(body)
                });

                if (!response.ok) {
                    let errJson = {}, errText = '';
                    try { errText = await response.text(); errJson = JSON.parse(errText); } catch { errJson = {}; }
                    const code = errJson.provider_status_code ?? errJson.status ?? errJson.base_resp?.status_code;
                    const msg = errJson.provider_status_msg ?? errJson.base_resp?.status_msg ?? (errJson.provider_response?.base_resp?.status_msg);
                    const base = errJson.error || errJson.message || 'Request failed';
                    const details = `${base}${code ? ` [${code}]` : ''}${msg ? `: ${msg}` : ''}`;
                    console.error('Minimax TTS failed:', { status: response.status, bodyText: errText, parsed: errJson });
                    throw new Error(details || `HTTP ${response.status}`);
                }

                const blob = await response.blob();
                const url = URL.createObjectURL(blob);
                const player = document.getElementById('minimaxAudioPlayer');
                const link = document.getElementById('minimaxAudioLink');

                player.src = url;
                player.style.display = 'block';
                link.href = url;
                link.download = `minimax-${Date.now()}.mp3`;
                link.style.display = 'inline-block';

                showSuccess('‚úÖ ÁîüÊàêÊàêÂäüÔºåÂèØÊí≠ÊîæÊàñ‰∏ãËºâ');
            } catch (e) {
                showError(`‚ùå ÁîüÊàêÂ§±Êïó: ${e.message}`);
            }
        }

        async function onStartButtonClick() {
            const isBenchmark = document.getElementById('benchmarkToggle')?.checked;
            const provider = document.getElementById('apiProvider')?.value;
            if (!isBenchmark) {
                if (provider === 'minimax') {
                    await minimaxTTS();
                } else {
                    await generateVideo();
                }
                return;
            }

            // Benchmark Ê®°ÂºèÔºöÂêå‰∏ÄÊâπÂúñÁâáÔºåÂàÜÂà•Áî® A/B ÂÖ©ÁµÑÈÖçÁΩÆÊèê‰∫§Ôºà‰ΩøÁî® Benchmark ÂçÄÂüüÁöÑ PromptÔºâ
            const images = Array.from(document.getElementById('imageFile').files || []);
            if (images.length === 0) { showError('Please select at least one image file'); return; }

            const aKey = document.getElementById('apiKey')?.value || '';
            const bKey = document.getElementById('apiKeyB')?.value || '';
            const aCfg = getCurrentAPIConfig();
            const bCfg = getCurrentAPIConfigB();
            const promptA = document.getElementById('promptTextA')?.value || '';
            const promptB = document.getElementById('promptTextB')?.value || '';

            for (const img of images) {
                // AÔºöË¶ÜÂØ´ÂèÉÊï∏ÂæåÂæ©Áî®ÂéüÊúâ submitTaskÔºà‰øùÁïô‰ªªÂãô/Ëº™Ë©¢/ÈåØË™§ËôïÁêÜÔºâ
                window.benchmarkOverrideConfig = aCfg;
                window.benchmarkOverrideApiKey = aKey;
                window.benchmarkOverridePrompt = promptA;
                window.benchmarkLabel = 'A';
                window.benchmarkImageName = img.name || '';
                await submitTask(img);
                // BÔºö
                window.benchmarkOverrideConfig = bCfg;
                window.benchmarkOverrideApiKey = bKey;
                window.benchmarkOverridePrompt = promptB;
                window.benchmarkLabel = 'B';
                window.benchmarkImageName = img.name || '';
                await submitTask(img);
                // Ê∏ÖÁêÜ
                window.benchmarkOverrideConfig = null;
                window.benchmarkOverrideApiKey = null;
                window.benchmarkOverridePrompt = null;
                window.benchmarkLabel = null;
                window.benchmarkImageName = null;
            }
        }

        // Minimax Clone ÂâçÁ´Ø‰∫§‰∫íÔºàËá™ÂãïÂÖãÈöÜÔºâ
        let minimaxCurrentVoiceId = '';
        (function initMinimaxCloneUI(){
            const upload = document.getElementById('minimaxCloneUpload');
            const input = document.getElementById('minimaxCloneFile');
            const nameEl = document.getElementById('minimaxCloneFileName');
            const statusEl = document.getElementById('minimaxCloneStatus');
            if (!upload || !input) return;
            upload.addEventListener('click', () => input.click());
            upload.addEventListener('dragover', e => { e.preventDefault(); upload.classList.add('drag-over'); });
            upload.addEventListener('dragleave', () => upload.classList.remove('drag-over'));
            upload.addEventListener('drop', e => {
                e.preventDefault(); upload.classList.remove('drag-over');
                if (e.dataTransfer?.files?.length){ input.files = e.dataTransfer.files; if (nameEl) nameEl.textContent = `Selected: ${e.dataTransfer.files[0].name}`; autoClone(); }
            });
            input.addEventListener('change', () => { const f = input.files?.[0]; if (nameEl) nameEl.textContent = f ? `Selected: ${f.name}` : ''; if (f) autoClone(); });

            async function autoClone() {
                try {
                    console.log('üöÄ AUTO CLONE STARTED!!!');
                    const f = input.files?.[0];
                    if (!f) return;
                    
                    // Ê™¢Êü•Êñá‰ª∂È°ûÂûãÔºàÊîØÊåÅÈü≥È†ªÂíåË¶ñÈ†ªÊñá‰ª∂Ôºâ
                    const isAudio = f.type.startsWith('audio/') || f.name.match(/\.(mp3|wav|m4a|aac|ogg|flac)$/i);
                    const isVideo = f.type.startsWith('video/') || f.name.match(/\.(mp4|mov|avi|mkv)$/i);
                    if (!isAudio && !isVideo) {
                        if (statusEl) statusEl.textContent = '‚ùå Ë´ã‰∏äÂÇ≥Èü≥È†ªÊàñË¶ñÈ†ªÊñá‰ª∂';
                        showError('Ë´ã‰∏äÂÇ≥Èü≥È†ªÊñá‰ª∂ÔºàMP3/WAV/M4AÁ≠âÔºâÊàñË¶ñÈ†ªÊñá‰ª∂ÔºàMP4Á≠âÔºåÂ∞áËá™ÂãïÊèêÂèñÈü≥È†ªÔºâ');
                        return;
                    }
                    
                    clearMessages();
                    if (statusEl) statusEl.textContent = '‚è≥ Ê≠£Âú®‰∏äÂÇ≥‰∏¶ÂÖãÈöÜ...';
                    console.log('üîÑ About to send request to /minimax/clone');
                    const fd = new FormData();
                    fd.append('audio', f);
                    const resp = await fetch('/minimax/clone', { method: 'POST', body: fd });
                    console.log('üì° Got response, status:', resp.status);
                    let text = '', data = {};
                    try { text = await resp.text(); console.log('üìÑ Raw response text:', text); data = JSON.parse(text); } catch { data = {}; }
                    console.log('üîç Minimax /clone response:', { status: resp.status, raw: text, parsed: data });
                    if (!resp.ok) { 
                        const code = data.provider_status_code ?? data.status ?? data.base_resp?.status_code;
                        const msg = data.provider_status_msg ?? data.base_resp?.status_msg ?? (data.provider_response?.base_resp?.status_msg);
                        const base = data.error || data.message || 'Request failed';
                        const details = `${base}${code ? ` [${code}]` : ''}${msg ? `: ${msg}` : ''}`;
                        console.error('‚ùå Minimax clone failed:', { status: resp.status, raw: text, parsed: data });
                        throw new Error(details || `HTTP ${resp.status}`); 
                    }
                    if (data.voice_id) {
                        minimaxCurrentVoiceId = data.voice_id;
                        if (statusEl) statusEl.textContent = `‚úÖ ÂÖãÈöÜÊàêÂäü voice_id: ${data.voice_id}`;
                        showSuccess(`‚úÖ Ë™ûÈü≥ÂÖãÈöÜÊàêÂäüÔºåvoice_id: ${data.voice_id}`);
                    }
                    if (data.preview_audio) {
                        const p = document.getElementById('minimaxClonePreview');
                        p.src = data.preview_audio; p.style.display = 'block';
                    }
                } catch (e) {
                    if (statusEl) statusEl.textContent = `‚ùå ÂÖãÈöÜÂ§±Êïó: ${e.message}`;
                    showError(`‚ùå ÂÖãÈöÜÂ§±Êïó: ${e.message}`);
                }
            }
        })();
    </script>
</body>
</html> 